define('@glimmer/syntax', ['exports', '@glimmer/env', '@glimmer/util', '@handlebars/parser', 'simple-html-tokenizer'], function (exports, env, util, parser, simpleHtmlTokenizer) { 'use strict';

  var UNKNOWN_POSITION = Object.freeze({
    line: 1,
    column: 0
  });
  var SYNTHETIC_LOCATION = Object.freeze({
    source: '(synthetic)',
    start: UNKNOWN_POSITION,
    end: UNKNOWN_POSITION
  });
  var TEMPORARY_LOCATION = Object.freeze({
    source: '(temporary)',
    start: UNKNOWN_POSITION,
    end: UNKNOWN_POSITION
  });
  var NON_EXISTENT_LOCATION = Object.freeze({
    source: '(nonexistent)',
    start: UNKNOWN_POSITION,
    end: UNKNOWN_POSITION
  });
  var BROKEN_LOCATION = Object.freeze({
    source: '(broken)',
    start: UNKNOWN_POSITION,
    end: UNKNOWN_POSITION
  });

  var SourceSlice = /*#__PURE__*/function () {
    function SourceSlice(options) {
      this.loc = options.loc;
      this.chars = options.chars;
    }

    SourceSlice.synthetic = function synthetic(chars) {
      var offsets = SourceSpan.synthetic(chars);
      return new SourceSlice({
        loc: offsets,
        chars: chars
      });
    };

    SourceSlice.load = function load(source, slice) {
      return new SourceSlice({
        loc: SourceSpan.load(source, slice[1]),
        chars: slice[0]
      });
    };

    var _proto = SourceSlice.prototype;

    _proto.getString = function getString() {
      return this.chars;
    };

    _proto.serialize = function serialize() {
      return [this.chars, this.loc.serialize()];
    };

    return SourceSlice;
  }();

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }

    privateMap.set(receiver, value);
    return value;
  };

  var __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }

    return privateMap.get(receiver);
  };

  var _whens, _map, _whens_1;
  /**
   * This file implements the DSL used by span and offset in places where they need to exhaustively
   * consider all combinations of states (Handlebars offsets, character offsets and invisible/broken
   * offsets).
   *
   * It's probably overkill, but it makes the code that uses it clear. It could be refactored or
   * removed.
   */

  var MatchAny = 'MATCH_ANY';
  var IsInvisible = 'IS_INVISIBLE';

  var WhenList = /*#__PURE__*/function () {
    function WhenList(whens) {
      _whens.set(this, void 0);

      __classPrivateFieldSet(this, _whens, whens);
    }

    var _proto = WhenList.prototype;

    _proto.first = function first(kind) {
      for (var _iterator = _createForOfIteratorHelperLoose(__classPrivateFieldGet(this, _whens)), _step; !(_step = _iterator()).done;) {
        var when = _step.value;
        var value = when.match(kind);

        if (util.isPresent(value)) {
          return value[0];
        }
      }

      return null;
    };

    return WhenList;
  }();

  _whens = new WeakMap();

  var When = /*#__PURE__*/function () {
    function When() {
      _map.set(this, new Map());
    }

    var _proto2 = When.prototype;

    _proto2.get = function get(pattern, or) {
      var value = __classPrivateFieldGet(this, _map).get(pattern);

      if (value) {
        return value;
      }

      value = or();

      __classPrivateFieldGet(this, _map).set(pattern, value);

      return value;
    };

    _proto2.add = function add(pattern, out) {
      __classPrivateFieldGet(this, _map).set(pattern, out);
    };

    _proto2.match = function match(kind) {
      var pattern = patternFor(kind);
      var out = [];

      var exact = __classPrivateFieldGet(this, _map).get(pattern);

      var fallback = __classPrivateFieldGet(this, _map).get(MatchAny);

      if (exact) {
        out.push(exact);
      }

      if (fallback) {
        out.push(fallback);
      }

      return out;
    };

    return When;
  }();

  _map = new WeakMap();
  function match(callback) {
    return callback(new Matcher()).check();
  }

  var Matcher = /*#__PURE__*/function () {
    function Matcher() {
      _whens_1.set(this, new When());
    }
    /**
     * You didn't exhaustively match all possibilities.
     */


    var _proto3 = Matcher.prototype;

    _proto3.check = function check() {
      var _this = this;

      return function (left, right) {
        return _this.matchFor(left.kind, right.kind)(left, right);
      };
    };

    _proto3.matchFor = function matchFor(left, right) {
      var nesteds = __classPrivateFieldGet(this, _whens_1).match(left);
      var callback = new WhenList(nesteds).first(right);
      return callback;
    };

    _proto3.when = function when(left, right, // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callback) {
      __classPrivateFieldGet(this, _whens_1).get(left, function () {
        return new When();
      }).add(right, callback);

      return this;
    };

    return Matcher;
  }();

  _whens_1 = new WeakMap();

  function patternFor(kind) {
    switch (kind) {
      case "Broken"
      /* Broken */
      :
      case "InternalsSynthetic"
      /* InternalsSynthetic */
      :
      case "NonExistent"
      /* NonExistent */
      :
        return IsInvisible;

      default:
        return kind;
    }
  }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var __classPrivateFieldGet$1 = undefined && undefined.__classPrivateFieldGet || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }

    return privateMap.get(receiver);
  };

  var __classPrivateFieldSet$1 = undefined && undefined.__classPrivateFieldSet || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }

    privateMap.set(receiver, value);
    return value;
  };

  var _locPos, _charPos; // eslint-disable-next-line import/no-extraneous-dependencies
  /**
   * Used to indicate that an attempt to convert a `SourcePosition` to a character offset failed. It
   * is separate from `null` so that `null` can be used to indicate that the computation wasn't yet
   * attempted (and therefore to cache the failure)
   */

  var BROKEN = 'BROKEN';
  /**
   * A `SourceOffset` represents a single position in the source.
   *
   * There are three kinds of backing data for `SourceOffset` objects:
   *
   * - `CharPosition`, which contains a character offset into the raw source string
   * - `HbsPosition`, which contains a `SourcePosition` from the Handlebars AST, which can be
   *   converted to a `CharPosition` on demand.
   * - `InvisiblePosition`, which represents a position not in source (@see {InvisiblePosition})
   */

  var SourceOffset = /*#__PURE__*/function () {
    function SourceOffset(data) {
      this.data = data;
    }
    /**
     * Create a `SourceOffset` from a Handlebars `SourcePosition`. It's stored as-is, and converted
     * into a character offset on demand, which avoids unnecessarily computing the offset of every
     * `SourceLocation`, but also means that broken `SourcePosition`s are not always detected.
     */


    SourceOffset.forHbsPos = function forHbsPos(source, pos) {
      return new HbsPosition(source, pos, null).wrap();
    }
    /**
     * Create a `SourceOffset` that corresponds to a broken `SourcePosition`. This means that the
     * calling code determined (or knows) that the `SourceLocation` doesn't correspond correctly to
     * any part of the source.
     */
    ;

    SourceOffset.broken = function broken(pos) {
      if (pos === void 0) {
        pos = UNKNOWN_POSITION;
      }

      return new InvisiblePosition("Broken"
      /* Broken */
      , pos).wrap();
    }
    /**
     * Get the character offset for this `SourceOffset`, if possible.
     */
    ;

    var _proto = SourceOffset.prototype;

    /**
     * Compare this offset with another one.
     *
     * If both offsets are `HbsPosition`s, they're equivalent as long as their lines and columns are
     * the same. This avoids computing offsets unnecessarily.
     *
     * Otherwise, two `SourceOffset`s are equivalent if their successfully computed character offsets
     * are the same.
     */
    _proto.eql = function eql(right) {
      return _eql(this.data, right.data);
    }
    /**
     * Create a span that starts from this source offset and ends with another source offset. Avoid
     * computing character offsets if both `SourceOffset`s are still lazy.
     */
    ;

    _proto.until = function until(other) {
      return span(this.data, other.data);
    }
    /**
     * Create a `SourceOffset` by moving the character position represented by this source offset
     * forward or backward (if `by` is negative), if possible.
     *
     * If this `SourceOffset` can't compute a valid character offset, `move` returns a broken offset.
     *
     * If the resulting character offset is less than 0 or greater than the size of the source, `move`
     * returns a broken offset.
     */
    ;

    _proto.move = function move(by) {
      var charPos = this.data.toCharPos();

      if (charPos === null) {
        return SourceOffset.broken();
      } else {
        var result = charPos.offset + by;

        if (charPos.source.check(result)) {
          return new CharPosition(charPos.source, result).wrap();
        } else {
          return SourceOffset.broken();
        }
      }
    }
    /**
     * Create a new `SourceSpan` that represents a collapsed range at this source offset. Avoid
     * computing the character offset if it has not already been computed.
     */
    ;

    _proto.collapsed = function collapsed() {
      return span(this.data, this.data);
    }
    /**
     * Convert this `SourceOffset` into a Handlebars {@see SourcePosition} for compatibility with
     * existing plugins.
     */
    ;

    _proto.toJSON = function toJSON() {
      return this.data.toJSON();
    };

    _createClass(SourceOffset, [{
      key: "offset",
      get: function get() {
        var charPos = this.data.toCharPos();
        return charPos === null ? null : charPos.offset;
      }
    }]);

    return SourceOffset;
  }();
  var CharPosition = /*#__PURE__*/function () {
    function CharPosition(source, charPos) {
      this.source = source;
      this.charPos = charPos;
      this.kind = "CharPosition"
      /* CharPosition */
      ;
      /** Computed from char offset */

      _locPos.set(this, null);
    }
    /**
     * This is already a `CharPosition`.
     *
     * {@see HbsPosition} for the alternative.
     *
     * @implements {PositionData}
     */


    var _proto2 = CharPosition.prototype;

    _proto2.toCharPos = function toCharPos() {
      return this;
    }
    /**
     * Produce a Handlebars {@see SourcePosition} for this `CharPosition`. If this `CharPosition` was
     * computed using {@see SourceOffset#move}, this will compute the `SourcePosition` for the offset.
     *
     * @implements {PositionData}
     */
    ;

    _proto2.toJSON = function toJSON() {
      var hbs = this.toHbsPos();
      return hbs === null ? UNKNOWN_POSITION : hbs.toJSON();
    };

    _proto2.wrap = function wrap() {
      return new SourceOffset(this);
    }
    /**
     * A `CharPosition` always has an offset it can produce without any additional computation.
     */
    ;

    /**
     * Convert the current character offset to an `HbsPosition`, if it was not already computed. Once
     * a `CharPosition` has computed its `HbsPosition`, it will not need to do compute it again, and
     * the same `CharPosition` is retained when used as one of the ends of a `SourceSpan`, so
     * computing the `HbsPosition` should be a one-time operation.
     */
    _proto2.toHbsPos = function toHbsPos() {
      var locPos = __classPrivateFieldGet$1(this, _locPos);

      if (locPos === null) {
        var hbsPos = this.source.hbsPosFor(this.charPos);

        if (hbsPos === null) {
          __classPrivateFieldSet$1(this, _locPos, locPos = BROKEN);
        } else {
          __classPrivateFieldSet$1(this, _locPos, locPos = new HbsPosition(this.source, hbsPos, this.charPos));
        }
      }

      return locPos === BROKEN ? null : locPos;
    };

    _createClass(CharPosition, [{
      key: "offset",
      get: function get() {
        return this.charPos;
      }
    }]);

    return CharPosition;
  }();
  _locPos = new WeakMap();
  var HbsPosition = /*#__PURE__*/function () {
    function HbsPosition(source, hbsPos, charPos) {
      if (charPos === void 0) {
        charPos = null;
      }

      this.source = source;
      this.hbsPos = hbsPos;
      this.kind = "HbsPosition"
      /* HbsPosition */
      ;

      _charPos.set(this, void 0);

      __classPrivateFieldSet$1(this, _charPos, charPos === null ? null : new CharPosition(source, charPos));
    }
    /**
     * Lazily compute the character offset from the {@see SourcePosition}. Once an `HbsPosition` has
     * computed its `CharPosition`, it will not need to do compute it again, and the same
     * `HbsPosition` is retained when used as one of the ends of a `SourceSpan`, so computing the
     * `CharPosition` should be a one-time operation.
     *
     * @implements {PositionData}
     */


    var _proto3 = HbsPosition.prototype;

    _proto3.toCharPos = function toCharPos() {
      var charPos = __classPrivateFieldGet$1(this, _charPos);

      if (charPos === null) {
        var charPosNumber = this.source.charPosFor(this.hbsPos);

        if (charPosNumber === null) {
          __classPrivateFieldSet$1(this, _charPos, charPos = BROKEN);
        } else {
          __classPrivateFieldSet$1(this, _charPos, charPos = new CharPosition(this.source, charPosNumber));
        }
      }

      return charPos === BROKEN ? null : charPos;
    }
    /**
     * Return the {@see SourcePosition} that this `HbsPosition` was instantiated with. This operation
     * does not need to compute anything.
     *
     * @implements {PositionData}
     */
    ;

    _proto3.toJSON = function toJSON() {
      return this.hbsPos;
    };

    _proto3.wrap = function wrap() {
      return new SourceOffset(this);
    }
    /**
     * This is already an `HbsPosition`.
     *
     * {@see CharPosition} for the alternative.
     */
    ;

    _proto3.toHbsPos = function toHbsPos() {
      return this;
    };

    return HbsPosition;
  }();
  _charPos = new WeakMap();
  var InvisiblePosition = /*#__PURE__*/function () {
    function InvisiblePosition(kind, // whatever was provided, possibly broken
    pos) {
      this.kind = kind;
      this.pos = pos;
    }
    /**
     * A broken position cannot be turned into a {@see CharacterPosition}.
     */


    var _proto4 = InvisiblePosition.prototype;

    _proto4.toCharPos = function toCharPos() {
      return null;
    }
    /**
     * The serialization of an `InvisiblePosition is whatever Handlebars {@see SourcePosition} was
     * originally identified as broken, non-existent or synthetic.
     *
     * If an `InvisiblePosition` never had an source offset at all, this method returns
     * {@see UNKNOWN_POSITION} for compatibility.
     */
    ;

    _proto4.toJSON = function toJSON() {
      return this.pos;
    };

    _proto4.wrap = function wrap() {
      return new SourceOffset(this);
    };

    _createClass(InvisiblePosition, [{
      key: "offset",
      get: function get() {
        return null;
      }
    }]);

    return InvisiblePosition;
  }();
  /**
   * Compare two {@see AnyPosition} and determine whether they are equal.
   *
   * @see {SourceOffset#eql}
   */

  var _eql = match(function (m) {
    return m.when("HbsPosition"
    /* HbsPosition */
    , "HbsPosition"
    /* HbsPosition */
    , function (_ref, _ref2) {
      var left = _ref.hbsPos;
      var right = _ref2.hbsPos;
      return left.column === right.column && left.line === right.line;
    }).when("CharPosition"
    /* CharPosition */
    , "CharPosition"
    /* CharPosition */
    , function (_ref3, _ref4) {
      var left = _ref3.charPos;
      var right = _ref4.charPos;
      return left === right;
    }).when("CharPosition"
    /* CharPosition */
    , "HbsPosition"
    /* HbsPosition */
    , function (_ref5, right) {
      var left = _ref5.offset;

      var _a;

      return left === ((_a = right.toCharPos()) === null || _a === void 0 ? void 0 : _a.offset);
    }).when("HbsPosition"
    /* HbsPosition */
    , "CharPosition"
    /* CharPosition */
    , function (left, _ref6) {
      var right = _ref6.offset;

      var _a;

      return ((_a = left.toCharPos()) === null || _a === void 0 ? void 0 : _a.offset) === right;
    }).when(MatchAny, MatchAny, function () {
      return false;
    });
  });

  function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }

  var __classPrivateFieldGet$2 = undefined && undefined.__classPrivateFieldGet || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }

    return privateMap.get(receiver);
  };

  var __classPrivateFieldSet$2 = undefined && undefined.__classPrivateFieldSet || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }

    privateMap.set(receiver, value);
    return value;
  };

  var _locPosSpan, _charPosSpan, _providedHbsLoc; // eslint-disable-next-line import/no-extraneous-dependencies
  /**
   * A `SourceSpan` object represents a span of characters inside of a template source.
   *
   * There are three kinds of `SourceSpan` objects:
   *
   * - `ConcreteSourceSpan`, which contains byte offsets
   * - `LazySourceSpan`, which contains `SourceLocation`s from the Handlebars AST, which can be
   *   converted to byte offsets on demand.
   * - `InvisibleSourceSpan`, which represent source strings that aren't present in the source,
   *   because:
   *     - they were created synthetically
   *     - their location is nonsensical (the span is broken)
   *     - they represent nothing in the source (this currently happens only when a bug in the
   *       upstream Handlebars parser fails to assign a location to empty blocks)
   *
   * At a high level, all `SourceSpan` objects provide:
   *
   * - byte offsets
   * - source in column and line format
   *
   * And you can do these operations on `SourceSpan`s:
   *
   * - collapse it to a `SourceSpan` representing its starting or ending position
   * - slice out some characters, optionally skipping some characters at the beginning or end
   * - create a new `SourceSpan` with a different starting or ending offset
   *
   * All SourceSpan objects implement `SourceLocation`, for compatibility. All SourceSpan
   * objects have a `toJSON` that emits `SourceLocation`, also for compatibility.
   *
   * For compatibility, subclasses of `AbstractSourceSpan` must implement `locDidUpdate`, which
   * happens when an AST plugin attempts to modify the `start` or `end` of a span directly.
   *
   * The goal is to avoid creating any problems for use-cases like AST Explorer.
   */

  var SourceSpan = /*#__PURE__*/function () {
    function SourceSpan(data) {
      this.data = data;
      this.isInvisible = data.kind !== "CharPosition"
      /* CharPosition */
      && data.kind !== "HbsPosition"
      /* HbsPosition */
      ;
    }

    SourceSpan.load = function load(source, serialized) {
      if (typeof serialized === 'number') {
        return SourceSpan.forCharPositions(source, serialized, serialized);
      } else if (typeof serialized === 'string') {
        return SourceSpan.synthetic(serialized);
      } else if (Array.isArray(serialized)) {
        return SourceSpan.forCharPositions(source, serialized[0], serialized[1]);
      } else if (serialized === "NonExistent"
      /* NonExistent */
      ) {
          return SourceSpan.NON_EXISTENT;
        } else if (serialized === "Broken"
      /* Broken */
      ) {
          return SourceSpan.broken(BROKEN_LOCATION);
        }

      util.assertNever(serialized);
    };

    SourceSpan.forHbsLoc = function forHbsLoc(source, loc) {
      var start = new HbsPosition(source, loc.start);
      var end = new HbsPosition(source, loc.end);
      return new HbsSpan(source, {
        start: start,
        end: end
      }, loc).wrap();
    };

    SourceSpan.forCharPositions = function forCharPositions(source, startPos, endPos) {
      var start = new CharPosition(source, startPos);
      var end = new CharPosition(source, endPos);
      return new CharPositionSpan(source, {
        start: start,
        end: end
      }).wrap();
    };

    SourceSpan.synthetic = function synthetic(chars) {
      return new InvisibleSpan("InternalsSynthetic"
      /* InternalsSynthetic */
      , NON_EXISTENT_LOCATION, chars).wrap();
    };

    SourceSpan.broken = function broken(pos) {
      if (pos === void 0) {
        pos = BROKEN_LOCATION;
      }

      return new InvisibleSpan("Broken"
      /* Broken */
      , pos).wrap();
    };

    var _proto = SourceSpan.prototype;

    _proto.getStart = function getStart() {
      return this.data.getStart().wrap();
    };

    _proto.getEnd = function getEnd() {
      return this.data.getEnd().wrap();
    };

    /**
     * Support converting ASTv1 nodes into a serialized format using JSON.stringify.
     */
    _proto.toJSON = function toJSON() {
      return this.loc;
    }
    /**
     * Create a new span with the current span's end and a new beginning.
     */
    ;

    _proto.withStart = function withStart(other) {
      return span(other.data, this.data.getEnd());
    }
    /**
     * Create a new span with the current span's beginning and a new ending.
     */
    ;

    _proto.withEnd = function withEnd(other) {
      return span(this.data.getStart(), other.data);
    };

    _proto.asString = function asString() {
      return this.data.asString();
    }
    /**
     * Convert this `SourceSpan` into a `SourceSlice`. In debug mode, this method optionally checks
     * that the byte offsets represented by this `SourceSpan` actually correspond to the expected
     * string.
     */
    ;

    _proto.toSlice = function toSlice(expected) {
      var chars = this.data.asString();

      if (env.DEBUG) {
        if (expected !== undefined && chars !== expected) {
          // eslint-disable-next-line no-console
          console.warn("unexpectedly found " + JSON.stringify(chars) + " when slicing source, but expected " + JSON.stringify(expected));
        }
      }

      return new SourceSlice({
        loc: this,
        chars: expected || chars
      });
    }
    /**
     * For compatibility with SourceLocation in AST plugins
     *
     * @deprecated use startPosition instead
     */
    ;

    _proto.collapse = function collapse(where) {
      switch (where) {
        case 'start':
          return this.getStart().collapsed();

        case 'end':
          return this.getEnd().collapsed();
      }
    };

    _proto.extend = function extend(other) {
      return span(this.data.getStart(), other.data.getEnd());
    };

    _proto.serialize = function serialize() {
      return this.data.serialize();
    };

    _proto.slice = function slice(_ref) {
      var _ref$skipStart = _ref.skipStart,
          skipStart = _ref$skipStart === void 0 ? 0 : _ref$skipStart,
          _ref$skipEnd = _ref.skipEnd,
          skipEnd = _ref$skipEnd === void 0 ? 0 : _ref$skipEnd;
      return span(this.getStart().move(skipStart).data, this.getEnd().move(-skipEnd).data);
    };

    _proto.sliceStartChars = function sliceStartChars(_ref2) {
      var _ref2$skipStart = _ref2.skipStart,
          skipStart = _ref2$skipStart === void 0 ? 0 : _ref2$skipStart,
          chars = _ref2.chars;
      return span(this.getStart().move(skipStart).data, this.getStart().move(skipStart + chars).data);
    };

    _proto.sliceEndChars = function sliceEndChars(_ref3) {
      var _ref3$skipEnd = _ref3.skipEnd,
          skipEnd = _ref3$skipEnd === void 0 ? 0 : _ref3$skipEnd,
          chars = _ref3.chars;
      return span(this.getEnd().move(skipEnd - chars).data, this.getStart().move(-skipEnd).data);
    };

    _createClass$1(SourceSpan, [{
      key: "loc",
      get: function get() {
        var span = this.data.toHbsSpan();
        return span === null ? BROKEN_LOCATION : span.toHbsLoc();
      }
    }, {
      key: "module",
      get: function get() {
        return this.data.getModule();
      }
      /**
       * Get the starting `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
       */

    }, {
      key: "startPosition",
      get: function get() {
        return this.loc.start;
      }
      /**
       * Get the ending `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
       */

    }, {
      key: "endPosition",
      get: function get() {
        return this.loc.end;
      }
    }, {
      key: "start",
      get: function get() {
        return this.loc.start;
      }
      /**
       * For compatibility with SourceLocation in AST plugins
       *
       * @deprecated use withStart instead
       */
      ,
      set: function set(position) {
        this.data.locDidUpdate({
          start: position
        });
      }
      /**
       * For compatibility with SourceLocation in AST plugins
       *
       * @deprecated use endPosition instead
       */

    }, {
      key: "end",
      get: function get() {
        return this.loc.end;
      }
      /**
       * For compatibility with SourceLocation in AST plugins
       *
       * @deprecated use withEnd instead
       */
      ,
      set: function set(position) {
        this.data.locDidUpdate({
          end: position
        });
      }
      /**
       * For compatibility with SourceLocation in AST plugins
       *
       * @deprecated use module instead
       */

    }, {
      key: "source",
      get: function get() {
        return this.module;
      }
    }], [{
      key: "NON_EXISTENT",
      get: function get() {
        return new InvisibleSpan("NonExistent"
        /* NonExistent */
        , NON_EXISTENT_LOCATION).wrap();
      }
    }]);

    return SourceSpan;
  }();

  var CharPositionSpan = /*#__PURE__*/function () {
    function CharPositionSpan(source, charPositions) {
      this.source = source;
      this.charPositions = charPositions;
      this.kind = "CharPosition"
      /* CharPosition */
      ;

      _locPosSpan.set(this, null);
    }

    var _proto2 = CharPositionSpan.prototype;

    _proto2.wrap = function wrap() {
      return new SourceSpan(this);
    };

    _proto2.asString = function asString() {
      return this.source.slice(this.charPositions.start.charPos, this.charPositions.end.charPos);
    };

    _proto2.getModule = function getModule() {
      return this.source.module;
    };

    _proto2.getStart = function getStart() {
      return this.charPositions.start;
    };

    _proto2.getEnd = function getEnd() {
      return this.charPositions.end;
    };

    _proto2.locDidUpdate = function locDidUpdate() {
    };

    _proto2.toHbsSpan = function toHbsSpan() {
      var locPosSpan = __classPrivateFieldGet$2(this, _locPosSpan);

      if (locPosSpan === null) {
        var start = this.charPositions.start.toHbsPos();
        var end = this.charPositions.end.toHbsPos();

        if (start === null || end === null) {
          locPosSpan = __classPrivateFieldSet$2(this, _locPosSpan, BROKEN);
        } else {
          locPosSpan = __classPrivateFieldSet$2(this, _locPosSpan, new HbsSpan(this.source, {
            start: start,
            end: end
          }));
        }
      }

      return locPosSpan === BROKEN ? null : locPosSpan;
    };

    _proto2.serialize = function serialize() {
      var _this$charPositions = this.charPositions,
          start = _this$charPositions.start.charPos,
          end = _this$charPositions.end.charPos;

      if (start === end) {
        return start;
      } else {
        return [start, end];
      }
    };

    _proto2.toCharPosSpan = function toCharPosSpan() {
      return this;
    };

    return CharPositionSpan;
  }();

  _locPosSpan = new WeakMap();
  var HbsSpan = /*#__PURE__*/function () {
    function HbsSpan(source, hbsPositions, providedHbsLoc) {
      if (providedHbsLoc === void 0) {
        providedHbsLoc = null;
      }

      this.source = source;
      this.hbsPositions = hbsPositions;
      this.kind = "HbsPosition"
      /* HbsPosition */
      ;

      _charPosSpan.set(this, null); // the source location from Handlebars + AST Plugins -- could be wrong


      _providedHbsLoc.set(this, void 0);

      __classPrivateFieldSet$2(this, _providedHbsLoc, providedHbsLoc);
    }

    var _proto3 = HbsSpan.prototype;

    _proto3.serialize = function serialize() {
      var charPos = this.toCharPosSpan();
      return charPos === null ? "Broken"
      /* Broken */
      : charPos.wrap().serialize();
    };

    _proto3.wrap = function wrap() {
      return new SourceSpan(this);
    };

    _proto3.updateProvided = function updateProvided(pos, edge) {
      if (__classPrivateFieldGet$2(this, _providedHbsLoc)) {
        __classPrivateFieldGet$2(this, _providedHbsLoc)[edge] = pos;
      } // invalidate computed character offsets


      __classPrivateFieldSet$2(this, _charPosSpan, null);

      __classPrivateFieldSet$2(this, _providedHbsLoc, {
        start: pos,
        end: pos
      });
    };

    _proto3.locDidUpdate = function locDidUpdate(_ref4) {
      var start = _ref4.start,
          end = _ref4.end;

      if (start !== undefined) {
        this.updateProvided(start, 'start');
        this.hbsPositions.start = new HbsPosition(this.source, start, null);
      }

      if (end !== undefined) {
        this.updateProvided(end, 'end');
        this.hbsPositions.end = new HbsPosition(this.source, end, null);
      }
    };

    _proto3.asString = function asString() {
      var span = this.toCharPosSpan();
      return span === null ? '' : span.asString();
    };

    _proto3.getModule = function getModule() {
      return this.source.module;
    };

    _proto3.getStart = function getStart() {
      return this.hbsPositions.start;
    };

    _proto3.getEnd = function getEnd() {
      return this.hbsPositions.end;
    };

    _proto3.toHbsLoc = function toHbsLoc() {
      return {
        start: this.hbsPositions.start.hbsPos,
        end: this.hbsPositions.end.hbsPos
      };
    };

    _proto3.toHbsSpan = function toHbsSpan() {
      return this;
    };

    _proto3.toCharPosSpan = function toCharPosSpan() {
      var charPosSpan = __classPrivateFieldGet$2(this, _charPosSpan);

      if (charPosSpan === null) {
        var start = this.hbsPositions.start.toCharPos();
        var end = this.hbsPositions.end.toCharPos();

        if (start && end) {
          charPosSpan = __classPrivateFieldSet$2(this, _charPosSpan, new CharPositionSpan(this.source, {
            start: start,
            end: end
          }));
        } else {
          charPosSpan = __classPrivateFieldSet$2(this, _charPosSpan, BROKEN);
          return null;
        }
      }

      return charPosSpan === BROKEN ? null : charPosSpan;
    };

    return HbsSpan;
  }();
  _charPosSpan = new WeakMap(), _providedHbsLoc = new WeakMap();

  var InvisibleSpan = /*#__PURE__*/function () {
    function InvisibleSpan(kind, // whatever was provided, possibly broken
    loc, // if the span represents a synthetic string
    string) {
      if (string === void 0) {
        string = null;
      }

      this.kind = kind;
      this.loc = loc;
      this.string = string;
    }

    var _proto4 = InvisibleSpan.prototype;

    _proto4.serialize = function serialize() {
      switch (this.kind) {
        case "Broken"
        /* Broken */
        :
        case "NonExistent"
        /* NonExistent */
        :
          return this.kind;

        case "InternalsSynthetic"
        /* InternalsSynthetic */
        :
          return this.string || '';
      }
    };

    _proto4.wrap = function wrap() {
      return new SourceSpan(this);
    };

    _proto4.asString = function asString() {
      return this.string || '';
    };

    _proto4.locDidUpdate = function locDidUpdate(_ref5) {
      var start = _ref5.start,
          end = _ref5.end;

      if (start !== undefined) {
        this.loc.start = start;
      }

      if (end !== undefined) {
        this.loc.end = end;
      }
    };

    _proto4.getModule = function getModule() {
      // TODO: Make this reflect the actual module this span originated from
      return 'an unknown module';
    };

    _proto4.getStart = function getStart() {
      return new InvisiblePosition(this.kind, this.loc.start);
    };

    _proto4.getEnd = function getEnd() {
      return new InvisiblePosition(this.kind, this.loc.end);
    };

    _proto4.toCharPosSpan = function toCharPosSpan() {
      return this;
    };

    _proto4.toHbsSpan = function toHbsSpan() {
      return null;
    };

    _proto4.toHbsLoc = function toHbsLoc() {
      return BROKEN_LOCATION;
    };

    return InvisibleSpan;
  }();

  var span = match(function (m) {
    return m.when("HbsPosition"
    /* HbsPosition */
    , "HbsPosition"
    /* HbsPosition */
    , function (left, right) {
      return new HbsSpan(left.source, {
        start: left,
        end: right
      }).wrap();
    }).when("CharPosition"
    /* CharPosition */
    , "CharPosition"
    /* CharPosition */
    , function (left, right) {
      return new CharPositionSpan(left.source, {
        start: left,
        end: right
      }).wrap();
    }).when("CharPosition"
    /* CharPosition */
    , "HbsPosition"
    /* HbsPosition */
    , function (left, right) {
      var rightCharPos = right.toCharPos();

      if (rightCharPos === null) {
        return new InvisibleSpan("Broken"
        /* Broken */
        , BROKEN_LOCATION).wrap();
      } else {
        return span(left, rightCharPos);
      }
    }).when("HbsPosition"
    /* HbsPosition */
    , "CharPosition"
    /* CharPosition */
    , function (left, right) {
      var leftCharPos = left.toCharPos();

      if (leftCharPos === null) {
        return new InvisibleSpan("Broken"
        /* Broken */
        , BROKEN_LOCATION).wrap();
      } else {
        return span(leftCharPos, right);
      }
    }).when(IsInvisible, MatchAny, function (left) {
      return new InvisibleSpan(left.kind, BROKEN_LOCATION).wrap();
    }).when(MatchAny, IsInvisible, function (_, right) {
      return new InvisibleSpan(right.kind, BROKEN_LOCATION).wrap();
    });
  });

  // eslint-disable-next-line import/no-extraneous-dependencies
  var Source = /*#__PURE__*/function () {
    function Source(source, module) {
      if (module === void 0) {
        module = 'an unknown module';
      }

      this.source = source;
      this.module = module;
    }
    /**
     * Validate that the character offset represents a position in the source string.
     */


    var _proto = Source.prototype;

    _proto.check = function check(offset) {
      return offset >= 0 && offset <= this.source.length;
    };

    _proto.slice = function slice(start, end) {
      return this.source.slice(start, end);
    };

    _proto.offsetFor = function offsetFor(line, column) {
      return SourceOffset.forHbsPos(this, {
        line: line,
        column: column
      });
    };

    _proto.spanFor = function spanFor(_ref) {
      var start = _ref.start,
          end = _ref.end;
      return SourceSpan.forHbsLoc(this, {
        start: {
          line: start.line,
          column: start.column
        },
        end: {
          line: end.line,
          column: end.column
        }
      });
    };

    _proto.hbsPosFor = function hbsPosFor(offset) {
      var seenLines = 0;
      var seenChars = 0;

      if (offset > this.source.length) {
        return null;
      }

      while (true) {
        var nextLine = this.source.indexOf('\n', seenChars);

        if (offset <= nextLine || nextLine === -1) {
          return {
            line: seenLines + 1,
            column: offset - seenChars
          };
        } else {
          seenLines += 1;
          seenChars = nextLine + 1;
        }
      }
    };

    _proto.charPosFor = function charPosFor(position) {
      var line = position.line,
          column = position.column;
      var sourceString = this.source;
      var sourceLength = sourceString.length;
      var seenLines = 0;
      var seenChars = 0;

      while (true) {
        if (seenChars >= sourceLength) return sourceLength;
        var nextLine = this.source.indexOf('\n', seenChars);
        if (nextLine === -1) nextLine = this.source.length;

        if (seenLines === line - 1) {
          if (seenChars + column > nextLine) return nextLine;

          if (env.DEBUG) {
            var roundTrip = this.hbsPosFor(seenChars + column);
          }

          return seenChars + column;
        } else if (nextLine === -1) {
          return 0;
        } else {
          seenLines += 1;
          seenChars = nextLine + 1;
        }
      }
    };

    return Source;
  }();

  function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }
  var PathExpressionImplV1 = /*#__PURE__*/function () {
    function PathExpressionImplV1(original, head, tail, loc) {
      this.original = original;
      this.loc = loc;
      this.type = 'PathExpression';
      this["this"] = false;
      this.data = false;
      var parts = tail.slice();

      if (head.type === 'ThisHead') {
        this["this"] = true;
      } else if (head.type === 'AtHead') {
        this.data = true;
        parts.unshift(head.name.slice(1));
      } else {
        parts.unshift(head.name);
      }

      this.parts = parts;
    }

    _createClass$2(PathExpressionImplV1, [{
      key: "head",
      get: function get() {
        var firstPart;

        if (this["this"]) {
          firstPart = 'this';
        } else if (this.data) {
          firstPart = "@" + this.parts[0];
        } else {
          firstPart = this.parts[0];
        }

        var firstPartLoc = this.loc.collapse('start').sliceStartChars({
          chars: firstPart.length
        }).loc;
        return publicBuilder.head(firstPart, firstPartLoc);
      }
    }, {
      key: "tail",
      get: function get() {
        return this["this"] ? this.parts : this.parts.slice(1);
      }
    }]);

    return PathExpressionImplV1;
  }();

  var _SOURCE;

  function SOURCE() {
    if (!_SOURCE) {
      _SOURCE = new Source('', '(synthetic)');
    }

    return _SOURCE;
  }

  function buildMustache(path, params, hash, raw, loc, strip) {
    if (typeof path === 'string') {
      path = buildPath(path);
    }

    return {
      type: 'MustacheStatement',
      path: path,
      params: params || [],
      hash: hash || buildHash([]),
      escaped: !raw,
      trusting: !!raw,
      loc: buildLoc(loc || null),
      strip: strip || {
        open: false,
        close: false
      }
    };
  }

  function buildBlock(path, params, hash, _defaultBlock, _elseBlock, loc, openStrip, inverseStrip, closeStrip) {
    var defaultBlock;
    var elseBlock;

    if (_defaultBlock.type === 'Template') {

      defaultBlock = util.assign({}, _defaultBlock, {
        type: 'Block'
      });
    } else {
      defaultBlock = _defaultBlock;
    }

    if (_elseBlock !== undefined && _elseBlock !== null && _elseBlock.type === 'Template') {

      elseBlock = util.assign({}, _elseBlock, {
        type: 'Block'
      });
    } else {
      elseBlock = _elseBlock;
    }

    return {
      type: 'BlockStatement',
      path: buildPath(path),
      params: params || [],
      hash: hash || buildHash([]),
      program: defaultBlock || null,
      inverse: elseBlock || null,
      loc: buildLoc(loc || null),
      openStrip: openStrip || {
        open: false,
        close: false
      },
      inverseStrip: inverseStrip || {
        open: false,
        close: false
      },
      closeStrip: closeStrip || {
        open: false,
        close: false
      }
    };
  }

  function buildElementModifier(path, params, hash, loc) {
    return {
      type: 'ElementModifierStatement',
      path: buildPath(path),
      params: params || [],
      hash: hash || buildHash([]),
      loc: buildLoc(loc || null)
    };
  }

  function buildPartial(name, params, hash, indent, loc) {
    return {
      type: 'PartialStatement',
      name: name,
      params: params || [],
      hash: hash || buildHash([]),
      indent: indent || '',
      strip: {
        open: false,
        close: false
      },
      loc: buildLoc(loc || null)
    };
  }

  function buildComment(value, loc) {
    return {
      type: 'CommentStatement',
      value: value,
      loc: buildLoc(loc || null)
    };
  }

  function buildMustacheComment(value, loc) {
    return {
      type: 'MustacheCommentStatement',
      value: value,
      loc: buildLoc(loc || null)
    };
  }

  function buildConcat(parts, loc) {
    if (!util.isPresent(parts)) {
      throw new Error("b.concat requires at least one part");
    }

    return {
      type: 'ConcatStatement',
      parts: parts || [],
      loc: buildLoc(loc || null)
    };
  }

  function buildElement(tag, options) {
    var attrs = options.attrs,
        blockParams = options.blockParams,
        modifiers = options.modifiers,
        comments = options.comments,
        children = options.children,
        loc = options.loc;
    var tagName; // this is used for backwards compat, prior to `selfClosing` being part of the ElementNode AST

    var selfClosing = false;

    if (typeof tag === 'object') {
      selfClosing = tag.selfClosing;
      tagName = tag.name;
    } else if (tag.slice(-1) === '/') {
      tagName = tag.slice(0, -1);
      selfClosing = true;
    } else {
      tagName = tag;
    }

    return {
      type: 'ElementNode',
      tag: tagName,
      selfClosing: selfClosing,
      attributes: attrs || [],
      blockParams: blockParams || [],
      modifiers: modifiers || [],
      comments: comments || [],
      children: children || [],
      loc: buildLoc(loc || null)
    };
  }

  function buildAttr(name, value, loc) {
    return {
      type: 'AttrNode',
      name: name,
      value: value,
      loc: buildLoc(loc || null)
    };
  }

  function buildText(chars, loc) {
    return {
      type: 'TextNode',
      chars: chars || '',
      loc: buildLoc(loc || null)
    };
  } // Expressions


  function buildSexpr(path, params, hash, loc) {
    return {
      type: 'SubExpression',
      path: buildPath(path),
      params: params || [],
      hash: hash || buildHash([]),
      loc: buildLoc(loc || null)
    };
  }

  function headToString(head) {
    switch (head.type) {
      case 'AtHead':
        return {
          original: head.name,
          parts: [head.name]
        };

      case 'ThisHead':
        return {
          original: "this",
          parts: []
        };

      case 'VarHead':
        return {
          original: head.name,
          parts: [head.name]
        };
    }
  }

  function buildHead(original, loc) {
    var _original$split = original.split('.'),
        head = _original$split[0],
        tail = _original$split.slice(1);

    var headNode;

    if (head === 'this') {
      headNode = {
        type: 'ThisHead',
        loc: buildLoc(loc || null)
      };
    } else if (head[0] === '@') {
      headNode = {
        type: 'AtHead',
        name: head,
        loc: buildLoc(loc || null)
      };
    } else {
      headNode = {
        type: 'VarHead',
        name: head,
        loc: buildLoc(loc || null)
      };
    }

    return {
      head: headNode,
      tail: tail
    };
  }

  function buildThis(loc) {
    return {
      type: 'ThisHead',
      loc: buildLoc(loc || null)
    };
  }

  function buildAtName(name, loc) {
    return {
      type: 'AtHead',
      name: name,
      loc: buildLoc(loc || null)
    };
  }

  function buildVar(name, loc) {
    return {
      type: 'VarHead',
      name: name,
      loc: buildLoc(loc || null)
    };
  }

  function buildHeadFromString(head, loc) {
    if (head[0] === '@') {
      return buildAtName(head, loc);
    } else if (head === 'this') {
      return buildThis(loc);
    } else {
      return buildVar(head, loc);
    }
  }

  function buildNamedBlockName(name, loc) {
    return {
      type: 'NamedBlockName',
      name: name,
      loc: buildLoc(loc || null)
    };
  }

  function buildCleanPath(head, tail, loc) {
    var _headToString = headToString(head),
        originalHead = _headToString.original,
        headParts = _headToString.parts;

    var parts = [].concat(headParts, tail);
    var original = [].concat(originalHead, parts).join('.');
    return new PathExpressionImplV1(original, head, tail, buildLoc(loc || null));
  }

  function buildPath(path, loc) {
    if (typeof path !== 'string') {
      if ('type' in path) {
        return path;
      } else {
        var _buildHead = buildHead(path.head, SourceSpan.broken()),
            _head = _buildHead.head,
            _tail = _buildHead.tail;

        var _headToString2 = headToString(_head),
            originalHead = _headToString2.original;

        return new PathExpressionImplV1([originalHead].concat(_tail).join('.'), _head, _tail, buildLoc(loc || null));
      }
    }

    var _buildHead2 = buildHead(path, SourceSpan.broken()),
        head = _buildHead2.head,
        tail = _buildHead2.tail;

    return new PathExpressionImplV1(path, head, tail, buildLoc(loc || null));
  }

  function buildLiteral(type, value, loc) {
    return {
      type: type,
      value: value,
      original: value,
      loc: buildLoc(loc || null)
    };
  } // Miscellaneous


  function buildHash(pairs, loc) {
    return {
      type: 'Hash',
      pairs: pairs || [],
      loc: buildLoc(loc || null)
    };
  }

  function buildPair(key, value, loc) {
    return {
      type: 'HashPair',
      key: key,
      value: value,
      loc: buildLoc(loc || null)
    };
  }

  function buildProgram(body, blockParams, loc) {
    return {
      type: 'Template',
      body: body || [],
      blockParams: blockParams || [],
      loc: buildLoc(loc || null)
    };
  }

  function buildBlockItself(body, blockParams, chained, loc) {
    if (chained === void 0) {
      chained = false;
    }

    return {
      type: 'Block',
      body: body || [],
      blockParams: blockParams || [],
      chained: chained,
      loc: buildLoc(loc || null)
    };
  }

  function buildTemplate(body, blockParams, loc) {
    return {
      type: 'Template',
      body: body || [],
      blockParams: blockParams || [],
      loc: buildLoc(loc || null)
    };
  }

  function buildPosition(line, column) {
    return {
      line: line,
      column: column
    };
  }

  function buildLoc() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1) {
      var loc = args[0];

      if (loc && typeof loc === 'object') {
        return SourceSpan.forHbsLoc(SOURCE(), loc);
      } else {
        return SourceSpan.forHbsLoc(SOURCE(), SYNTHETIC_LOCATION);
      }
    } else {
      var startLine = args[0],
          startColumn = args[1],
          endLine = args[2],
          endColumn = args[3],
          _source = args[4];
      var source = _source ? new Source('', _source) : SOURCE();
      return SourceSpan.forHbsLoc(source, {
        start: {
          line: startLine,
          column: startColumn
        },
        end: {
          line: endLine,
          column: endColumn
        }
      });
    }
  }

  var publicBuilder = {
    mustache: buildMustache,
    block: buildBlock,
    partial: buildPartial,
    comment: buildComment,
    mustacheComment: buildMustacheComment,
    element: buildElement,
    elementModifier: buildElementModifier,
    attr: buildAttr,
    text: buildText,
    sexpr: buildSexpr,
    concat: buildConcat,
    hash: buildHash,
    pair: buildPair,
    literal: buildLiteral,
    program: buildProgram,
    blockItself: buildBlockItself,
    template: buildTemplate,
    loc: buildLoc,
    pos: buildPosition,
    path: buildPath,
    fullPath: buildCleanPath,
    head: buildHeadFromString,
    at: buildAtName,
    "var": buildVar,
    "this": buildThis,
    blockName: buildNamedBlockName,
    string: literal('StringLiteral'),
    "boolean": literal('BooleanLiteral'),
    number: literal('NumberLiteral'),
    undefined: function (_undefined) {
      function undefined$1() {
        return _undefined.apply(this, arguments);
      }

      undefined$1.toString = function () {
        return _undefined.toString();
      };

      return undefined$1;
    }(function () {
      return buildLiteral('UndefinedLiteral', undefined);
    }),
    "null": function _null() {
      return buildLiteral('NullLiteral', null);
    }
  };

  function literal(type) {
    return function (value, loc) {
      return buildLiteral(type, value, loc);
    };
  }



  var api = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

  /**
   * A free variable is resolved according to a resolution rule:
   *
   * 1. Strict resolution
   * 2. Namespaced resolution
   * 3. Fallback resolution
   */

  /**
   * Strict resolution is used:
   *
   * 1. in a strict mode template
   * 2. in an unambiguous invocation with dot paths
   */
  var StrictResolution = /*#__PURE__*/function () {
    function StrictResolution() {
      this.isAngleBracket = false;
    }

    var _proto = StrictResolution.prototype;

    _proto.resolution = function resolution() {
      return 31
      /* GetStrictFree */
      ;
    };

    _proto.serialize = function serialize() {
      return 'Strict';
    };

    return StrictResolution;
  }();
  var STRICT_RESOLUTION = new StrictResolution();
  /**
   * A `LooseModeResolution` includes:
   *
   * - 0 or more namespaces to resolve the variable in
   * - optional fallback behavior
   *
   * In practice, there are a limited number of possible combinations of these degrees of freedom,
   * and they are captured by the `Ambiguity` union below.
   */

  var LooseModeResolution = /*#__PURE__*/function () {
    function LooseModeResolution(ambiguity, isAngleBracket) {
      if (isAngleBracket === void 0) {
        isAngleBracket = false;
      }

      this.ambiguity = ambiguity;
      this.isAngleBracket = isAngleBracket;
    }
    /**
     * Namespaced resolution is used in an unambiguous syntax position:
     *
     * 1. `(sexp)` (namespace: `Helper`)
     * 2. `{{#block}}` (namespace: `Component`)
     * 3. `<a {{modifier}}>` (namespace: `Modifier`)
     * 4. `<Component />` (namespace: `Component`)
     *
     * @see {NamespacedAmbiguity}
     */


    LooseModeResolution.namespaced = function namespaced(namespace, isAngleBracket) {
      if (isAngleBracket === void 0) {
        isAngleBracket = false;
      }

      return new LooseModeResolution({
        namespaces: [namespace],
        fallback: false
      }, isAngleBracket);
    }
    /**
     * Fallback resolution is used when no namespaced resolutions are possible, but fallback
     * resolution is still allowed.
     *
     * ```hbs
     * {{x.y}}
     * ```
     *
     * @see {FallbackAmbiguity}
     */
    ;

    LooseModeResolution.fallback = function fallback() {
      return new LooseModeResolution({
        namespaces: [],
        fallback: true
      });
    }
    /**
     * Append resolution is used when the variable should be resolved in both the `component` and
     * `helper` namespaces. Fallback resolution is optional.
     *
     * ```hbs
     * {{x}}
     * ```
     *
     * ^ `x` should be resolved in the `component` and `helper` namespaces with fallback resolution.
     *
     * ```hbs
     * {{x y}}
     * ```
     *
     * ^ `x` should be resolved in the `component` and `helper` namespaces without fallback
     * resolution.
     *
     * @see {ComponentOrHelperAmbiguity}
     */
    ;

    LooseModeResolution.append = function append(_ref) {
      var invoke = _ref.invoke;
      return new LooseModeResolution({
        namespaces: ["Component"
        /* Component */
        , "Helper"
        /* Helper */
        ],
        fallback: !invoke
      });
    }
    /**
     * Trusting append resolution is used when the variable should be resolved in both the `component` and
     * `helper` namespaces. Fallback resolution is optional.
     *
     * ```hbs
     * {{{x}}}
     * ```
     *
     * ^ `x` should be resolved in the `component` and `helper` namespaces with fallback resolution.
     *
     * ```hbs
     * {{{x y}}}
     * ```
     *
     * ^ `x` should be resolved in the `component` and `helper` namespaces without fallback
     * resolution.
     *
     * @see {HelperAmbiguity}
     */
    ;

    LooseModeResolution.trustingAppend = function trustingAppend(_ref2) {
      var invoke = _ref2.invoke;
      return new LooseModeResolution({
        namespaces: ["Helper"
        /* Helper */
        ],
        fallback: !invoke
      });
    }
    /**
     * Attribute resolution is used when the variable should be resolved as a `helper` with fallback
     * resolution.
     *
     * ```hbs
     * <a href={{x}} />
     * <a href="{{x}}.html" />
     * ```
     *
     * ^ resolved in the `helper` namespace with fallback
     *
     * @see {HelperAmbiguity}
     */
    ;

    LooseModeResolution.attr = function attr() {
      return new LooseModeResolution({
        namespaces: ["Helper"
        /* Helper */
        ],
        fallback: true
      });
    };

    var _proto2 = LooseModeResolution.prototype;

    _proto2.resolution = function resolution() {
      if (this.ambiguity.namespaces.length === 0) {
        return 33
        /* GetFreeAsFallback */
        ;
      } else if (this.ambiguity.namespaces.length === 1) {
        if (this.ambiguity.fallback) {
          // simple namespaced resolution with fallback must be attr={{x}}
          return 36
          /* GetFreeAsHelperHeadOrThisFallback */
          ;
        } else {
          // simple namespaced resolution without fallback
          switch (this.ambiguity.namespaces[0]) {
            case "Helper"
            /* Helper */
            :
              return 37
              /* GetFreeAsHelperHead */
              ;

            case "Modifier"
            /* Modifier */
            :
              return 38
              /* GetFreeAsModifierHead */
              ;

            case "Component"
            /* Component */
            :
              return 39
              /* GetFreeAsComponentHead */
              ;
          }
        }
      } else if (this.ambiguity.fallback) {
        // component or helper + fallback ({{something}})
        return 34
        /* GetFreeAsComponentOrHelperHeadOrThisFallback */
        ;
      } else {
          // component or helper without fallback ({{something something}})
          return 35
          /* GetFreeAsComponentOrHelperHead */
          ;
        }
    };

    _proto2.serialize = function serialize() {
      if (this.ambiguity.namespaces.length === 0) {
        return 'Loose';
      } else if (this.ambiguity.namespaces.length === 1) {
        if (this.ambiguity.fallback) {
          // simple namespaced resolution with fallback must be attr={{x}}
          return ['ambiguous', "Attr"
          /* Attr */
          ];
        } else {
          return ['ns', this.ambiguity.namespaces[0]];
        }
      } else if (this.ambiguity.fallback) {
        // component or helper + fallback ({{something}})
        return ['ambiguous', "Append"
        /* Append */
        ];
      } else {
        // component or helper without fallback ({{something something}})
        return ['ambiguous', "Invoke"
        /* Invoke */
        ];
      }
    };

    return LooseModeResolution;
  }();
  var ARGUMENT_RESOLUTION = LooseModeResolution.fallback();
  function loadResolution(resolution) {
    if (typeof resolution === 'string') {
      switch (resolution) {
        case 'Loose':
          return LooseModeResolution.fallback();

        case 'Strict':
          return STRICT_RESOLUTION;
      }
    }

    switch (resolution[0]) {
      case 'ambiguous':
        switch (resolution[1]) {
          case "Append"
          /* Append */
          :
            return LooseModeResolution.append({
              invoke: false
            });

          case "Attr"
          /* Attr */
          :
            return LooseModeResolution.attr();

          case "Invoke"
          /* Invoke */
          :
            return LooseModeResolution.append({
              invoke: true
            });
        }

      case 'ns':
        return LooseModeResolution.namespaced(resolution[1]);
    }
  }

  function _createForOfIteratorHelperLoose$1(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

  function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

  function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function node(name) {
    if (name !== undefined) {
      var type = name;
      return {
        fields: function fields() {
          return /*#__PURE__*/function () {
            function _class(fields) {
              this.type = type;
              this.loc = fields.loc;
              copy(fields, this);
            }

            return _class;
          }();
        }
      };
    } else {
      return {
        fields: function fields() {
          return /*#__PURE__*/function () {
            function _class2(fields) {
              this.loc = fields.loc;
              copy(fields, this);
            }

            return _class2;
          }();
        }
      };
    }
  }

  function keys(object) {
    return Object.keys(object);
  }

  function copy(object1, object2) {
    for (var _iterator = _createForOfIteratorHelperLoose$1(keys(object1)), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      object2[key] = object1[key];
    }
  }

  function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); return Constructor; }

  function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Corresponds to syntaxes with positional and named arguments:
   *
   * - SubExpression
   * - Invoking Append
   * - Invoking attributes
   * - InvokeBlock
   *
   * If `Args` is empty, the `SourceOffsets` for this node should be the collapsed position
   * immediately after the parent call node's `callee`.
   */

  var Args = /*#__PURE__*/function (_node$fields) {
    _inheritsLoose(Args, _node$fields);

    function Args() {
      return _node$fields.apply(this, arguments) || this;
    }

    Args.empty = function empty(loc) {
      return new Args({
        loc: loc,
        positional: PositionalArguments.empty(loc),
        named: NamedArguments.empty(loc)
      });
    };

    Args.named = function named(_named) {
      return new Args({
        loc: _named.loc,
        positional: PositionalArguments.empty(_named.loc.collapse('end')),
        named: _named
      });
    };

    var _proto = Args.prototype;

    _proto.nth = function nth(offset) {
      return this.positional.nth(offset);
    };

    _proto.get = function get(name) {
      return this.named.get(name);
    };

    _proto.isEmpty = function isEmpty() {
      return this.positional.isEmpty() && this.named.isEmpty();
    };

    return Args;
  }(node().fields());
  /**
   * Corresponds to positional arguments.
   *
   * If `PositionalArguments` is empty, the `SourceOffsets` for this node should be the collapsed
   * position immediately after the parent call node's `callee`.
   */

  var PositionalArguments = /*#__PURE__*/function (_node$fields2) {
    _inheritsLoose(PositionalArguments, _node$fields2);

    function PositionalArguments() {
      return _node$fields2.apply(this, arguments) || this;
    }

    PositionalArguments.empty = function empty(loc) {
      return new PositionalArguments({
        loc: loc,
        exprs: []
      });
    };

    var _proto2 = PositionalArguments.prototype;

    _proto2.nth = function nth(offset) {
      return this.exprs[offset] || null;
    };

    _proto2.isEmpty = function isEmpty() {
      return this.exprs.length === 0;
    };

    _createClass$3(PositionalArguments, [{
      key: "size",
      get: function get() {
        return this.exprs.length;
      }
    }]);

    return PositionalArguments;
  }(node().fields());
  /**
   * Corresponds to named arguments.
   *
   * If `PositionalArguments` and `NamedArguments` are empty, the `SourceOffsets` for this node should
   * be the same as the `Args` node that contains this node.
   *
   * If `PositionalArguments` is not empty but `NamedArguments` is empty, the `SourceOffsets` for this
   * node should be the collapsed position immediately after the last positional argument.
   */

  var NamedArguments = /*#__PURE__*/function (_node$fields3) {
    _inheritsLoose(NamedArguments, _node$fields3);

    function NamedArguments() {
      return _node$fields3.apply(this, arguments) || this;
    }

    NamedArguments.empty = function empty(loc) {
      return new NamedArguments({
        loc: loc,
        entries: []
      });
    };

    var _proto3 = NamedArguments.prototype;

    _proto3.get = function get(name) {
      var entry = this.entries.filter(function (e) {
        return e.name.chars === name;
      })[0];
      return entry ? entry.value : null;
    };

    _proto3.isEmpty = function isEmpty() {
      return this.entries.length === 0;
    };

    _createClass$3(NamedArguments, [{
      key: "size",
      get: function get() {
        return this.entries.length;
      }
    }]);

    return NamedArguments;
  }(node().fields());
  /**
   * Corresponds to a single named argument.
   *
   * ```hbs
   * x=<expr>
   * ```
   */

  var NamedArgument = function NamedArgument(options) {
    this.loc = options.name.loc.extend(options.value.loc);
    this.name = options.name;
    this.value = options.value;
  };

  function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * `HtmlAttr` nodes are valid HTML attributes, with or without a value.
   *
   * Exceptions:
   *
   * - `...attributes` is `SplatAttr`
   * - `@x=<value>` is `ComponentArg`
   */

  var HtmlAttr = /*#__PURE__*/function (_node$fields) {
    _inheritsLoose$1(HtmlAttr, _node$fields);

    function HtmlAttr() {
      return _node$fields.apply(this, arguments) || this;
    }

    return HtmlAttr;
  }(node('HtmlAttr').fields());
  var SplatAttr = /*#__PURE__*/function (_node$fields2) {
    _inheritsLoose$1(SplatAttr, _node$fields2);

    function SplatAttr() {
      return _node$fields2.apply(this, arguments) || this;
    }

    return SplatAttr;
  }(node('SplatAttr').fields());
  /**
   * Corresponds to an argument passed by a component (`@x=<value>`)
   */

  var ComponentArg = /*#__PURE__*/function (_node$fields3) {
    _inheritsLoose$1(ComponentArg, _node$fields3);

    function ComponentArg() {
      return _node$fields3.apply(this, arguments) || this;
    }

    var _proto = ComponentArg.prototype;

    /**
     * Convert the component argument into a named argument node
     */
    _proto.toNamedArgument = function toNamedArgument() {
      return new NamedArgument({
        name: this.name,
        value: this.value
      });
    };

    return ComponentArg;
  }(node().fields());
  /**
   * An `ElementModifier` is just a normal call node in modifier position.
   */

  var ElementModifier = /*#__PURE__*/function (_node$fields4) {
    _inheritsLoose$1(ElementModifier, _node$fields4);

    function ElementModifier() {
      return _node$fields4.apply(this, arguments) || this;
    }

    return ElementModifier;
  }(node('ElementModifier').fields());

  var __classPrivateFieldSet$3 = undefined && undefined.__classPrivateFieldSet || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }

    privateMap.set(receiver, value);
    return value;
  };

  var __classPrivateFieldGet$3 = undefined && undefined.__classPrivateFieldGet || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }

    return privateMap.get(receiver);
  };

  var _span;
  var SpanList = /*#__PURE__*/function () {
    function SpanList(span) {
      if (span === void 0) {
        span = [];
      }

      _span.set(this, void 0);

      __classPrivateFieldSet$3(this, _span, span);
    }

    SpanList.range = function range(span, fallback) {
      if (fallback === void 0) {
        fallback = SourceSpan.NON_EXISTENT;
      }

      return new SpanList(span.map(loc)).getRangeOffset(fallback);
    };

    var _proto = SpanList.prototype;

    _proto.add = function add(offset) {
      __classPrivateFieldGet$3(this, _span).push(offset);
    };

    _proto.getRangeOffset = function getRangeOffset(fallback) {
      if (__classPrivateFieldGet$3(this, _span).length === 0) {
        return fallback;
      } else {
        var first = __classPrivateFieldGet$3(this, _span)[0];

        var last = __classPrivateFieldGet$3(this, _span)[__classPrivateFieldGet$3(this, _span).length - 1];

        return first.extend(last);
      }
    };

    return SpanList;
  }();
  _span = new WeakMap();
  function loc(span) {
    if (Array.isArray(span)) {
      var first = span[0];
      var last = span[span.length - 1];
      return loc(first).extend(loc(last));
    } else if (span instanceof SourceSpan) {
      return span;
    } else {
      return span.loc;
    }
  }
  function hasSpan(span) {
    if (Array.isArray(span) && span.length === 0) {
      return false;
    }

    return true;
  }
  function maybeLoc(location, fallback) {
    if (hasSpan(location)) {
      return loc(location);
    } else {
      return fallback;
    }
  }

  function _defineProperties$4(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$4(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$4(Constructor.prototype, protoProps); if (staticProps) _defineProperties$4(Constructor, staticProps); return Constructor; }

  function _inheritsLoose$2(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  var GlimmerComment = /*#__PURE__*/function (_node$fields) {
    _inheritsLoose$2(GlimmerComment, _node$fields);

    function GlimmerComment() {
      return _node$fields.apply(this, arguments) || this;
    }

    return GlimmerComment;
  }(node('GlimmerComment').fields());
  var HtmlText = /*#__PURE__*/function (_node$fields2) {
    _inheritsLoose$2(HtmlText, _node$fields2);

    function HtmlText() {
      return _node$fields2.apply(this, arguments) || this;
    }

    return HtmlText;
  }(node('HtmlText').fields());
  var HtmlComment = /*#__PURE__*/function (_node$fields3) {
    _inheritsLoose$2(HtmlComment, _node$fields3);

    function HtmlComment() {
      return _node$fields3.apply(this, arguments) || this;
    }

    return HtmlComment;
  }(node('HtmlComment').fields());
  var AppendContent = /*#__PURE__*/function (_node$fields4) {
    _inheritsLoose$2(AppendContent, _node$fields4);

    function AppendContent() {
      return _node$fields4.apply(this, arguments) || this;
    }

    _createClass$4(AppendContent, [{
      key: "callee",
      get: function get() {
        if (this.value.type === 'Call') {
          return this.value.callee;
        } else {
          return this.value;
        }
      }
    }, {
      key: "args",
      get: function get() {
        if (this.value.type === 'Call') {
          return this.value.args;
        } else {
          return Args.empty(this.value.loc.collapse('end'));
        }
      }
    }]);

    return AppendContent;
  }(node('AppendContent').fields());
  var InvokeBlock = /*#__PURE__*/function (_node$fields5) {
    _inheritsLoose$2(InvokeBlock, _node$fields5);

    function InvokeBlock() {
      return _node$fields5.apply(this, arguments) || this;
    }

    return InvokeBlock;
  }(node('InvokeBlock').fields());
  /**
   * Corresponds to a component invocation. When the content of a component invocation contains no
   * named blocks, `blocks` contains a single named block named `"default"`. When a component
   * invocation is self-closing, `blocks` is empty.
   */

  var InvokeComponent = /*#__PURE__*/function (_node$fields6) {
    _inheritsLoose$2(InvokeComponent, _node$fields6);

    function InvokeComponent() {
      return _node$fields6.apply(this, arguments) || this;
    }

    _createClass$4(InvokeComponent, [{
      key: "args",
      get: function get() {
        var entries = this.componentArgs.map(function (a) {
          return a.toNamedArgument();
        });
        return Args.named(new NamedArguments({
          loc: SpanList.range(entries, this.callee.loc.collapse('end')),
          entries: entries
        }));
      }
    }]);

    return InvokeComponent;
  }(node('InvokeComponent').fields());
  /**
   * Corresponds to a simple HTML element. The AST allows component arguments and modifiers to support
   * future extensions.
   */

  var SimpleElement = /*#__PURE__*/function (_node$fields7) {
    _inheritsLoose$2(SimpleElement, _node$fields7);

    function SimpleElement() {
      return _node$fields7.apply(this, arguments) || this;
    }

    _createClass$4(SimpleElement, [{
      key: "args",
      get: function get() {
        var entries = this.componentArgs.map(function (a) {
          return a.toNamedArgument();
        });
        return Args.named(new NamedArguments({
          loc: SpanList.range(entries, this.tag.loc.collapse('end')),
          entries: entries
        }));
      }
    }]);

    return SimpleElement;
  }(node('SimpleElement').fields());

  function _inheritsLoose$3(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Corresponds to a Handlebars literal.
   *
   * @see {LiteralValue}
   */

  var LiteralExpression = /*#__PURE__*/function (_node$fields) {
    _inheritsLoose$3(LiteralExpression, _node$fields);

    function LiteralExpression() {
      return _node$fields.apply(this, arguments) || this;
    }

    var _proto = LiteralExpression.prototype;

    _proto.toSlice = function toSlice() {
      return new SourceSlice({
        loc: this.loc,
        chars: this.value
      });
    };

    return LiteralExpression;
  }(node('Literal').fields());
  /**
   * Returns true if an input {@see ExpressionNode} is a literal.
   */

  function isLiteral(node, kind) {
    if (node.type === 'Literal') {
      if (kind === undefined) {
        return true;
      } else if (kind === 'null') {
        return node.value === null;
      } else {
        return typeof node.value === kind;
      }
    } else {
      return false;
    }
  }
  /**
   * Corresponds to a path in expression position.
   *
   * ```hbs
   * this
   * this.x
   * @x
   * @x.y
   * x
   * x.y
   * ```
   */

  var PathExpression = /*#__PURE__*/function (_node$fields2) {
    _inheritsLoose$3(PathExpression, _node$fields2);

    function PathExpression() {
      return _node$fields2.apply(this, arguments) || this;
    }

    return PathExpression;
  }(node('Path').fields());
  /**
   * Corresponds to a parenthesized call expression.
   *
   * ```hbs
   * (x)
   * (x.y)
   * (x y)
   * (x.y z)
   * ```
   */

  var CallExpression = /*#__PURE__*/function (_node$fields3) {
    _inheritsLoose$3(CallExpression, _node$fields3);

    function CallExpression() {
      return _node$fields3.apply(this, arguments) || this;
    }

    return CallExpression;
  }(node('Call').fields());
  /**
   * Corresponds to a possible deprecated helper call. Must be:
   *
   * 1. A free variable (not this.foo, not @foo, not local).
   * 2. Argument-less.
   * 3. In a component invocation's named argument position.
   * 4. Not parenthesized (not @bar={{(helper)}}).
   * 5. Not interpolated (not @bar="{{helper}}").
   *
   * ```hbs
   * <Foo @bar={{helper}} />
   * ```
   */

  var DeprecatedCallExpression = /*#__PURE__*/function (_node$fields4) {
    _inheritsLoose$3(DeprecatedCallExpression, _node$fields4);

    function DeprecatedCallExpression() {
      return _node$fields4.apply(this, arguments) || this;
    }

    return DeprecatedCallExpression;
  }(node('DeprecatedCall').fields());
  /**
   * Corresponds to an interpolation in attribute value position.
   *
   * ```hbs
   * <a href="{{url}}.html"
   * ```
   */

  var InterpolateExpression = /*#__PURE__*/function (_node$fields5) {
    _inheritsLoose$3(InterpolateExpression, _node$fields5);

    function InterpolateExpression() {
      return _node$fields5.apply(this, arguments) || this;
    }

    return InterpolateExpression;
  }(node('Interpolate').fields());

  function _inheritsLoose$4(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Corresponds to `this` at the head of an expression.
   */

  var ThisReference = /*#__PURE__*/function (_node$fields) {
    _inheritsLoose$4(ThisReference, _node$fields);

    function ThisReference() {
      return _node$fields.apply(this, arguments) || this;
    }

    return ThisReference;
  }(node('This').fields());
  /**
   * Corresponds to `@<ident>` at the beginning of an expression.
   */

  var ArgReference = /*#__PURE__*/function (_node$fields2) {
    _inheritsLoose$4(ArgReference, _node$fields2);

    function ArgReference() {
      return _node$fields2.apply(this, arguments) || this;
    }

    return ArgReference;
  }(node('Arg').fields());
  /**
   * Corresponds to `<ident>` at the beginning of an expression, when `<ident>` is in the current
   * block's scope.
   */

  var LocalVarReference = /*#__PURE__*/function (_node$fields3) {
    _inheritsLoose$4(LocalVarReference, _node$fields3);

    function LocalVarReference() {
      return _node$fields3.apply(this, arguments) || this;
    }

    return LocalVarReference;
  }(node('Local').fields());
  /**
   * Corresponds to `<ident>` at the beginning of an expression, when `<ident>` is *not* in the
   * current block's scope.
   *
   * The `resolution: FreeVarResolution` field describes how to resolve the free variable.
   *
   * Note: In strict mode, it must always be a variable that is in a concrete JavaScript scope that
   * the template will be installed into.
   */

  var FreeVarReference = /*#__PURE__*/function (_node$fields4) {
    _inheritsLoose$4(FreeVarReference, _node$fields4);

    function FreeVarReference() {
      return _node$fields4.apply(this, arguments) || this;
    }

    return FreeVarReference;
  }(node('Free').fields());

  function _defineProperties$5(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$5(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$5(Constructor.prototype, protoProps); if (staticProps) _defineProperties$5(Constructor, staticProps); return Constructor; }

  function _inheritsLoose$5(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Corresponds to an entire template.
   */

  var Template = /*#__PURE__*/function (_node$fields) {
    _inheritsLoose$5(Template, _node$fields);

    function Template() {
      return _node$fields.apply(this, arguments) || this;
    }

    return Template;
  }(node().fields());
  /**
   * Represents a block. In principle this could be merged with `NamedBlock`, because all cases
   * involving blocks have at least a notional name.
   */

  var Block = /*#__PURE__*/function (_node$fields2) {
    _inheritsLoose$5(Block, _node$fields2);

    function Block() {
      return _node$fields2.apply(this, arguments) || this;
    }

    return Block;
  }(node().fields());
  /**
   * Corresponds to a collection of named blocks.
   */

  var NamedBlocks = /*#__PURE__*/function (_node$fields3) {
    _inheritsLoose$5(NamedBlocks, _node$fields3);

    function NamedBlocks() {
      return _node$fields3.apply(this, arguments) || this;
    }

    var _proto = NamedBlocks.prototype;

    _proto.get = function get(name) {
      return this.blocks.filter(function (block) {
        return block.name.chars === name;
      })[0] || null;
    };

    return NamedBlocks;
  }(node().fields());
  /**
   * Corresponds to a single named block. This is used for anonymous named blocks (`default` and
   * `else`).
   */

  var NamedBlock = /*#__PURE__*/function (_node$fields4) {
    _inheritsLoose$5(NamedBlock, _node$fields4);

    function NamedBlock() {
      return _node$fields4.apply(this, arguments) || this;
    }

    _createClass$5(NamedBlock, [{
      key: "args",
      get: function get() {
        var entries = this.componentArgs.map(function (a) {
          return a.toNamedArgument();
        });
        return Args.named(new NamedArguments({
          loc: SpanList.range(entries, this.name.loc.collapse('end')),
          entries: entries
        }));
      }
    }]);

    return NamedBlock;
  }(node().fields());



  var api$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    StrictResolution: StrictResolution,
    STRICT_RESOLUTION: STRICT_RESOLUTION,
    LooseModeResolution: LooseModeResolution,
    ARGUMENT_RESOLUTION: ARGUMENT_RESOLUTION,
    loadResolution: loadResolution,
    node: node,
    Args: Args,
    PositionalArguments: PositionalArguments,
    NamedArguments: NamedArguments,
    NamedArgument: NamedArgument,
    HtmlAttr: HtmlAttr,
    SplatAttr: SplatAttr,
    ComponentArg: ComponentArg,
    ElementModifier: ElementModifier,
    GlimmerComment: GlimmerComment,
    HtmlText: HtmlText,
    HtmlComment: HtmlComment,
    AppendContent: AppendContent,
    InvokeBlock: InvokeBlock,
    InvokeComponent: InvokeComponent,
    SimpleElement: SimpleElement,
    LiteralExpression: LiteralExpression,
    isLiteral: isLiteral,
    PathExpression: PathExpression,
    CallExpression: CallExpression,
    DeprecatedCallExpression: DeprecatedCallExpression,
    InterpolateExpression: InterpolateExpression,
    ThisReference: ThisReference,
    ArgReference: ArgReference,
    LocalVarReference: LocalVarReference,
    FreeVarReference: FreeVarReference,
    Template: Template,
    Block: Block,
    NamedBlocks: NamedBlocks,
    NamedBlock: NamedBlock
  });

  var ATTR_VALUE_REGEX_TEST = /[\xA0"&]/;
  var ATTR_VALUE_REGEX_REPLACE = new RegExp(ATTR_VALUE_REGEX_TEST.source, 'g');
  var TEXT_REGEX_TEST = /[\xA0&<>]/;
  var TEXT_REGEX_REPLACE = new RegExp(TEXT_REGEX_TEST.source, 'g');

  function attrValueReplacer(_char) {
    switch (_char.charCodeAt(0)) {
      case 160
      /* NBSP */
      :
        return '&nbsp;';

      case 34
      /* QUOT */
      :
        return '&quot;';

      case 38
      /* AMP */
      :
        return '&amp;';

      default:
        return _char;
    }
  }

  function textReplacer(_char2) {
    switch (_char2.charCodeAt(0)) {
      case 160
      /* NBSP */
      :
        return '&nbsp;';

      case 38
      /* AMP */
      :
        return '&amp;';

      case 60
      /* LT */
      :
        return '&lt;';

      case 62
      /* GT */
      :
        return '&gt;';

      default:
        return _char2;
    }
  }

  function escapeAttrValue(attrValue) {
    if (ATTR_VALUE_REGEX_TEST.test(attrValue)) {
      return attrValue.replace(ATTR_VALUE_REGEX_REPLACE, attrValueReplacer);
    }

    return attrValue;
  }
  function escapeText(text) {
    if (TEXT_REGEX_TEST.test(text)) {
      return text.replace(TEXT_REGEX_REPLACE, textReplacer);
    }

    return text;
  }
  function sortByLoc(a, b) {
    // If either is invisible, don't try to order them
    if (a.loc.isInvisible || b.loc.isInvisible) {
      return 0;
    }

    if (a.loc.startPosition.line < b.loc.startPosition.line) {
      return -1;
    }

    if (a.loc.startPosition.line === b.loc.startPosition.line && a.loc.startPosition.column < b.loc.startPosition.column) {
      return -1;
    }

    if (a.loc.startPosition.line === b.loc.startPosition.line && a.loc.startPosition.column === b.loc.startPosition.column) {
      return 0;
    }

    return 1;
  }

  function _createForOfIteratorHelperLoose$2(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

  function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

  function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  var voidMap = Object.create(null);
  var voidTagNames = 'area base br col command embed hr img input keygen link meta param source track wbr';
  voidTagNames.split(' ').forEach(function (tagName) {
    voidMap[tagName] = true;
  });
  var NON_WHITESPACE = /\S/;

  var Printer = /*#__PURE__*/function () {
    function Printer(options) {
      this.buffer = '';
      this.options = options;
    }
    /*
      This is used by _all_ methods on this Printer class that add to `this.buffer`,
      it allows consumers of the printer to use alternate string representations for
      a given node.
         The primary use case for this are things like source -> source codemod utilities.
      For example, ember-template-recast attempts to always preserve the original string
      formatting in each AST node if no modifications are made to it.
    */


    var _proto = Printer.prototype;

    _proto.handledByOverride = function handledByOverride(node, ensureLeadingWhitespace) {
      if (ensureLeadingWhitespace === void 0) {
        ensureLeadingWhitespace = false;
      }

      if (this.options.override !== undefined) {
        var result = this.options.override(node, this.options);

        if (typeof result === 'string') {
          if (ensureLeadingWhitespace && result !== '' && NON_WHITESPACE.test(result[0])) {
            result = " " + result;
          }

          this.buffer += result;
          return true;
        }
      }

      return false;
    };

    _proto.Node = function Node(node) {
      switch (node.type) {
        case 'MustacheStatement':
        case 'BlockStatement':
        case 'PartialStatement':
        case 'MustacheCommentStatement':
        case 'CommentStatement':
        case 'TextNode':
        case 'ElementNode':
        case 'AttrNode':
        case 'Block':
        case 'Template':
          return this.TopLevelStatement(node);

        case 'StringLiteral':
        case 'BooleanLiteral':
        case 'NumberLiteral':
        case 'UndefinedLiteral':
        case 'NullLiteral':
        case 'PathExpression':
        case 'SubExpression':
          return this.Expression(node);

        case 'Program':
          return this.Block(node);

        case 'ConcatStatement':
          // should have an AttrNode parent
          return this.ConcatStatement(node);

        case 'Hash':
          return this.Hash(node);

        case 'HashPair':
          return this.HashPair(node);

        case 'ElementModifierStatement':
          return this.ElementModifierStatement(node);
      }
    };

    _proto.Expression = function Expression(expression) {
      switch (expression.type) {
        case 'StringLiteral':
        case 'BooleanLiteral':
        case 'NumberLiteral':
        case 'UndefinedLiteral':
        case 'NullLiteral':
          return this.Literal(expression);

        case 'PathExpression':
          return this.PathExpression(expression);

        case 'SubExpression':
          return this.SubExpression(expression);
      }
    };

    _proto.Literal = function Literal(literal) {
      switch (literal.type) {
        case 'StringLiteral':
          return this.StringLiteral(literal);

        case 'BooleanLiteral':
          return this.BooleanLiteral(literal);

        case 'NumberLiteral':
          return this.NumberLiteral(literal);

        case 'UndefinedLiteral':
          return this.UndefinedLiteral(literal);

        case 'NullLiteral':
          return this.NullLiteral(literal);
      }
    };

    _proto.TopLevelStatement = function TopLevelStatement(statement) {
      switch (statement.type) {
        case 'MustacheStatement':
          return this.MustacheStatement(statement);

        case 'BlockStatement':
          return this.BlockStatement(statement);

        case 'PartialStatement':
          return this.PartialStatement(statement);

        case 'MustacheCommentStatement':
          return this.MustacheCommentStatement(statement);

        case 'CommentStatement':
          return this.CommentStatement(statement);

        case 'TextNode':
          return this.TextNode(statement);

        case 'ElementNode':
          return this.ElementNode(statement);

        case 'Block':
        case 'Template':
          return this.Block(statement);

        case 'AttrNode':
          // should have element
          return this.AttrNode(statement);
      }
    };

    _proto.Block = function Block(block) {
      /*
        When processing a template like:
             ```hbs
        {{#if whatever}}
          whatever
        {{else if somethingElse}}
          something else
        {{else}}
          fallback
        {{/if}}
        ```
             The AST still _effectively_ looks like:
             ```hbs
        {{#if whatever}}
          whatever
        {{else}}{{#if somethingElse}}
          something else
        {{else}}
          fallback
        {{/if}}{{/if}}
        ```
             The only way we can tell if that is the case is by checking for
        `block.chained`, but unfortunately when the actual statements are
        processed the `block.body[0]` node (which will always be a
        `BlockStatement`) has no clue that its ancestor `Block` node was
        chained.
             This "forwards" the `chained` setting so that we can check
        it later when processing the `BlockStatement`.
      */
      if (block.chained) {
        var firstChild = block.body[0];
        firstChild.chained = true;
      }

      if (this.handledByOverride(block)) {
        return;
      }

      this.TopLevelStatements(block.body);
    };

    _proto.TopLevelStatements = function TopLevelStatements(statements) {
      var _this = this;

      statements.forEach(function (statement) {
        return _this.TopLevelStatement(statement);
      });
    };

    _proto.ElementNode = function ElementNode(el) {
      if (this.handledByOverride(el)) {
        return;
      }

      this.OpenElementNode(el);
      this.TopLevelStatements(el.children);
      this.CloseElementNode(el);
    };

    _proto.OpenElementNode = function OpenElementNode(el) {
      this.buffer += "<" + el.tag;
      var parts = [].concat(el.attributes, el.modifiers, el.comments).sort(sortByLoc);

      for (var _iterator = _createForOfIteratorHelperLoose$2(parts), _step; !(_step = _iterator()).done;) {
        var part = _step.value;
        this.buffer += ' ';

        switch (part.type) {
          case 'AttrNode':
            this.AttrNode(part);
            break;

          case 'ElementModifierStatement':
            this.ElementModifierStatement(part);
            break;

          case 'MustacheCommentStatement':
            this.MustacheCommentStatement(part);
            break;
        }
      }

      if (el.blockParams.length) {
        this.BlockParams(el.blockParams);
      }

      if (el.selfClosing) {
        this.buffer += ' /';
      }

      this.buffer += '>';
    };

    _proto.CloseElementNode = function CloseElementNode(el) {
      if (el.selfClosing || voidMap[el.tag.toLowerCase()]) {
        return;
      }

      this.buffer += "</" + el.tag + ">";
    };

    _proto.AttrNode = function AttrNode(attr) {
      if (this.handledByOverride(attr)) {
        return;
      }

      var name = attr.name,
          value = attr.value;
      this.buffer += name;

      if (value.type !== 'TextNode' || value.chars.length > 0) {
        this.buffer += '=';
        this.AttrNodeValue(value);
      }
    };

    _proto.AttrNodeValue = function AttrNodeValue(value) {
      if (value.type === 'TextNode') {
        this.buffer += '"';
        this.TextNode(value, true);
        this.buffer += '"';
      } else {
        this.Node(value);
      }
    };

    _proto.TextNode = function TextNode(text, isAttr) {
      if (this.handledByOverride(text)) {
        return;
      }

      if (this.options.entityEncoding === 'raw') {
        this.buffer += text.chars;
      } else if (isAttr) {
        this.buffer += escapeAttrValue(text.chars);
      } else {
        this.buffer += escapeText(text.chars);
      }
    };

    _proto.MustacheStatement = function MustacheStatement(mustache) {
      if (this.handledByOverride(mustache)) {
        return;
      }

      this.buffer += mustache.escaped ? '{{' : '{{{';

      if (mustache.strip.open) {
        this.buffer += '~';
      }

      this.Expression(mustache.path);
      this.Params(mustache.params);
      this.Hash(mustache.hash);

      if (mustache.strip.close) {
        this.buffer += '~';
      }

      this.buffer += mustache.escaped ? '}}' : '}}}';
    };

    _proto.BlockStatement = function BlockStatement(block) {
      if (this.handledByOverride(block)) {
        return;
      }

      if (block.chained) {
        this.buffer += block.inverseStrip.open ? '{{~' : '{{';
        this.buffer += 'else ';
      } else {
        this.buffer += block.openStrip.open ? '{{~#' : '{{#';
      }

      this.Expression(block.path);
      this.Params(block.params);
      this.Hash(block.hash);

      if (block.program.blockParams.length) {
        this.BlockParams(block.program.blockParams);
      }

      if (block.chained) {
        this.buffer += block.inverseStrip.close ? '~}}' : '}}';
      } else {
        this.buffer += block.openStrip.close ? '~}}' : '}}';
      }

      this.Block(block.program);

      if (block.inverse) {
        if (!block.inverse.chained) {
          this.buffer += block.inverseStrip.open ? '{{~' : '{{';
          this.buffer += 'else';
          this.buffer += block.inverseStrip.close ? '~}}' : '}}';
        }

        this.Block(block.inverse);
      }

      if (!block.chained) {
        this.buffer += block.closeStrip.open ? '{{~/' : '{{/';
        this.Expression(block.path);
        this.buffer += block.closeStrip.close ? '~}}' : '}}';
      }
    };

    _proto.BlockParams = function BlockParams(blockParams) {
      this.buffer += " as |" + blockParams.join(' ') + "|";
    };

    _proto.PartialStatement = function PartialStatement(partial) {
      if (this.handledByOverride(partial)) {
        return;
      }

      this.buffer += '{{>';
      this.Expression(partial.name);
      this.Params(partial.params);
      this.Hash(partial.hash);
      this.buffer += '}}';
    };

    _proto.ConcatStatement = function ConcatStatement(concat) {
      var _this2 = this;

      if (this.handledByOverride(concat)) {
        return;
      }

      this.buffer += '"';
      concat.parts.forEach(function (part) {
        if (part.type === 'TextNode') {
          _this2.TextNode(part, true);
        } else {
          _this2.Node(part);
        }
      });
      this.buffer += '"';
    };

    _proto.MustacheCommentStatement = function MustacheCommentStatement(comment) {
      if (this.handledByOverride(comment)) {
        return;
      }

      this.buffer += "{{!--" + comment.value + "--}}";
    };

    _proto.ElementModifierStatement = function ElementModifierStatement(mod) {
      if (this.handledByOverride(mod)) {
        return;
      }

      this.buffer += '{{';
      this.Expression(mod.path);
      this.Params(mod.params);
      this.Hash(mod.hash);
      this.buffer += '}}';
    };

    _proto.CommentStatement = function CommentStatement(comment) {
      if (this.handledByOverride(comment)) {
        return;
      }

      this.buffer += "<!--" + comment.value + "-->";
    };

    _proto.PathExpression = function PathExpression(path) {
      if (this.handledByOverride(path)) {
        return;
      }

      this.buffer += path.original;
    };

    _proto.SubExpression = function SubExpression(sexp) {
      if (this.handledByOverride(sexp)) {
        return;
      }

      this.buffer += '(';
      this.Expression(sexp.path);
      this.Params(sexp.params);
      this.Hash(sexp.hash);
      this.buffer += ')';
    };

    _proto.Params = function Params(params) {
      var _this3 = this;

      // TODO: implement a top level Params AST node (just like the Hash object)
      // so that this can also be overridden
      if (params.length) {
        params.forEach(function (param) {
          _this3.buffer += ' ';

          _this3.Expression(param);
        });
      }
    };

    _proto.Hash = function Hash(hash) {
      var _this4 = this;

      if (this.handledByOverride(hash, true)) {
        return;
      }

      hash.pairs.forEach(function (pair) {
        _this4.buffer += ' ';

        _this4.HashPair(pair);
      });
    };

    _proto.HashPair = function HashPair(pair) {
      if (this.handledByOverride(pair)) {
        return;
      }

      this.buffer += pair.key;
      this.buffer += '=';
      this.Node(pair.value);
    };

    _proto.StringLiteral = function StringLiteral(str) {
      if (this.handledByOverride(str)) {
        return;
      }

      this.buffer += JSON.stringify(str.value);
    };

    _proto.BooleanLiteral = function BooleanLiteral(bool) {
      if (this.handledByOverride(bool)) {
        return;
      }

      this.buffer += bool.value;
    };

    _proto.NumberLiteral = function NumberLiteral(number) {
      if (this.handledByOverride(number)) {
        return;
      }

      this.buffer += number.value;
    };

    _proto.UndefinedLiteral = function UndefinedLiteral(node) {
      if (this.handledByOverride(node)) {
        return;
      }

      this.buffer += 'undefined';
    };

    _proto.NullLiteral = function NullLiteral(node) {
      if (this.handledByOverride(node)) {
        return;
      }

      this.buffer += 'null';
    };

    _proto.print = function print(node) {
      var options = this.options;

      if (options.override) {
        var result = options.override(node, options);

        if (result !== undefined) {
          return result;
        }
      }

      this.buffer = '';
      this.Node(node);
      return this.buffer;
    };

    return Printer;
  }();

  function build(ast, options) {
    if (options === void 0) {
      options = {
        entityEncoding: 'transformed'
      };
    }

    if (!ast) {
      return '';
    }

    var printer = new Printer(options);
    return printer.print(ast);
  }

  function generateSyntaxError(message, location) {
    var module = location.module,
        loc = location.loc;
    var _loc$start = loc.start,
        line = _loc$start.line,
        column = _loc$start.column;
    var code = location.asString();
    var quotedCode = code ? "\n\n|\n|  " + code.split('\n').join('\n|  ') + "\n|\n\n" : '';
    var error = new Error(message + ": " + quotedCode + "(error occurred in '" + module + "' @ line " + line + " : column " + column + ")");
    error.name = 'SyntaxError';
    error.location = location;
    error.code = code;
    return error;
  }

  // ParentNode and ChildKey types are derived from VisitorKeysMap

  var visitorKeys = {
    Program: util.tuple('body'),
    Template: util.tuple('body'),
    Block: util.tuple('body'),
    MustacheStatement: util.tuple('path', 'params', 'hash'),
    BlockStatement: util.tuple('path', 'params', 'hash', 'program', 'inverse'),
    ElementModifierStatement: util.tuple('path', 'params', 'hash'),
    PartialStatement: util.tuple('name', 'params', 'hash'),
    CommentStatement: util.tuple(),
    MustacheCommentStatement: util.tuple(),
    ElementNode: util.tuple('attributes', 'modifiers', 'children', 'comments'),
    AttrNode: util.tuple('value'),
    TextNode: util.tuple(),
    ConcatStatement: util.tuple('parts'),
    SubExpression: util.tuple('path', 'params', 'hash'),
    PathExpression: util.tuple(),
    PathHead: util.tuple(),
    StringLiteral: util.tuple(),
    BooleanLiteral: util.tuple(),
    NumberLiteral: util.tuple(),
    NullLiteral: util.tuple(),
    UndefinedLiteral: util.tuple(),
    Hash: util.tuple('pairs'),
    HashPair: util.tuple('value'),
    // v2 new nodes
    NamedBlock: util.tuple('attributes', 'modifiers', 'children', 'comments'),
    SimpleElement: util.tuple('attributes', 'modifiers', 'children', 'comments'),
    Component: util.tuple('head', 'attributes', 'modifiers', 'children', 'comments')
  };

  var TraversalError = function () {
    TraversalError.prototype = Object.create(Error.prototype);
    TraversalError.prototype.constructor = TraversalError;

    function TraversalError(message, node, parent, key) {
      var error = Error.call(this, message);
      this.key = key;
      this.message = message;
      this.node = node;
      this.parent = parent;
      this.stack = error.stack;
    }

    return TraversalError;
  }();
  function cannotRemoveNode(node, parent, key) {
    return new TraversalError('Cannot remove a node unless it is part of an array', node, parent, key);
  }
  function cannotReplaceNode(node, parent, key) {
    return new TraversalError('Cannot replace a node with multiple nodes unless it is part of an array', node, parent, key);
  }
  function cannotReplaceOrRemoveInKeyHandlerYet(node, key) {
    return new TraversalError('Replacing and removing in key handlers is not yet supported.', node, null, key);
  }

  function _inheritsLoose$6(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  function _createForOfIteratorHelperLoose$3(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

  function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

  function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function getLocalName(node) {
    switch (node.type) {
      case 'ElementNode':
        // unfortunately the ElementNode stores `tag` as a string
        // if that changes in glimmer-vm this will need to be updated
        return node.tag.split('.')[0];

      case 'SubExpression':
      case 'MustacheStatement':
      case 'BlockStatement':
        return getLocalName(node.path);

      case 'UndefinedLiteral':
      case 'NullLiteral':
      case 'BooleanLiteral':
      case 'StringLiteral':
      case 'NumberLiteral':
      case 'TextNode':
      case 'Template':
      case 'Block':
      case 'CommentStatement':
      case 'MustacheCommentStatement':
      case 'PartialStatement':
      case 'ElementModifierStatement':
      case 'AttrNode':
      case 'ConcatStatement':
      case 'Program':
      case 'Hash':
      case 'HashPair':
        return undefined;

      case 'PathExpression':
      default:
        return node.parts.length ? node.parts[0] : undefined;
    }
  }

  function getLocals(node) {
    switch (node.type) {
      case 'ElementNode':
      case 'Program':
      case 'Block':
      case 'Template':
        return node.blockParams;

      case 'BlockStatement':
        return node.program.blockParams;

      default:
        return undefined;
    }
  }

  var TransformScope = /*#__PURE__*/function () {
    function TransformScope(locals) {
      this.locals = locals;
      this.hasPartial = false;
      this.usedLocals = {};

      for (var _iterator = _createForOfIteratorHelperLoose$3(locals), _step; !(_step = _iterator()).done;) {
        var local = _step.value;
        this.usedLocals[local] = false;
      }
    }

    var _proto = TransformScope.prototype;

    _proto.child = function child(node) {
      var locals = getLocals(node);
      return locals ? new ChildTransformScope(locals, this) : this;
    };

    _proto.usePartial = function usePartial() {
      this.hasPartial = true;
    };

    return TransformScope;
  }();

  var RootTransformScope = /*#__PURE__*/function (_TransformScope) {
    _inheritsLoose$6(RootTransformScope, _TransformScope);

    function RootTransformScope(node) {
      var _a;

      var locals = (_a = getLocals(node)) !== null && _a !== void 0 ? _a : [];
      return _TransformScope.call(this, locals) || this;
    }

    var _proto2 = RootTransformScope.prototype;

    _proto2.useLocal = function useLocal(node) {
      var name = getLocalName(node);

      if (name && name in this.usedLocals) {
        this.usedLocals[name] = true;
      }
    };

    _proto2.isLocal = function isLocal(name) {
      return this.locals.indexOf(name) !== -1;
    };

    _proto2.currentUnusedLocals = function currentUnusedLocals() {
      var _this = this;

      if (!this.hasPartial && this.locals.length > 0) {
        return this.locals.filter(function (local) {
          return !_this.usedLocals[local];
        });
      }

      return false;
    };

    return RootTransformScope;
  }(TransformScope);

  var ChildTransformScope = /*#__PURE__*/function (_TransformScope2) {
    _inheritsLoose$6(ChildTransformScope, _TransformScope2);

    function ChildTransformScope(locals, parent) {
      var _this2;

      _this2 = _TransformScope2.call(this, locals) || this;
      _this2.parent = parent;
      return _this2;
    }

    var _proto3 = ChildTransformScope.prototype;

    _proto3.useLocal = function useLocal(node) {
      var name = getLocalName(node);

      if (name && name in this.usedLocals) {
        this.usedLocals[name] = true;
      } else {
        this.parent.useLocal(node);
      }
    };

    _proto3.isLocal = function isLocal(name) {
      return this.locals.indexOf(name) !== -1 || this.parent.isLocal(name);
    };

    _proto3.currentUnusedLocals = function currentUnusedLocals() {
      if (!this.hasPartial && this.locals.length > 0) {
        // We only care about the last local, because if it is used then it implies
        // usage of the others (specifically when in a child block, |foo bar|)
        if (!this.usedLocals[this.locals[this.locals.length - 1]]) {
          return [this.locals[this.locals.length - 1]];
        }
      }

      return false;
    };

    return ChildTransformScope;
  }(TransformScope);

  function _defineProperties$6(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$6(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$6(Constructor.prototype, protoProps); if (staticProps) _defineProperties$6(Constructor, staticProps); return Constructor; }

  var WalkerPath = /*#__PURE__*/function () {
    function WalkerPath(node, parent, parentKey) {
      var _this = this;

      if (parent === void 0) {
        parent = null;
      }

      if (parentKey === void 0) {
        parentKey = null;
      }

      this.node = node;
      this.parent = parent;
      this.parentKey = parentKey;
      this.scope = parent ? parent.scope.child(node) : new RootTransformScope(node); // Consume in scope values

      if (node.type === 'PathExpression') {
        this.scope.useLocal(node);
      }

      if (node.type === 'ElementNode') {
        this.scope.useLocal(node);
        node.children.forEach(function (node) {
          return _this.scope.useLocal(node);
        });
      }
    }

    var _proto = WalkerPath.prototype;

    _proto.parents = function parents() {
      var _this2 = this,
          _ref;

      return _ref = {}, _ref[Symbol.iterator] = function () {
        return new PathParentsIterator(_this2);
      }, _ref;
    };

    _createClass$6(WalkerPath, [{
      key: "parentNode",
      get: function get() {
        return this.parent ? this.parent.node : null;
      }
    }]);

    return WalkerPath;
  }();

  var PathParentsIterator = /*#__PURE__*/function () {
    function PathParentsIterator(path) {
      this.path = path;
    }

    var _proto2 = PathParentsIterator.prototype;

    _proto2.next = function next() {
      if (this.path.parent) {
        this.path = this.path.parent;
        return {
          done: false,
          value: this.path
        };
      } else {
        return {
          done: true,
          value: null
        };
      }
    };

    return PathParentsIterator;
  }();

  function getEnterFunction(handler) {
    if (typeof handler === 'function') {
      return handler;
    } else {
      return handler.enter;
    }
  }

  function getExitFunction(handler) {
    if (typeof handler === 'function') {
      return undefined;
    } else {
      return handler.exit;
    }
  }

  function getKeyHandler(handler, key) {
    var keyVisitor = typeof handler !== 'function' ? handler.keys : undefined;
    if (keyVisitor === undefined) return;
    var keyHandler = keyVisitor[key];

    if (keyHandler !== undefined) {
      return keyHandler;
    }

    return keyVisitor.All;
  }

  function getNodeHandler(visitor, nodeType) {
    if (nodeType === 'Template' || nodeType === 'Block') {
      if (visitor.Program) {

        return visitor.Program;
      }
    }

    var handler = visitor[nodeType];

    if (handler !== undefined) {
      return handler;
    }

    return visitor.All;
  }

  function visitNode(visitor, path) {
    var node = path.node,
        parent = path.parent,
        parentKey = path.parentKey;
    var handler = getNodeHandler(visitor, node.type);
    var enter;
    var exit;

    if (handler !== undefined) {
      enter = getEnterFunction(handler);
      exit = getExitFunction(handler);
    }

    var result;

    if (enter !== undefined) {
      result = enter(node, path);
    }

    if (result !== undefined && result !== null) {
      if (JSON.stringify(node) === JSON.stringify(result)) {
        result = undefined;
      } else if (Array.isArray(result)) {
        visitArray(visitor, result, parent, parentKey);
        return result;
      } else {
        var _path = new WalkerPath(result, parent, parentKey);

        return visitNode(visitor, _path) || result;
      }
    }

    if (result === undefined) {
      var keys = visitorKeys[node.type];

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i]; // we know if it has child keys we can widen to a ParentNode

        visitKey(visitor, handler, path, key);
      }

      if (exit !== undefined) {
        result = exit(node, path);
      }
    }

    return result;
  }

  function get(node, key) {
    return node[key];
  }

  function set(node, key, value) {
    node[key] = value;
  }

  function visitKey(visitor, handler, path, key) {
    var node = path.node;
    var value = get(node, key);

    if (!value) {
      return;
    }

    var keyEnter;
    var keyExit;

    if (handler !== undefined) {
      var keyHandler = getKeyHandler(handler, key);

      if (keyHandler !== undefined) {
        keyEnter = getEnterFunction(keyHandler);
        keyExit = getExitFunction(keyHandler);
      }
    }

    if (keyEnter !== undefined) {
      if (keyEnter(node, key) !== undefined) {
        throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);
      }
    }

    if (Array.isArray(value)) {
      visitArray(visitor, value, path, key);
    } else {
      var keyPath = new WalkerPath(value, path, key);
      var result = visitNode(visitor, keyPath);

      if (result !== undefined) {
        // TODO: dynamically check the results by having a table of
        // expected node types in value space, not just type space
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        assignKey(node, key, value, result);
      }
    }

    if (keyExit !== undefined) {
      if (keyExit(node, key) !== undefined) {
        throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);
      }
    }
  }

  function visitArray(visitor, array, parent, parentKey) {
    for (var i = 0; i < array.length; i++) {
      var node = array[i];
      var path = new WalkerPath(node, parent, parentKey);
      var result = visitNode(visitor, path);

      if (result !== undefined) {
        i += spliceArray(array, i, result) - 1;
      }
    }
  }

  function assignKey(node, key, value, result) {
    if (result === null) {
      throw cannotRemoveNode(value, node, key);
    } else if (Array.isArray(result)) {
      if (result.length === 1) {
        set(node, key, result[0]);
      } else {
        if (result.length === 0) {
          throw cannotRemoveNode(value, node, key);
        } else {
          throw cannotReplaceNode(value, node, key);
        }
      }
    } else {
      set(node, key, result);
    }
  }

  function spliceArray(array, index, result) {
    if (result === null) {
      array.splice(index, 1);
      return 0;
    } else if (Array.isArray(result)) {
      array.splice.apply(array, [index, 1].concat(result));
      return result.length;
    } else {
      array.splice(index, 1, result);
      return 1;
    }
  }

  function traverse(node, visitor) {
    var path = new WalkerPath(node);
    visitNode(visitor, path);
  }

  var Walker = /*#__PURE__*/function () {
    function Walker(order) {
      this.order = order;
      this.stack = [];
    }

    var _proto = Walker.prototype;

    _proto.visit = function visit(node, callback) {
      if (!node) {
        return;
      }

      this.stack.push(node);

      if (this.order === 'post') {
        this.children(node, callback);
        callback(node, this);
      } else {
        callback(node, this);
        this.children(node, callback);
      }

      this.stack.pop();
    };

    _proto.children = function children(node, callback) {
      switch (node.type) {
        case 'Block':
        case 'Template':
          return visitors.Program(this, node, callback);

        case 'ElementNode':
          return visitors.ElementNode(this, node, callback);

        case 'BlockStatement':
          return visitors.BlockStatement(this, node, callback);

        default:
          return;
      }
    };

    return Walker;
  }();
  var visitors = {
    Program: function Program(walker, node, callback) {
      for (var i = 0; i < node.body.length; i++) {
        walker.visit(node.body[i], callback);
      }
    },
    Template: function Template(walker, node, callback) {
      for (var i = 0; i < node.body.length; i++) {
        walker.visit(node.body[i], callback);
      }
    },
    Block: function Block(walker, node, callback) {
      for (var i = 0; i < node.body.length; i++) {
        walker.visit(node.body[i], callback);
      }
    },
    ElementNode: function ElementNode(walker, node, callback) {
      for (var i = 0; i < node.children.length; i++) {
        walker.visit(node.children[i], callback);
      }
    },
    BlockStatement: function BlockStatement(walker, node, callback) {
      walker.visit(node.program, callback);
      walker.visit(node.inverse || null, callback);
    }
  };

  // Based on the ID validation regex in Handlebars.

  var ID_INVERSE_PATTERN = /[!"#%-,\.\/;->@\[-\^`\{-~]/; // Checks the element's attributes to see if it uses block params.
  // If it does, registers the block params with the program and
  // removes the corresponding attributes from the element.

  function parseElementBlockParams(element) {
    var params = parseBlockParams(element);
    if (params) element.blockParams = params;
  }

  function parseBlockParams(element) {
    var l = element.attributes.length;
    var attrNames = [];

    for (var i = 0; i < l; i++) {
      attrNames.push(element.attributes[i].name);
    }

    var asIndex = attrNames.indexOf('as');

    if (asIndex === -1 && attrNames.length > 0 && attrNames[attrNames.length - 1].charAt(0) === '|') {
      throw generateSyntaxError('Block parameters must be preceded by the `as` keyword, detected block parameters without `as`', element.loc);
    }

    if (asIndex !== -1 && l > asIndex && attrNames[asIndex + 1].charAt(0) === '|') {
      // Some basic validation, since we're doing the parsing ourselves
      var paramsString = attrNames.slice(asIndex).join(' ');

      if (paramsString.charAt(paramsString.length - 1) !== '|' || paramsString.match(/\|/g).length !== 2) {
        throw generateSyntaxError("Invalid block parameters syntax, '" + paramsString + "'", element.loc);
      }

      var params = [];

      for (var _i = asIndex + 1; _i < l; _i++) {
        var param = attrNames[_i].replace(/\|/g, '');

        if (param !== '') {
          if (ID_INVERSE_PATTERN.test(param)) {
            throw generateSyntaxError("Invalid identifier for block parameters, '" + param + "'", element.loc);
          }

          params.push(param);
        }
      }

      if (params.length === 0) {
        throw generateSyntaxError('Cannot use zero block parameters', element.loc);
      }

      element.attributes = element.attributes.slice(0, asIndex);
      return params;
    }

    return null;
  }

  function childrenFor(node) {
    switch (node.type) {
      case 'Block':
      case 'Template':
        return node.body;

      case 'ElementNode':
        return node.children;
    }
  }
  function appendChild(parent, node) {
    childrenFor(parent).push(node);
  }
  function isHBSLiteral(path) {
    return path.type === 'StringLiteral' || path.type === 'BooleanLiteral' || path.type === 'NumberLiteral' || path.type === 'NullLiteral' || path.type === 'UndefinedLiteral';
  }
  function printLiteral(literal) {
    if (literal.type === 'UndefinedLiteral') {
      return 'undefined';
    } else {
      return JSON.stringify(literal.value);
    }
  }
  function isUpperCase(tag) {
    return tag[0] === tag[0].toUpperCase() && tag[0] !== tag[0].toLowerCase();
  }
  function isLowerCase(tag) {
    return tag[0] === tag[0].toLowerCase() && tag[0] !== tag[0].toUpperCase();
  }

  var DEFAULT_STRIP = {
    close: false,
    open: false
  };
  /**
   * The Parser Builder differentiates from the public builder API by:
   *
   * 1. Offering fewer different ways to instantiate nodes
   * 2. Mandating source locations
   */

  var Builders = /*#__PURE__*/function () {
    function Builders() {}

    var _proto = Builders.prototype;

    _proto.pos = function pos(line, column) {
      return {
        line: line,
        column: column
      };
    };

    _proto.blockItself = function blockItself(_ref) {
      var body = _ref.body,
          blockParams = _ref.blockParams,
          _ref$chained = _ref.chained,
          chained = _ref$chained === void 0 ? false : _ref$chained,
          loc = _ref.loc;
      return {
        type: 'Block',
        body: body || [],
        blockParams: blockParams || [],
        chained: chained,
        loc: loc
      };
    };

    _proto.template = function template(_ref2) {
      var body = _ref2.body,
          blockParams = _ref2.blockParams,
          loc = _ref2.loc;
      return {
        type: 'Template',
        body: body || [],
        blockParams: blockParams || [],
        loc: loc
      };
    };

    _proto.mustache = function mustache(_ref3) {
      var path = _ref3.path,
          params = _ref3.params,
          hash = _ref3.hash,
          trusting = _ref3.trusting,
          loc = _ref3.loc,
          _ref3$strip = _ref3.strip,
          strip = _ref3$strip === void 0 ? DEFAULT_STRIP : _ref3$strip;
      return {
        type: 'MustacheStatement',
        path: path,
        params: params,
        hash: hash,
        escaped: !trusting,
        trusting: trusting,
        loc: loc,
        strip: strip || {
          open: false,
          close: false
        }
      };
    };

    _proto.block = function block(_ref4) {
      var path = _ref4.path,
          params = _ref4.params,
          hash = _ref4.hash,
          defaultBlock = _ref4.defaultBlock,
          _ref4$elseBlock = _ref4.elseBlock,
          elseBlock = _ref4$elseBlock === void 0 ? null : _ref4$elseBlock,
          loc = _ref4.loc,
          _ref4$openStrip = _ref4.openStrip,
          openStrip = _ref4$openStrip === void 0 ? DEFAULT_STRIP : _ref4$openStrip,
          _ref4$inverseStrip = _ref4.inverseStrip,
          inverseStrip = _ref4$inverseStrip === void 0 ? DEFAULT_STRIP : _ref4$inverseStrip,
          _ref4$closeStrip = _ref4.closeStrip,
          closeStrip = _ref4$closeStrip === void 0 ? DEFAULT_STRIP : _ref4$closeStrip;
      return {
        type: 'BlockStatement',
        path: path,
        params: params,
        hash: hash,
        program: defaultBlock,
        inverse: elseBlock,
        loc: loc,
        openStrip: openStrip,
        inverseStrip: inverseStrip,
        closeStrip: closeStrip
      };
    };

    _proto.comment = function comment(value, loc) {
      return {
        type: 'CommentStatement',
        value: value,
        loc: loc
      };
    };

    _proto.mustacheComment = function mustacheComment(value, loc) {
      return {
        type: 'MustacheCommentStatement',
        value: value,
        loc: loc
      };
    };

    _proto.concat = function concat(parts, loc) {
      return {
        type: 'ConcatStatement',
        parts: parts,
        loc: loc
      };
    };

    _proto.element = function element(_ref5) {
      var tag = _ref5.tag,
          selfClosing = _ref5.selfClosing,
          attrs = _ref5.attrs,
          blockParams = _ref5.blockParams,
          modifiers = _ref5.modifiers,
          comments = _ref5.comments,
          children = _ref5.children,
          loc = _ref5.loc;
      return {
        type: 'ElementNode',
        tag: tag,
        selfClosing: selfClosing,
        attributes: attrs || [],
        blockParams: blockParams || [],
        modifiers: modifiers || [],
        comments: comments || [],
        children: children || [],
        loc: loc
      };
    };

    _proto.elementModifier = function elementModifier(_ref6) {
      var path = _ref6.path,
          params = _ref6.params,
          hash = _ref6.hash,
          loc = _ref6.loc;
      return {
        type: 'ElementModifierStatement',
        path: path,
        params: params,
        hash: hash,
        loc: loc
      };
    };

    _proto.attr = function attr(_ref7) {
      var name = _ref7.name,
          value = _ref7.value,
          loc = _ref7.loc;
      return {
        type: 'AttrNode',
        name: name,
        value: value,
        loc: loc
      };
    };

    _proto.text = function text(_ref8) {
      var chars = _ref8.chars,
          loc = _ref8.loc;
      return {
        type: 'TextNode',
        chars: chars,
        loc: loc
      };
    };

    _proto.sexpr = function sexpr(_ref9) {
      var path = _ref9.path,
          params = _ref9.params,
          hash = _ref9.hash,
          loc = _ref9.loc;
      return {
        type: 'SubExpression',
        path: path,
        params: params,
        hash: hash,
        loc: loc
      };
    };

    _proto.path = function path(_ref10) {
      var head = _ref10.head,
          tail = _ref10.tail,
          loc = _ref10.loc;

      var _headToString = headToString$1(head),
          originalHead = _headToString.original;

      var original = [].concat(originalHead, tail).join('.');
      return new PathExpressionImplV1(original, head, tail, loc);
    };

    _proto.head = function head(_head, loc) {
      if (_head[0] === '@') {
        return this.atName(_head, loc);
      } else if (_head === 'this') {
        return this["this"](loc);
      } else {
        return this["var"](_head, loc);
      }
    };

    _proto["this"] = function _this(loc) {
      return {
        type: 'ThisHead',
        loc: loc
      };
    };

    _proto.atName = function atName(name, loc) {
      return {
        type: 'AtHead',
        name: name,
        loc: loc
      };
    };

    _proto["var"] = function _var(name, loc) {
      return {
        type: 'VarHead',
        name: name,
        loc: loc
      };
    };

    _proto.hash = function hash(pairs, loc) {
      return {
        type: 'Hash',
        pairs: pairs || [],
        loc: loc
      };
    };

    _proto.pair = function pair(_ref11) {
      var key = _ref11.key,
          value = _ref11.value,
          loc = _ref11.loc;
      return {
        type: 'HashPair',
        key: key,
        value: value,
        loc: loc
      };
    };

    _proto.literal = function literal(_ref12) {
      var type = _ref12.type,
          value = _ref12.value,
          loc = _ref12.loc;
      return {
        type: type,
        value: value,
        original: value,
        loc: loc
      };
    };

    _proto.undefined = function (_undefined) {
      function undefined$1() {
        return _undefined.apply(this, arguments);
      }

      undefined$1.toString = function () {
        return _undefined.toString();
      };

      return undefined$1;
    }(function () {
      return this.literal({
        type: 'UndefinedLiteral',
        value: undefined
      });
    });

    _proto["null"] = function _null() {
      return this.literal({
        type: 'NullLiteral',
        value: null
      });
    };

    _proto.string = function string(value, loc) {
      return this.literal({
        type: 'StringLiteral',
        value: value,
        loc: loc
      });
    };

    _proto["boolean"] = function boolean(value, loc) {
      return this.literal({
        type: 'BooleanLiteral',
        value: value,
        loc: loc
      });
    };

    _proto.number = function number(value, loc) {
      return this.literal({
        type: 'NumberLiteral',
        value: value,
        loc: loc
      });
    };

    return Builders;
  }(); // Expressions


  function headToString$1(head) {
    switch (head.type) {
      case 'AtHead':
        return {
          original: head.name,
          parts: [head.name]
        };

      case 'ThisHead':
        return {
          original: "this",
          parts: []
        };

      case 'VarHead':
        return {
          original: head.name,
          parts: [head.name]
        };
    }
  }

  var b = new Builders();

  function _defineProperties$7(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$7(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$7(Constructor.prototype, protoProps); if (staticProps) _defineProperties$7(Constructor, staticProps); return Constructor; }
  var Parser = /*#__PURE__*/function () {
    function Parser(source, entityParser, mode) {
      if (entityParser === void 0) {
        entityParser = new simpleHtmlTokenizer.EntityParser(simpleHtmlTokenizer.HTML5NamedCharRefs);
      }

      if (mode === void 0) {
        mode = 'precompile';
      }

      this.elementStack = [];
      this.currentAttribute = null;
      this.currentNode = null;
      this.source = source;
      this.lines = source.source.split(/(?:\r\n?|\n)/g);
      this.tokenizer = new simpleHtmlTokenizer.EventedTokenizer(this, entityParser, mode);
    }

    var _proto = Parser.prototype;

    _proto.offset = function offset() {
      var _this$tokenizer = this.tokenizer,
          line = _this$tokenizer.line,
          column = _this$tokenizer.column;
      return this.source.offsetFor(line, column);
    };

    _proto.pos = function pos(_ref) {
      var line = _ref.line,
          column = _ref.column;
      return this.source.offsetFor(line, column);
    };

    _proto.finish = function finish(node) {
      return util.assign({}, node, {
        loc: node.loc.until(this.offset())
      }); // node.loc = node.loc.withEnd(end);
    };

    _proto.acceptTemplate = function acceptTemplate(node) {
      return this[node.type](node);
    };

    _proto.acceptNode = function acceptNode(node) {
      return this[node.type](node);
    };

    _proto.currentElement = function currentElement() {
      return this.elementStack[this.elementStack.length - 1];
    };

    _proto.sourceForNode = function sourceForNode(node, endNode) {
      var firstLine = node.loc.start.line - 1;
      var currentLine = firstLine - 1;
      var firstColumn = node.loc.start.column;
      var string = [];
      var line;
      var lastLine;
      var lastColumn;

      if (endNode) {
        lastLine = endNode.loc.end.line - 1;
        lastColumn = endNode.loc.end.column;
      } else {
        lastLine = node.loc.end.line - 1;
        lastColumn = node.loc.end.column;
      }

      while (currentLine < lastLine) {
        currentLine++;
        line = this.lines[currentLine];

        if (currentLine === firstLine) {
          if (firstLine === lastLine) {
            string.push(line.slice(firstColumn, lastColumn));
          } else {
            string.push(line.slice(firstColumn));
          }
        } else if (currentLine === lastLine) {
          string.push(line.slice(0, lastColumn));
        } else {
          string.push(line);
        }
      }

      return string.join('\n');
    };

    _createClass$7(Parser, [{
      key: "currentAttr",
      get: function get() {
        return this.currentAttribute;
      }
    }, {
      key: "currentTag",
      get: function get() {
        var node = this.currentNode;
        return node;
      }
    }, {
      key: "currentStartTag",
      get: function get() {
        var node = this.currentNode;
        return node;
      }
    }, {
      key: "currentEndTag",
      get: function get() {
        var node = this.currentNode;
        return node;
      }
    }, {
      key: "currentComment",
      get: function get() {
        var node = this.currentNode;
        return node;
      }
    }, {
      key: "currentData",
      get: function get() {
        var node = this.currentNode;
        return node;
      }
    }]);

    return Parser;
  }();

  function _defineProperties$8(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$8(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$8(Constructor.prototype, protoProps); if (staticProps) _defineProperties$8(Constructor, staticProps); return Constructor; }

  function _inheritsLoose$7(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  var HandlebarsNodeVisitors = /*#__PURE__*/function (_Parser) {
    _inheritsLoose$7(HandlebarsNodeVisitors, _Parser);

    function HandlebarsNodeVisitors() {
      return _Parser.apply(this, arguments) || this;
    }

    var _proto = HandlebarsNodeVisitors.prototype;

    _proto.Program = function Program(program) {
      var body = [];
      var node;

      if (this.isTopLevel) {
        node = b.template({
          body: body,
          blockParams: program.blockParams,
          loc: this.source.spanFor(program.loc)
        });
      } else {
        node = b.blockItself({
          body: body,
          blockParams: program.blockParams,
          chained: program.chained,
          loc: this.source.spanFor(program.loc)
        });
      }

      var i,
          l = program.body.length;
      this.elementStack.push(node);

      if (l === 0) {
        return this.elementStack.pop();
      }

      for (i = 0; i < l; i++) {
        this.acceptNode(program.body[i]);
      } // Ensure that that the element stack is balanced properly.


      var poppedNode = this.elementStack.pop();

      if (poppedNode !== node) {
        var elementNode = poppedNode;
        throw generateSyntaxError("Unclosed element `" + elementNode.tag + "`", elementNode.loc);
      }

      return node;
    };

    _proto.BlockStatement = function BlockStatement(block) {
      if (this.tokenizer.state === "comment"
      /* comment */
      ) {
          this.appendToCommentData(this.sourceForNode(block));
          return;
        }

      if (this.tokenizer.state !== "data"
      /* data */
      && this.tokenizer.state !== "beforeData"
      /* beforeData */
      ) {
          throw generateSyntaxError('A block may only be used inside an HTML element or another block.', this.source.spanFor(block.loc));
        }

      var _acceptCallNodes = acceptCallNodes(this, block),
          path = _acceptCallNodes.path,
          params = _acceptCallNodes.params,
          hash = _acceptCallNodes.hash; // These are bugs in Handlebars upstream


      if (!block.program.loc) {
        block.program.loc = NON_EXISTENT_LOCATION;
      }

      if (block.inverse && !block.inverse.loc) {
        block.inverse.loc = NON_EXISTENT_LOCATION;
      }

      var program = this.Program(block.program);
      var inverse = block.inverse ? this.Program(block.inverse) : null;
      var node = b.block({
        path: path,
        params: params,
        hash: hash,
        defaultBlock: program,
        elseBlock: inverse,
        loc: this.source.spanFor(block.loc),
        openStrip: block.openStrip,
        inverseStrip: block.inverseStrip,
        closeStrip: block.closeStrip
      });
      var parentProgram = this.currentElement();
      appendChild(parentProgram, node);
    };

    _proto.MustacheStatement = function MustacheStatement(rawMustache) {
      var tokenizer = this.tokenizer;

      if (tokenizer.state === 'comment') {
        this.appendToCommentData(this.sourceForNode(rawMustache));
        return;
      }

      var mustache;
      var escaped = rawMustache.escaped,
          loc = rawMustache.loc,
          strip = rawMustache.strip;

      if (isHBSLiteral(rawMustache.path)) {
        mustache = b.mustache({
          path: this.acceptNode(rawMustache.path),
          params: [],
          hash: b.hash([], this.source.spanFor(rawMustache.path.loc).collapse('end')),
          trusting: !escaped,
          loc: this.source.spanFor(loc),
          strip: strip
        });
      } else {
        var _acceptCallNodes2 = acceptCallNodes(this, rawMustache),
            path = _acceptCallNodes2.path,
            params = _acceptCallNodes2.params,
            hash = _acceptCallNodes2.hash;

        mustache = b.mustache({
          path: path,
          params: params,
          hash: hash,
          trusting: !escaped,
          loc: this.source.spanFor(loc),
          strip: strip
        });
      }

      switch (tokenizer.state) {
        // Tag helpers
        case "tagOpen"
        /* tagOpen */
        :
        case "tagName"
        /* tagName */
        :
          throw generateSyntaxError("Cannot use mustaches in an elements tagname", mustache.loc);

        case "beforeAttributeName"
        /* beforeAttributeName */
        :
          addElementModifier(this.currentStartTag, mustache);
          break;

        case "attributeName"
        /* attributeName */
        :
        case "afterAttributeName"
        /* afterAttributeName */
        :
          this.beginAttributeValue(false);
          this.finishAttributeValue();
          addElementModifier(this.currentStartTag, mustache);
          tokenizer.transitionTo("beforeAttributeName"
          /* beforeAttributeName */
          );
          break;

        case "afterAttributeValueQuoted"
        /* afterAttributeValueQuoted */
        :
          addElementModifier(this.currentStartTag, mustache);
          tokenizer.transitionTo("beforeAttributeName"
          /* beforeAttributeName */
          );
          break;
        // Attribute values

        case "beforeAttributeValue"
        /* beforeAttributeValue */
        :
          this.beginAttributeValue(false);
          this.appendDynamicAttributeValuePart(mustache);
          tokenizer.transitionTo("attributeValueUnquoted"
          /* attributeValueUnquoted */
          );
          break;

        case "attributeValueDoubleQuoted"
        /* attributeValueDoubleQuoted */
        :
        case "attributeValueSingleQuoted"
        /* attributeValueSingleQuoted */
        :
        case "attributeValueUnquoted"
        /* attributeValueUnquoted */
        :
          this.appendDynamicAttributeValuePart(mustache);
          break;
        // TODO: Only append child when the tokenizer state makes
        // sense to do so, otherwise throw an error.

        default:
          appendChild(this.currentElement(), mustache);
      }

      return mustache;
    };

    _proto.appendDynamicAttributeValuePart = function appendDynamicAttributeValuePart(part) {
      this.finalizeTextPart();
      var attr = this.currentAttr;
      attr.isDynamic = true;
      attr.parts.push(part);
    };

    _proto.finalizeTextPart = function finalizeTextPart() {
      var attr = this.currentAttr;
      var text = attr.currentPart;

      if (text !== null) {
        this.currentAttr.parts.push(text);
        this.startTextPart();
      }
    };

    _proto.startTextPart = function startTextPart() {
      this.currentAttr.currentPart = null;
    };

    _proto.ContentStatement = function ContentStatement(content) {
      updateTokenizerLocation(this.tokenizer, content);
      this.tokenizer.tokenizePart(content.value);
      this.tokenizer.flushData();
    };

    _proto.CommentStatement = function CommentStatement(rawComment) {
      var tokenizer = this.tokenizer;

      if (tokenizer.state === "comment"
      /* comment */
      ) {
          this.appendToCommentData(this.sourceForNode(rawComment));
          return null;
        }

      var value = rawComment.value,
          loc = rawComment.loc;
      var comment = b.mustacheComment(value, this.source.spanFor(loc));

      switch (tokenizer.state) {
        case "beforeAttributeName"
        /* beforeAttributeName */
        :
        case "afterAttributeName"
        /* afterAttributeName */
        :
          this.currentStartTag.comments.push(comment);
          break;

        case "beforeData"
        /* beforeData */
        :
        case "data"
        /* data */
        :
          appendChild(this.currentElement(), comment);
          break;

        default:
          throw generateSyntaxError("Using a Handlebars comment when in the `" + tokenizer['state'] + "` state is not supported", this.source.spanFor(rawComment.loc));
      }

      return comment;
    };

    _proto.PartialStatement = function PartialStatement(partial) {
      throw generateSyntaxError("Handlebars partials are not supported", this.source.spanFor(partial.loc));
    };

    _proto.PartialBlockStatement = function PartialBlockStatement(partialBlock) {
      throw generateSyntaxError("Handlebars partial blocks are not supported", this.source.spanFor(partialBlock.loc));
    };

    _proto.Decorator = function Decorator(decorator) {
      throw generateSyntaxError("Handlebars decorators are not supported", this.source.spanFor(decorator.loc));
    };

    _proto.DecoratorBlock = function DecoratorBlock(decoratorBlock) {
      throw generateSyntaxError("Handlebars decorator blocks are not supported", this.source.spanFor(decoratorBlock.loc));
    };

    _proto.SubExpression = function SubExpression(sexpr) {
      var _acceptCallNodes3 = acceptCallNodes(this, sexpr),
          path = _acceptCallNodes3.path,
          params = _acceptCallNodes3.params,
          hash = _acceptCallNodes3.hash;

      return b.sexpr({
        path: path,
        params: params,
        hash: hash,
        loc: this.source.spanFor(sexpr.loc)
      });
    };

    _proto.PathExpression = function PathExpression(path) {
      var original = path.original;
      var parts;

      if (original.indexOf('/') !== -1) {
        if (original.slice(0, 2) === './') {
          throw generateSyntaxError("Using \"./\" is not supported in Glimmer and unnecessary", this.source.spanFor(path.loc));
        }

        if (original.slice(0, 3) === '../') {
          throw generateSyntaxError("Changing context using \"../\" is not supported in Glimmer", this.source.spanFor(path.loc));
        }

        if (original.indexOf('.') !== -1) {
          throw generateSyntaxError("Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths", this.source.spanFor(path.loc));
        }

        parts = [path.parts.join('/')];
      } else if (original === '.') {
        throw generateSyntaxError("'.' is not a supported path in Glimmer; check for a path with a trailing '.'", this.source.spanFor(path.loc));
      } else {
        parts = path.parts;
      }

      var thisHead = false; // This is to fix a bug in the Handlebars AST where the path expressions in
      // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
      // are simply turned into `{{foo}}`. The fix is to push it back onto the
      // parts array and let the runtime see the difference. However, we cannot
      // simply use the string `this` as it means literally the property called
      // "this" in the current context (it can be expressed in the syntax as
      // `{{[this]}}`, where the square bracket are generally for this kind of
      // escaping – such as `{{foo.["bar.baz"]}}` would mean lookup a property
      // named literally "bar.baz" on `this.foo`). By convention, we use `null`
      // for this purpose.

      if (original.match(/^this(\..+)?$/)) {
        thisHead = true;
      }

      var pathHead;

      if (thisHead) {
        pathHead = {
          type: 'ThisHead',
          loc: {
            start: path.loc.start,
            end: {
              line: path.loc.start.line,
              column: path.loc.start.column + 4
            }
          }
        };
      } else if (path.data) {
        var head = parts.shift();

        if (head === undefined) {
          throw generateSyntaxError("Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.", this.source.spanFor(path.loc));
        }

        pathHead = {
          type: 'AtHead',
          name: "@" + head,
          loc: {
            start: path.loc.start,
            end: {
              line: path.loc.start.line,
              column: path.loc.start.column + head.length + 1
            }
          }
        };
      } else {
        var _head = parts.shift();

        if (_head === undefined) {
          throw generateSyntaxError("Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.", this.source.spanFor(path.loc));
        }

        pathHead = {
          type: 'VarHead',
          name: _head,
          loc: {
            start: path.loc.start,
            end: {
              line: path.loc.start.line,
              column: path.loc.start.column + _head.length
            }
          }
        };
      }

      return new PathExpressionImplV1(path.original, pathHead, parts, this.source.spanFor(path.loc));
    };

    _proto.Hash = function Hash(hash) {
      var pairs = [];

      for (var i = 0; i < hash.pairs.length; i++) {
        var pair = hash.pairs[i];
        pairs.push(b.pair({
          key: pair.key,
          value: this.acceptNode(pair.value),
          loc: this.source.spanFor(pair.loc)
        }));
      }

      return b.hash(pairs, this.source.spanFor(hash.loc));
    };

    _proto.StringLiteral = function StringLiteral(string) {
      return b.literal({
        type: 'StringLiteral',
        value: string.value,
        loc: string.loc
      });
    };

    _proto.BooleanLiteral = function BooleanLiteral(_boolean) {
      return b.literal({
        type: 'BooleanLiteral',
        value: _boolean.value,
        loc: _boolean.loc
      });
    };

    _proto.NumberLiteral = function NumberLiteral(number) {
      return b.literal({
        type: 'NumberLiteral',
        value: number.value,
        loc: number.loc
      });
    };

    _proto.UndefinedLiteral = function UndefinedLiteral(undef) {
      return b.literal({
        type: 'UndefinedLiteral',
        value: undefined,
        loc: undef.loc
      });
    };

    _proto.NullLiteral = function NullLiteral(nul) {
      return b.literal({
        type: 'NullLiteral',
        value: null,
        loc: nul.loc
      });
    };

    _createClass$8(HandlebarsNodeVisitors, [{
      key: "isTopLevel",
      get: function get() {
        return this.elementStack.length === 0;
      }
    }]);

    return HandlebarsNodeVisitors;
  }(Parser);

  function calculateRightStrippedOffsets(original, value) {
    if (value === '') {
      // if it is empty, just return the count of newlines
      // in original
      return {
        lines: original.split('\n').length - 1,
        columns: 0
      };
    } // otherwise, return the number of newlines prior to
    // `value`


    var difference = original.split(value)[0];
    var lines = difference.split(/\n/);
    var lineCount = lines.length - 1;
    return {
      lines: lineCount,
      columns: lines[lineCount].length
    };
  }

  function updateTokenizerLocation(tokenizer, content) {
    var line = content.loc.start.line;
    var column = content.loc.start.column;
    var offsets = calculateRightStrippedOffsets(content.original, content.value);
    line = line + offsets.lines;

    if (offsets.lines) {
      column = offsets.columns;
    } else {
      column = column + offsets.columns;
    }

    tokenizer.line = line;
    tokenizer.column = column;
  }

  function acceptCallNodes(compiler, node) {
    var path = node.path.type === 'PathExpression' ? compiler.PathExpression(node.path) : compiler.SubExpression(node.path);
    var params = node.params ? node.params.map(function (e) {
      return compiler.acceptNode(e);
    }) : []; // if there is no hash, position it as a collapsed node immediately after the last param (or the
    // path, if there are also no params)

    var end = params.length > 0 ? params[params.length - 1].loc : path.loc;
    var hash = node.hash ? compiler.Hash(node.hash) : {
      type: 'Hash',
      pairs: [],
      loc: compiler.source.spanFor(end).collapse('end')
    };
    return {
      path: path,
      params: params,
      hash: hash
    };
  }

  function addElementModifier(element, mustache) {
    var path = mustache.path,
        params = mustache.params,
        hash = mustache.hash,
        loc = mustache.loc;

    if (isHBSLiteral(path)) {
      var _modifier = "{{" + printLiteral(path) + "}}";

      var tag = "<" + element.name + " ... " + _modifier + " ...";
      throw generateSyntaxError("In " + tag + ", " + _modifier + " is not a valid modifier", mustache.loc);
    }

    var modifier = b.elementModifier({
      path: path,
      params: params,
      hash: hash,
      loc: loc
    });
    element.modifiers.push(modifier);
  }

  function _inheritsLoose$8(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  var TokenizerEventHandlers = /*#__PURE__*/function (_HandlebarsNodeVisito) {
    _inheritsLoose$8(TokenizerEventHandlers, _HandlebarsNodeVisito);

    function TokenizerEventHandlers() {
      var _this;

      _this = _HandlebarsNodeVisito.apply(this, arguments) || this;
      _this.tagOpenLine = 0;
      _this.tagOpenColumn = 0;
      return _this;
    }

    var _proto = TokenizerEventHandlers.prototype;

    _proto.reset = function reset() {
      this.currentNode = null;
    } // Comment
    ;

    _proto.beginComment = function beginComment() {
      this.currentNode = b.comment('', this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn));
    };

    _proto.appendToCommentData = function appendToCommentData(_char) {
      this.currentComment.value += _char;
    };

    _proto.finishComment = function finishComment() {
      appendChild(this.currentElement(), this.finish(this.currentComment));
    } // Data
    ;

    _proto.beginData = function beginData() {
      this.currentNode = b.text({
        chars: '',
        loc: this.offset().collapsed()
      });
    };

    _proto.appendToData = function appendToData(_char2) {
      this.currentData.chars += _char2;
    };

    _proto.finishData = function finishData() {
      this.currentData.loc = this.currentData.loc.withEnd(this.offset());
      appendChild(this.currentElement(), this.currentData);
    } // Tags - basic
    ;

    _proto.tagOpen = function tagOpen() {
      this.tagOpenLine = this.tokenizer.line;
      this.tagOpenColumn = this.tokenizer.column;
    };

    _proto.beginStartTag = function beginStartTag() {
      this.currentNode = {
        type: 'StartTag',
        name: '',
        attributes: [],
        modifiers: [],
        comments: [],
        selfClosing: false,
        loc: this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn)
      };
    };

    _proto.beginEndTag = function beginEndTag() {
      this.currentNode = {
        type: 'EndTag',
        name: '',
        attributes: [],
        modifiers: [],
        comments: [],
        selfClosing: false,
        loc: this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn)
      };
    };

    _proto.finishTag = function finishTag() {
      var tag = this.finish(this.currentTag);

      if (tag.type === 'StartTag') {
        this.finishStartTag();

        if (tag.name === ':') {
          throw generateSyntaxError('Invalid named block named detected, you may have created a named block without a name, or you may have began your name with a number. Named blocks must have names that are at least one character long, and begin with a lower case letter', this.source.spanFor({
            start: this.currentTag.loc.toJSON(),
            end: this.offset().toJSON()
          }));
        }

        if (voidMap[tag.name] || tag.selfClosing) {
          this.finishEndTag(true);
        }
      } else if (tag.type === 'EndTag') {
        this.finishEndTag(false);
      }
    };

    _proto.finishStartTag = function finishStartTag() {
      var _this$finish = this.finish(this.currentStartTag),
          name = _this$finish.name,
          attrs = _this$finish.attributes,
          modifiers = _this$finish.modifiers,
          comments = _this$finish.comments,
          selfClosing = _this$finish.selfClosing,
          loc = _this$finish.loc;

      var element = b.element({
        tag: name,
        selfClosing: selfClosing,
        attrs: attrs,
        modifiers: modifiers,
        comments: comments,
        children: [],
        blockParams: [],
        loc: loc
      });
      this.elementStack.push(element);
    };

    _proto.finishEndTag = function finishEndTag(isVoid) {
      var tag = this.finish(this.currentTag);
      var element = this.elementStack.pop();
      var parent = this.currentElement();
      this.validateEndTag(tag, element, isVoid);
      element.loc = element.loc.withEnd(this.offset());
      parseElementBlockParams(element);
      appendChild(parent, element);
    };

    _proto.markTagAsSelfClosing = function markTagAsSelfClosing() {
      this.currentTag.selfClosing = true;
    } // Tags - name
    ;

    _proto.appendToTagName = function appendToTagName(_char3) {
      this.currentTag.name += _char3;
    } // Tags - attributes
    ;

    _proto.beginAttribute = function beginAttribute() {
      var offset = this.offset();
      this.currentAttribute = {
        name: '',
        parts: [],
        currentPart: null,
        isQuoted: false,
        isDynamic: false,
        start: offset,
        valueSpan: offset.collapsed()
      };
    };

    _proto.appendToAttributeName = function appendToAttributeName(_char4) {
      this.currentAttr.name += _char4;
    };

    _proto.beginAttributeValue = function beginAttributeValue(isQuoted) {
      this.currentAttr.isQuoted = isQuoted;
      this.startTextPart();
      this.currentAttr.valueSpan = this.offset().collapsed();
    };

    _proto.appendToAttributeValue = function appendToAttributeValue(_char5) {
      var parts = this.currentAttr.parts;
      var lastPart = parts[parts.length - 1];
      var current = this.currentAttr.currentPart;

      if (current) {
        current.chars += _char5; // update end location for each added char

        current.loc = current.loc.withEnd(this.offset());
      } else {
        // initially assume the text node is a single char
        var loc = this.offset(); // the tokenizer line/column have already been advanced, correct location info

        if (_char5 === '\n') {
          loc = lastPart ? lastPart.loc.getEnd() : this.currentAttr.valueSpan.getStart();
        } else {
          loc = loc.move(-1);
        }

        this.currentAttr.currentPart = b.text({
          chars: _char5,
          loc: loc.collapsed()
        });
      }
    };

    _proto.finishAttributeValue = function finishAttributeValue() {
      this.finalizeTextPart();
      var tag = this.currentTag;
      var tokenizerPos = this.offset();

      if (tag.type === 'EndTag') {
        throw generateSyntaxError("Invalid end tag: closing tag must not have attributes", this.source.spanFor({
          start: tag.loc.toJSON(),
          end: tokenizerPos.toJSON()
        }));
      }

      var _this$currentAttr = this.currentAttr,
          name = _this$currentAttr.name,
          parts = _this$currentAttr.parts,
          start = _this$currentAttr.start,
          isQuoted = _this$currentAttr.isQuoted,
          isDynamic = _this$currentAttr.isDynamic,
          valueSpan = _this$currentAttr.valueSpan;
      var value = this.assembleAttributeValue(parts, isQuoted, isDynamic, start.until(tokenizerPos));
      value.loc = valueSpan.withEnd(tokenizerPos);
      var attribute = b.attr({
        name: name,
        value: value,
        loc: start.until(tokenizerPos)
      });
      this.currentStartTag.attributes.push(attribute);
    };

    _proto.reportSyntaxError = function reportSyntaxError(message) {
      throw generateSyntaxError(message, this.offset().collapsed());
    };

    _proto.assembleConcatenatedValue = function assembleConcatenatedValue(parts) {
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];

        if (part.type !== 'MustacheStatement' && part.type !== 'TextNode') {
          throw generateSyntaxError('Unsupported node in quoted attribute value: ' + part['type'], part.loc);
        }
      }

      util.assertPresent(parts, "the concatenation parts of an element should not be empty");
      var first = parts[0];
      var last = parts[parts.length - 1];
      return b.concat(parts, this.source.spanFor(first.loc).extend(this.source.spanFor(last.loc)));
    };

    _proto.validateEndTag = function validateEndTag(tag, element, selfClosing) {
      var error;

      if (voidMap[tag.name] && !selfClosing) {
        // EngTag is also called by StartTag for void and self-closing tags (i.e.
        // <input> or <br />, so we need to check for that here. Otherwise, we would
        // throw an error for those cases.
        error = "<" + tag.name + "> elements do not need end tags. You should remove it";
      } else if (element.tag === undefined) {
        error = "Closing tag </" + tag.name + "> without an open tag";
      } else if (element.tag !== tag.name) {
        error = "Closing tag </" + tag.name + "> did not match last open tag <" + element.tag + "> (on line " + element.loc.startPosition.line + ")";
      }

      if (error) {
        throw generateSyntaxError(error, tag.loc);
      }
    };

    _proto.assembleAttributeValue = function assembleAttributeValue(parts, isQuoted, isDynamic, span) {
      if (isDynamic) {
        if (isQuoted) {
          return this.assembleConcatenatedValue(parts);
        } else {
          if (parts.length === 1 || parts.length === 2 && parts[1].type === 'TextNode' && parts[1].chars === '/') {
            return parts[0];
          } else {
            throw generateSyntaxError("An unquoted attribute value must be a string or a mustache, " + "preceded by whitespace or a '=' character, and " + "followed by whitespace, a '>' character, or '/>'", span);
          }
        }
      } else {
        return parts.length > 0 ? parts[0] : b.text({
          chars: '',
          loc: span
        });
      }
    };

    return TokenizerEventHandlers;
  }(HandlebarsNodeVisitors);
  var syntax = {
    parse: preprocess,
    builders: publicBuilder,
    print: build,
    traverse: traverse,
    Walker: Walker
  };

  var CodemodEntityParser = /*#__PURE__*/function (_EntityParser) {
    _inheritsLoose$8(CodemodEntityParser, _EntityParser);

    // match upstream types, but never match an entity
    function CodemodEntityParser() {
      return _EntityParser.call(this, {}) || this;
    }

    var _proto2 = CodemodEntityParser.prototype;

    _proto2.parse = function parse() {
      return undefined;
    };

    return CodemodEntityParser;
  }(simpleHtmlTokenizer.EntityParser);

  function preprocess(input, options) {
    if (options === void 0) {
      options = {};
    }

    var _a, _b, _c;

    var mode = options.mode || 'precompile';
    var source;
    var ast;

    if (typeof input === 'string') {
      source = new Source(input, (_a = options.meta) === null || _a === void 0 ? void 0 : _a.moduleName);

      if (mode === 'codemod') {
        ast = parser.parseWithoutProcessing(input, options.parseOptions);
      } else {
        ast = parser.parse(input, options.parseOptions);
      }
    } else if (input instanceof Source) {
      source = input;

      if (mode === 'codemod') {
        ast = parser.parseWithoutProcessing(input.source, options.parseOptions);
      } else {
        ast = parser.parse(input.source, options.parseOptions);
      }
    } else {
      source = new Source('', (_b = options.meta) === null || _b === void 0 ? void 0 : _b.moduleName);
      ast = input;
    }

    var entityParser = undefined;

    if (mode === 'codemod') {
      entityParser = new CodemodEntityParser();
    }

    var offsets = SourceSpan.forCharPositions(source, 0, source.source.length);
    ast.loc = {
      source: '(program)',
      start: offsets.startPosition,
      end: offsets.endPosition
    };
    var program = new TokenizerEventHandlers(source, entityParser, mode).acceptTemplate(ast);

    if (options.strictMode) {
      program.blockParams = (_c = options.locals) !== null && _c !== void 0 ? _c : [];
    }

    if (options && options.plugins && options.plugins.ast) {
      for (var i = 0, l = options.plugins.ast.length; i < l; i++) {
        var transform = options.plugins.ast[i];
        var env = util.assign({}, options, {
          syntax: syntax
        }, {
          plugins: undefined
        });
        var pluginResult = transform(env);
        traverse(program, pluginResult.visitor);
      }
    }

    return program;
  }

  function _defineProperties$9(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$9(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$9(Constructor.prototype, protoProps); if (staticProps) _defineProperties$9(Constructor, staticProps); return Constructor; }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inheritsLoose$9(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  var __classPrivateFieldSet$4 = undefined && undefined.__classPrivateFieldSet || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }

    privateMap.set(receiver, value);
    return value;
  };

  var __classPrivateFieldGet$4 = undefined && undefined.__classPrivateFieldGet || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }

    return privateMap.get(receiver);
  };

  var _hasEval;
  var SymbolTable = /*#__PURE__*/function () {
    function SymbolTable() {}

    SymbolTable.top = function top(locals, customizeComponentName) {
      return new ProgramSymbolTable(locals, customizeComponentName);
    };

    var _proto = SymbolTable.prototype;

    _proto.child = function child(locals) {
      var _this = this;

      var symbols = locals.map(function (name) {
        return _this.allocate(name);
      });
      return new BlockSymbolTable(this, locals, symbols);
    };

    return SymbolTable;
  }();
  var ProgramSymbolTable = /*#__PURE__*/function (_SymbolTable) {
    _inheritsLoose$9(ProgramSymbolTable, _SymbolTable);

    function ProgramSymbolTable(templateLocals, customizeComponentName) {
      var _this2;

      _this2 = _SymbolTable.call(this) || this;
      _this2.templateLocals = templateLocals;
      _this2.customizeComponentName = customizeComponentName;
      _this2.symbols = [];
      _this2.upvars = [];
      _this2.size = 1;
      _this2.named = util.dict();
      _this2.blocks = util.dict();
      _this2.usedTemplateLocals = [];

      _hasEval.set(_assertThisInitialized(_this2), false);

      return _this2;
    }

    var _proto2 = ProgramSymbolTable.prototype;

    _proto2.getUsedTemplateLocals = function getUsedTemplateLocals() {
      return this.usedTemplateLocals;
    };

    _proto2.setHasEval = function setHasEval() {
      __classPrivateFieldSet$4(this, _hasEval, true);
    };

    _proto2.has = function has(name) {
      return this.templateLocals.indexOf(name) !== -1;
    };

    _proto2.get = function get(name) {
      var index = this.usedTemplateLocals.indexOf(name);

      if (index !== -1) {
        return [index, true];
      }

      index = this.usedTemplateLocals.length;
      this.usedTemplateLocals.push(name);
      return [index, true];
    };

    _proto2.getLocalsMap = function getLocalsMap() {
      return util.dict();
    };

    _proto2.getEvalInfo = function getEvalInfo() {
      var locals = this.getLocalsMap();
      return Object.keys(locals).map(function (symbol) {
        return locals[symbol];
      });
    };

    _proto2.allocateFree = function allocateFree(name, resolution) {
      // If the name in question is an uppercase (i.e. angle-bracket) component invocation, run
      // the optional `customizeComponentName` function provided to the precompiler.
      if (resolution.resolution() === 39
      /* GetFreeAsComponentHead */
      && resolution.isAngleBracket && isUpperCase(name)) {
        name = this.customizeComponentName(name);
      }

      var index = this.upvars.indexOf(name);

      if (index !== -1) {
        return index;
      }

      index = this.upvars.length;
      this.upvars.push(name);
      return index;
    };

    _proto2.allocateNamed = function allocateNamed(name) {
      var named = this.named[name];

      if (!named) {
        named = this.named[name] = this.allocate(name);
      }

      return named;
    };

    _proto2.allocateBlock = function allocateBlock(name) {
      if (name === 'inverse') {
        name = 'else';
      }

      var block = this.blocks[name];

      if (!block) {
        block = this.blocks[name] = this.allocate("&" + name);
      }

      return block;
    };

    _proto2.allocate = function allocate(identifier) {
      this.symbols.push(identifier);
      return this.size++;
    };

    _createClass$9(ProgramSymbolTable, [{
      key: "hasEval",
      get: function get() {
        return __classPrivateFieldGet$4(this, _hasEval);
      }
    }]);

    return ProgramSymbolTable;
  }(SymbolTable);
  _hasEval = new WeakMap();
  var BlockSymbolTable = /*#__PURE__*/function (_SymbolTable2) {
    _inheritsLoose$9(BlockSymbolTable, _SymbolTable2);

    function BlockSymbolTable(parent, symbols, slots) {
      var _this3;

      _this3 = _SymbolTable2.call(this) || this;
      _this3.parent = parent;
      _this3.symbols = symbols;
      _this3.slots = slots;
      return _this3;
    }

    var _proto3 = BlockSymbolTable.prototype;

    _proto3.has = function has(name) {
      return this.symbols.indexOf(name) !== -1 || this.parent.has(name);
    };

    _proto3.get = function get(name) {
      var slot = this.symbols.indexOf(name);
      return slot === -1 ? this.parent.get(name) : [this.slots[slot], false];
    };

    _proto3.getLocalsMap = function getLocalsMap() {
      var _this4 = this;

      var dict = this.parent.getLocalsMap();
      this.symbols.forEach(function (symbol) {
        return dict[symbol] = _this4.get(symbol)[0];
      });
      return dict;
    };

    _proto3.getEvalInfo = function getEvalInfo() {
      var locals = this.getLocalsMap();
      return Object.keys(locals).map(function (symbol) {
        return locals[symbol];
      });
    };

    _proto3.setHasEval = function setHasEval() {
      this.parent.setHasEval();
    };

    _proto3.allocateFree = function allocateFree(name, resolution) {
      return this.parent.allocateFree(name, resolution);
    };

    _proto3.allocateNamed = function allocateNamed(name) {
      return this.parent.allocateNamed(name);
    };

    _proto3.allocateBlock = function allocateBlock(name) {
      return this.parent.allocateBlock(name);
    };

    _proto3.allocate = function allocate(identifier) {
      return this.parent.allocate(identifier);
    };

    _createClass$9(BlockSymbolTable, [{
      key: "locals",
      get: function get() {
        return this.symbols;
      }
    }]);

    return BlockSymbolTable;
  }(SymbolTable);

  var __rest = undefined && undefined.__rest || function (s, e) {
    var t = {};

    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    }

    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
  };
  var Builder = /*#__PURE__*/function () {
    function Builder() {}

    var _proto = Builder.prototype;

    // TEMPLATE //
    _proto.template = function template(symbols, body, loc) {
      return new Template({
        table: symbols,
        body: body,
        loc: loc
      });
    } // INTERNAL (these nodes cannot be reached when doing general-purpose visiting) //
    ;

    _proto.block = function block(symbols, body, loc) {
      return new Block({
        scope: symbols,
        body: body,
        loc: loc
      });
    };

    _proto.namedBlock = function namedBlock(name, block, loc) {
      return new NamedBlock({
        name: name,
        block: block,
        attrs: [],
        componentArgs: [],
        modifiers: [],
        loc: loc
      });
    };

    _proto.simpleNamedBlock = function simpleNamedBlock(name, block, loc) {
      return new BuildElement({
        selfClosing: false,
        attrs: [],
        componentArgs: [],
        modifiers: [],
        comments: []
      }).named(name, block, loc);
    };

    _proto.slice = function slice(chars, loc) {
      return new SourceSlice({
        loc: loc,
        chars: chars
      });
    };

    _proto.args = function args(positional, named, loc) {
      return new Args({
        loc: loc,
        positional: positional,
        named: named
      });
    };

    _proto.positional = function positional(exprs, loc) {
      return new PositionalArguments({
        loc: loc,
        exprs: exprs
      });
    };

    _proto.namedArgument = function namedArgument(key, value) {
      return new NamedArgument({
        name: key,
        value: value
      });
    };

    _proto.named = function named(entries, loc) {
      return new NamedArguments({
        loc: loc,
        entries: entries
      });
    };

    _proto.attr = function attr(_ref, loc) {
      var name = _ref.name,
          value = _ref.value,
          trusting = _ref.trusting;
      return new HtmlAttr({
        loc: loc,
        name: name,
        value: value,
        trusting: trusting
      });
    };

    _proto.splatAttr = function splatAttr(symbol, loc) {
      return new SplatAttr({
        symbol: symbol,
        loc: loc
      });
    };

    _proto.arg = function arg(_ref2, loc) {
      var name = _ref2.name,
          value = _ref2.value,
          trusting = _ref2.trusting;
      return new ComponentArg({
        name: name,
        value: value,
        trusting: trusting,
        loc: loc
      });
    } // EXPRESSIONS //
    ;

    _proto.path = function path(head, tail, loc) {
      return new PathExpression({
        loc: loc,
        ref: head,
        tail: tail
      });
    };

    _proto.self = function self(loc) {
      return new ThisReference({
        loc: loc
      });
    };

    _proto.at = function at(name, symbol, loc) {
      return new ArgReference({
        loc: loc,
        name: new SourceSlice({
          loc: loc,
          chars: name
        }),
        symbol: symbol
      });
    };

    _proto.freeVar = function freeVar(_ref3) {
      var name = _ref3.name,
          context = _ref3.context,
          symbol = _ref3.symbol,
          loc = _ref3.loc;
      return new FreeVarReference({
        name: name,
        resolution: context,
        symbol: symbol,
        loc: loc
      });
    };

    _proto.localVar = function localVar(name, symbol, isTemplateLocal, loc) {
      return new LocalVarReference({
        loc: loc,
        name: name,
        isTemplateLocal: isTemplateLocal,
        symbol: symbol
      });
    };

    _proto.sexp = function sexp(parts, loc) {
      return new CallExpression({
        loc: loc,
        callee: parts.callee,
        args: parts.args
      });
    };

    _proto.deprecatedCall = function deprecatedCall(arg, callee, loc) {
      return new DeprecatedCallExpression({
        loc: loc,
        arg: arg,
        callee: callee
      });
    };

    _proto.interpolate = function interpolate(parts, loc) {
      util.assertPresent(parts);
      return new InterpolateExpression({
        loc: loc,
        parts: parts
      });
    };

    _proto.literal = function literal(value, loc) {
      return new LiteralExpression({
        loc: loc,
        value: value
      });
    } // STATEMENTS //
    ;

    _proto.append = function append(_ref4, loc) {
      var table = _ref4.table,
          trusting = _ref4.trusting,
          value = _ref4.value;
      return new AppendContent({
        table: table,
        trusting: trusting,
        value: value,
        loc: loc
      });
    };

    _proto.modifier = function modifier(_ref5, loc) {
      var callee = _ref5.callee,
          args = _ref5.args;
      return new ElementModifier({
        loc: loc,
        callee: callee,
        args: args
      });
    };

    _proto.namedBlocks = function namedBlocks(blocks, loc) {
      return new NamedBlocks({
        loc: loc,
        blocks: blocks
      });
    };

    _proto.blockStatement = function blockStatement(_a, loc) {
      var symbols = _a.symbols,
          program = _a.program,
          _a$inverse = _a.inverse,
          inverse = _a$inverse === void 0 ? null : _a$inverse,
          call = __rest(_a, ["symbols", "program", "inverse"]);

      var blocksLoc = program.loc;
      var blocks = [this.namedBlock(SourceSlice.synthetic('default'), program, program.loc)];

      if (inverse) {
        blocksLoc = blocksLoc.extend(inverse.loc);
        blocks.push(this.namedBlock(SourceSlice.synthetic('else'), inverse, inverse.loc));
      }

      return new InvokeBlock({
        loc: loc,
        blocks: this.namedBlocks(blocks, blocksLoc),
        callee: call.callee,
        args: call.args
      });
    };

    _proto.element = function element(options) {
      return new BuildElement(options);
    };

    return Builder;
  }();
  var BuildElement = /*#__PURE__*/function () {
    function BuildElement(base) {
      this.base = base;
      this.builder = new Builder();
    }

    var _proto2 = BuildElement.prototype;

    _proto2.simple = function simple(tag, body, loc) {
      return new SimpleElement(util.assign({
        tag: tag,
        body: body,
        componentArgs: [],
        loc: loc
      }, this.base));
    };

    _proto2.named = function named(name, block, loc) {
      return new NamedBlock(util.assign({
        name: name,
        block: block,
        componentArgs: [],
        loc: loc
      }, this.base));
    };

    _proto2.selfClosingComponent = function selfClosingComponent(callee, loc) {
      return new InvokeComponent(util.assign({
        loc: loc,
        callee: callee,
        // point the empty named blocks at the `/` self-closing tag
        blocks: new NamedBlocks({
          blocks: [],
          loc: loc.sliceEndChars({
            skipEnd: 1,
            chars: 1
          })
        })
      }, this.base));
    };

    _proto2.componentWithDefaultBlock = function componentWithDefaultBlock(callee, children, symbols, loc) {
      var block = this.builder.block(symbols, children, loc);
      var namedBlock = this.builder.namedBlock(SourceSlice.synthetic('default'), block, loc); // BUILDER.simpleNamedBlock('default', children, symbols, loc);

      return new InvokeComponent(util.assign({
        loc: loc,
        callee: callee,
        blocks: this.builder.namedBlocks([namedBlock], namedBlock.loc)
      }, this.base));
    };

    _proto2.componentWithNamedBlocks = function componentWithNamedBlocks(callee, blocks, loc) {
      return new InvokeComponent(util.assign({
        loc: loc,
        callee: callee,
        blocks: this.builder.namedBlocks(blocks, SpanList.range(blocks))
      }, this.base));
    };

    return BuildElement;
  }();

  function SexpSyntaxContext(node) {
    if (isSimpleCallee(node)) {
      return LooseModeResolution.namespaced("Helper"
      /* Helper */
      );
    } else {
      return null;
    }
  }
  function ModifierSyntaxContext(node) {
    if (isSimpleCallee(node)) {
      return LooseModeResolution.namespaced("Modifier"
      /* Modifier */
      );
    } else {
      return null;
    }
  }
  function BlockSyntaxContext(node) {
    if (isSimpleCallee(node)) {
      return LooseModeResolution.namespaced("Component"
      /* Component */
      );
    } else {
      return LooseModeResolution.fallback();
    }
  }
  function ComponentSyntaxContext(node) {
    if (isSimplePath(node)) {
      return LooseModeResolution.namespaced("Component"
      /* Component */
      , true);
    } else {
      return null;
    }
  }
  /**
   * This corresponds to append positions (text curlies or attribute
   * curlies). In strict mode, this also corresponds to arg curlies.
   */

  function AttrValueSyntaxContext(node) {
    var isSimple = isSimpleCallee(node);
    var isInvoke = isInvokeNode(node);

    if (isSimple) {
      return isInvoke ? LooseModeResolution.namespaced("Helper"
      /* Helper */
      ) : LooseModeResolution.attr();
    } else {
      return isInvoke ? STRICT_RESOLUTION : LooseModeResolution.fallback();
    }
  }
  /**
   * This corresponds to append positions (text curlies or attribute
   * curlies). In strict mode, this also corresponds to arg curlies.
   */

  function AppendSyntaxContext(node) {
    var isSimple = isSimpleCallee(node);
    var isInvoke = isInvokeNode(node);
    var trusting = node.trusting;

    if (isSimple) {
      return trusting ? LooseModeResolution.trustingAppend({
        invoke: isInvoke
      }) : LooseModeResolution.append({
        invoke: isInvoke
      });
    } else {
      return LooseModeResolution.fallback();
    }
  } // UTILITIES

  /**
   * A call node has a simple callee if its head is:
   *
   * - a `PathExpression`
   * - the `PathExpression`'s head is a `VarHead`
   * - it has no tail
   *
   * Simple heads:
   *
   * ```
   * {{x}}
   * {{x y}}
   * ```
   *
   * Not simple heads:
   *
   * ```
   * {{x.y}}
   * {{x.y z}}
   * {{@x}}
   * {{@x a}}
   * {{this}}
   * {{this a}}
   * ```
   */

  function isSimpleCallee(node) {
    var path = node.path;
    return isSimplePath(path);
  }

  function isSimplePath(node) {
    if (node.type === 'PathExpression' && node.head.type === 'VarHead') {
      return node.tail.length === 0;
    } else {
      return false;
    }
  }
  /**
   * The call expression has at least one argument.
   */


  function isInvokeNode(node) {
    return node.params.length > 0 || node.hash.pairs.length > 0;
  }

  function _inheritsLoose$a(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  function _createForOfIteratorHelperLoose$4(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

  function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

  function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _defineProperties$a(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$a(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$a(Constructor.prototype, protoProps); if (staticProps) _defineProperties$a(Constructor, staticProps); return Constructor; }
  function normalize(source, options) {
    if (options === void 0) {
      options = {};
    }

    var _a;

    var ast = preprocess(source, options);
    var normalizeOptions = util.assign({
      strictMode: false,
      locals: []
    }, options);
    var top = SymbolTable.top(normalizeOptions.strictMode ? normalizeOptions.locals : [], (_a = // eslint-disable-next-line @typescript-eslint/unbound-method
    options.customizeComponentName) !== null && _a !== void 0 ? _a : function (name) {
      return name;
    });
    var block = new BlockContext(source, normalizeOptions, top);
    var normalizer = new StatementNormalizer(block);
    var astV2 = new TemplateChildren(block.loc(ast.loc), ast.body.map(function (b) {
      return normalizer.normalize(b);
    }), block).assertTemplate(top);
    var locals = top.getUsedTemplateLocals();
    return [astV2, locals];
  }
  /**
   * A `BlockContext` represents the block that a particular AST node is contained inside of.
   *
   * `BlockContext` is aware of template-wide options (such as strict mode), as well as the bindings
   * that are in-scope within that block.
   *
   * Concretely, it has the `PrecompileOptions` and current `SymbolTable`, and provides
   * facilities for working with those options.
   *
   * `BlockContext` is stateless.
   */

  var BlockContext = /*#__PURE__*/function () {
    function BlockContext(source, options, table) {
      this.source = source;
      this.options = options;
      this.table = table;
      this.builder = new Builder();
    }

    var _proto = BlockContext.prototype;

    _proto.loc = function loc(_loc) {
      return this.source.spanFor(_loc);
    };

    _proto.resolutionFor = function resolutionFor(node, resolution) {
      if (this.strict) {
        return {
          resolution: STRICT_RESOLUTION
        };
      }

      if (this.isFreeVar(node)) {
        var r = resolution(node);

        if (r === null) {
          return {
            resolution: 'error',
            path: printPath(node),
            head: printHead(node)
          };
        }

        return {
          resolution: r
        };
      } else {
        return {
          resolution: STRICT_RESOLUTION
        };
      }
    };

    _proto.isFreeVar = function isFreeVar(callee) {
      if (callee.type === 'PathExpression') {
        if (callee.head.type !== 'VarHead') {
          return false;
        }

        return !this.table.has(callee.head.name);
      } else if (callee.path.type === 'PathExpression') {
        return this.isFreeVar(callee.path);
      } else {
        return false;
      }
    };

    _proto.hasBinding = function hasBinding(name) {
      return this.table.has(name);
    };

    _proto.child = function child(blockParams) {
      return new BlockContext(this.source, this.options, this.table.child(blockParams));
    };

    _proto.customizeComponentName = function customizeComponentName(input) {
      if (this.options.customizeComponentName) {
        return this.options.customizeComponentName(input);
      } else {
        return input;
      }
    };

    _createClass$a(BlockContext, [{
      key: "strict",
      get: function get() {
        return this.options.strictMode || false;
      }
    }]);

    return BlockContext;
  }();
  /**
   * An `ExpressionNormalizer` normalizes expressions within a block.
   *
   * `ExpressionNormalizer` is stateless.
   */

  var ExpressionNormalizer = /*#__PURE__*/function () {
    function ExpressionNormalizer(block) {
      this.block = block;
    }

    var _proto2 = ExpressionNormalizer.prototype;

    _proto2.normalize = function normalize(expr, resolution) {
      switch (expr.type) {
        case 'NullLiteral':
        case 'BooleanLiteral':
        case 'NumberLiteral':
        case 'StringLiteral':
        case 'UndefinedLiteral':
          return this.block.builder.literal(expr.value, this.block.loc(expr.loc));

        case 'PathExpression':
          return this.path(expr, resolution);

        case 'SubExpression':
          {
            var _resolution = this.block.resolutionFor(expr, SexpSyntaxContext);

            if (_resolution.resolution === 'error') {
              throw generateSyntaxError("You attempted to invoke a path (`" + _resolution.path + "`) but " + _resolution.head + " was not in scope", expr.loc);
            }

            return this.block.builder.sexp(this.callParts(expr, _resolution.resolution), this.block.loc(expr.loc));
          }
      }
    };

    _proto2.path = function path(expr, resolution) {
      var headOffsets = this.block.loc(expr.head.loc);
      var tail = []; // start with the head

      var offset = headOffsets;

      for (var _iterator = _createForOfIteratorHelperLoose$4(expr.tail), _step; !(_step = _iterator()).done;) {
        var part = _step.value;
        offset = offset.sliceStartChars({
          chars: part.length,
          skipStart: 1
        });
        tail.push(new SourceSlice({
          loc: offset,
          chars: part
        }));
      }

      return this.block.builder.path(this.ref(expr.head, resolution), tail, this.block.loc(expr.loc));
    }
    /**
     * The `callParts` method takes ASTv1.CallParts as well as a syntax context and normalizes
     * it to an ASTv2 CallParts.
     */
    ;

    _proto2.callParts = function callParts(parts, context) {
      var _this = this;

      var path = parts.path,
          params = parts.params,
          hash = parts.hash;
      var callee = this.normalize(path, context);
      var paramList = params.map(function (p) {
        return _this.normalize(p, ARGUMENT_RESOLUTION);
      });
      var paramLoc = SpanList.range(paramList, callee.loc.collapse('end'));
      var namedLoc = this.block.loc(hash.loc);
      var argsLoc = SpanList.range([paramLoc, namedLoc]);
      var positional = this.block.builder.positional(params.map(function (p) {
        return _this.normalize(p, ARGUMENT_RESOLUTION);
      }), paramLoc);
      var named = this.block.builder.named(hash.pairs.map(function (p) {
        return _this.namedArgument(p);
      }), this.block.loc(hash.loc));
      return {
        callee: callee,
        args: this.block.builder.args(positional, named, argsLoc)
      };
    };

    _proto2.namedArgument = function namedArgument(pair) {
      var offsets = this.block.loc(pair.loc);
      var keyOffsets = offsets.sliceStartChars({
        chars: pair.key.length
      });
      return this.block.builder.namedArgument(new SourceSlice({
        chars: pair.key,
        loc: keyOffsets
      }), this.normalize(pair.value, ARGUMENT_RESOLUTION));
    }
    /**
     * The `ref` method normalizes an `ASTv1.PathHead` into an `ASTv2.VariableReference`.
     * This method is extremely important, because it is responsible for normalizing free
     * variables into an an ASTv2.PathHead *with appropriate context*.
     *
     * The syntax context is originally determined by the syntactic position that this `PathHead`
     * came from, and is ultimately attached to the `ASTv2.VariableReference` here. In ASTv2,
     * the `VariableReference` node bears full responsibility for loose mode rules that control
     * the behavior of free variables.
     */
    ;

    _proto2.ref = function ref(head, resolution) {
      var block = this.block;
      var builder = block.builder,
          table = block.table;
      var offsets = block.loc(head.loc);

      switch (head.type) {
        case 'ThisHead':
          return builder.self(offsets);

        case 'AtHead':
          {
            var symbol = table.allocateNamed(head.name);
            return builder.at(head.name, symbol, offsets);
          }

        case 'VarHead':
          {
            if (block.hasBinding(head.name)) {
              var _table$get = table.get(head.name),
                  _symbol = _table$get[0],
                  isRoot = _table$get[1];

              return block.builder.localVar(head.name, _symbol, isRoot, offsets);
            } else {
              var context = block.strict ? STRICT_RESOLUTION : resolution;

              var _symbol2 = block.table.allocateFree(head.name, context);

              return block.builder.freeVar({
                name: head.name,
                context: context,
                symbol: _symbol2,
                loc: offsets
              });
            }
          }
      }
    };

    return ExpressionNormalizer;
  }();
  /**
   * `TemplateNormalizer` normalizes top-level ASTv1 statements to ASTv2.
   */


  var StatementNormalizer = /*#__PURE__*/function () {
    function StatementNormalizer(block) {
      this.block = block;
    }

    var _proto3 = StatementNormalizer.prototype;

    _proto3.normalize = function normalize(node) {
      switch (node.type) {
        case 'PartialStatement':
          throw new Error("Handlebars partial syntax ({{> ...}}) is not allowed in Glimmer");

        case 'BlockStatement':
          return this.BlockStatement(node);

        case 'ElementNode':
          return new ElementNormalizer(this.block).ElementNode(node);

        case 'MustacheStatement':
          return this.MustacheStatement(node);
        // These are the same in ASTv2

        case 'MustacheCommentStatement':
          return this.MustacheCommentStatement(node);

        case 'CommentStatement':
          {
            var loc = this.block.loc(node.loc);
            return new HtmlComment({
              loc: loc,
              text: loc.slice({
                skipStart: 4,
                skipEnd: 3
              }).toSlice(node.value)
            });
          }

        case 'TextNode':
          return new HtmlText({
            loc: this.block.loc(node.loc),
            chars: node.chars
          });
      }
    };

    _proto3.MustacheCommentStatement = function MustacheCommentStatement(node) {
      var loc = this.block.loc(node.loc);
      var textLoc;

      if (loc.asString().slice(0, 5) === '{{!--') {
        textLoc = loc.slice({
          skipStart: 5,
          skipEnd: 4
        });
      } else {
        textLoc = loc.slice({
          skipStart: 3,
          skipEnd: 2
        });
      }

      return new GlimmerComment({
        loc: loc,
        text: textLoc.toSlice(node.value)
      });
    }
    /**
     * Normalizes an ASTv1.MustacheStatement to an ASTv2.AppendStatement
     */
    ;

    _proto3.MustacheStatement = function MustacheStatement(mustache) {
      var escaped = mustache.escaped;
      var loc = this.block.loc(mustache.loc); // Normalize the call parts in AppendSyntaxContext

      var callParts = this.expr.callParts({
        path: mustache.path,
        params: mustache.params,
        hash: mustache.hash
      }, AppendSyntaxContext(mustache));
      var value = callParts.args.isEmpty() ? callParts.callee : this.block.builder.sexp(callParts, loc);
      return this.block.builder.append({
        table: this.block.table,
        trusting: !escaped,
        value: value
      }, loc);
    }
    /**
     * Normalizes a ASTv1.BlockStatement to an ASTv2.BlockStatement
     */
    ;

    _proto3.BlockStatement = function BlockStatement(block) {
      var program = block.program,
          inverse = block.inverse;
      var loc = this.block.loc(block.loc);
      var resolution = this.block.resolutionFor(block, BlockSyntaxContext);

      if (resolution.resolution === 'error') {
        throw generateSyntaxError("You attempted to invoke a path (`{{#" + resolution.path + "}}`) but " + resolution.head + " was not in scope", loc);
      }

      var callParts = this.expr.callParts(block, resolution.resolution);
      return this.block.builder.blockStatement(util.assign({
        symbols: this.block.table,
        program: this.Block(program),
        inverse: inverse ? this.Block(inverse) : null
      }, callParts), loc);
    };

    _proto3.Block = function Block(_ref) {
      var body = _ref.body,
          loc = _ref.loc,
          blockParams = _ref.blockParams;
      var child = this.block.child(blockParams);
      var normalizer = new StatementNormalizer(child);
      return new BlockChildren(this.block.loc(loc), body.map(function (b) {
        return normalizer.normalize(b);
      }), this.block).assertBlock(child.table);
    };

    _createClass$a(StatementNormalizer, [{
      key: "expr",
      get: function get() {
        return new ExpressionNormalizer(this.block);
      }
    }]);

    return StatementNormalizer;
  }();

  var ElementNormalizer = /*#__PURE__*/function () {
    function ElementNormalizer(ctx) {
      this.ctx = ctx;
    }
    /**
     * Normalizes an ASTv1.ElementNode to:
     *
     * - ASTv2.NamedBlock if the tag name begins with `:`
     * - ASTv2.Component if the tag name matches the component heuristics
     * - ASTv2.SimpleElement if the tag name doesn't match the component heuristics
     *
     * A tag name represents a component if:
     *
     * - it begins with `@`
     * - it is exactly `this` or begins with `this.`
     * - the part before the first `.` is a reference to an in-scope variable binding
     * - it begins with an uppercase character
     */


    var _proto4 = ElementNormalizer.prototype;

    _proto4.ElementNode = function ElementNode(element) {
      var _this2 = this;

      var tag = element.tag,
          selfClosing = element.selfClosing,
          comments = element.comments;
      var loc = this.ctx.loc(element.loc);

      var _tag$split = tag.split('.'),
          tagHead = _tag$split[0],
          rest = _tag$split.slice(1); // the head, attributes and modifiers are in the current scope


      var path = this.classifyTag(tagHead, rest, element.loc);
      var attrs = element.attributes.filter(function (a) {
        return a.name[0] !== '@';
      }).map(function (a) {
        return _this2.attr(a);
      });
      var args = element.attributes.filter(function (a) {
        return a.name[0] === '@';
      }).map(function (a) {
        return _this2.arg(a);
      });
      var modifiers = element.modifiers.map(function (m) {
        return _this2.modifier(m);
      }); // the element's block params are in scope for the children

      var child = this.ctx.child(element.blockParams);
      var normalizer = new StatementNormalizer(child);
      var childNodes = element.children.map(function (s) {
        return normalizer.normalize(s);
      });
      var el = this.ctx.builder.element({
        selfClosing: selfClosing,
        attrs: attrs,
        componentArgs: args,
        modifiers: modifiers,
        comments: comments.map(function (c) {
          return new StatementNormalizer(_this2.ctx).MustacheCommentStatement(c);
        })
      });
      var children = new ElementChildren(el, loc, childNodes, this.ctx);
      var offsets = this.ctx.loc(element.loc);
      var tagOffsets = offsets.sliceStartChars({
        chars: tag.length,
        skipStart: 1
      });

      if (path === 'ElementHead') {
        if (tag[0] === ':') {
          return children.assertNamedBlock(tagOffsets.slice({
            skipStart: 1
          }).toSlice(tag.slice(1)), child.table);
        } else {
          return children.assertElement(tagOffsets.toSlice(tag), element.blockParams.length > 0);
        }
      }

      if (element.selfClosing) {
        return el.selfClosingComponent(path, loc);
      } else {
        var blocks = children.assertComponent(tag, child.table, element.blockParams.length > 0);
        return el.componentWithNamedBlocks(path, blocks, loc);
      }
    };

    _proto4.modifier = function modifier(m) {
      var resolution = this.ctx.resolutionFor(m, ModifierSyntaxContext);

      if (resolution.resolution === 'error') {
        throw generateSyntaxError("You attempted to invoke a path (`{{#" + resolution.path + "}}`) as a modifier, but " + resolution.head + " was not in scope. Try adding `this` to the beginning of the path", m.loc);
      }

      var callParts = this.expr.callParts(m, resolution.resolution);
      return this.ctx.builder.modifier(callParts, this.ctx.loc(m.loc));
    }
    /**
     * This method handles attribute values that are curlies, as well as curlies nested inside of
     * interpolations:
     *
     * ```hbs
     * <a href={{url}} />
     * <a href="{{url}}.html" />
     * ```
     */
    ;

    _proto4.mustacheAttr = function mustacheAttr(mustache) {
      // Normalize the call parts in AttrValueSyntaxContext
      var sexp = this.ctx.builder.sexp(this.expr.callParts(mustache, AttrValueSyntaxContext(mustache)), this.ctx.loc(mustache.loc)); // If there are no params or hash, just return the function part as its own expression

      if (sexp.args.isEmpty()) {
        return sexp.callee;
      } else {
        return sexp;
      }
    }
    /**
     * attrPart is the narrowed down list of valid attribute values that are also
     * allowed as a concat part (you can't nest concats).
     */
    ;

    _proto4.attrPart = function attrPart(part) {
      switch (part.type) {
        case 'MustacheStatement':
          return {
            expr: this.mustacheAttr(part),
            trusting: !part.escaped
          };

        case 'TextNode':
          return {
            expr: this.ctx.builder.literal(part.chars, this.ctx.loc(part.loc)),
            trusting: true
          };
      }
    };

    _proto4.attrValue = function attrValue(part) {
      var _this3 = this;

      switch (part.type) {
        case 'ConcatStatement':
          {
            var parts = part.parts.map(function (p) {
              return _this3.attrPart(p).expr;
            });
            return {
              expr: this.ctx.builder.interpolate(parts, this.ctx.loc(part.loc)),
              trusting: false
            };
          }

        default:
          return this.attrPart(part);
      }
    };

    _proto4.attr = function attr(m) {

      if (m.name === '...attributes') {
        return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock('attrs'), this.ctx.loc(m.loc));
      }

      var offsets = this.ctx.loc(m.loc);
      var nameSlice = offsets.sliceStartChars({
        chars: m.name.length
      }).toSlice(m.name);
      var value = this.attrValue(m.value);
      return this.ctx.builder.attr({
        name: nameSlice,
        value: value.expr,
        trusting: value.trusting
      }, offsets);
    };

    _proto4.maybeDeprecatedCall = function maybeDeprecatedCall(arg, part) {
      if (this.ctx.strict) {
        return null;
      }

      if (part.type !== 'MustacheStatement') {
        return null;
      }

      var path = part.path;

      if (path.type !== 'PathExpression') {
        return null;
      }

      if (path.head.type !== 'VarHead') {
        return null;
      }

      var name = path.head.name;

      if (name === 'has-block' || name === 'has-block-params') {
        return null;
      }

      if (this.ctx.hasBinding(name)) {
        return null;
      }

      if (path.tail.length !== 0) {
        return null;
      }

      if (part.params.length !== 0 || part.hash.pairs.length !== 0) {
        return null;
      }

      var context = LooseModeResolution.attr();
      var callee = this.ctx.builder.freeVar({
        name: name,
        context: context,
        symbol: this.ctx.table.allocateFree(name, context),
        loc: path.loc
      });
      return {
        expr: this.ctx.builder.deprecatedCall(arg, callee, part.loc),
        trusting: false
      };
    };

    _proto4.arg = function arg(_arg) {
      var offsets = this.ctx.loc(_arg.loc);
      var nameSlice = offsets.sliceStartChars({
        chars: _arg.name.length
      }).toSlice(_arg.name);
      var value = this.maybeDeprecatedCall(nameSlice, _arg.value) || this.attrValue(_arg.value);
      return this.ctx.builder.arg({
        name: nameSlice,
        value: value.expr,
        trusting: value.trusting
      }, offsets);
    }
    /**
     * This function classifies the head of an ASTv1.Element into an ASTv2.PathHead (if the
     * element is a component) or `'ElementHead'` (if the element is a simple element).
     *
     * Rules:
     *
     * 1. If the variable is an `@arg`, return an `AtHead`
     * 2. If the variable is `this`, return a `ThisHead`
     * 3. If the variable is in the current scope:
     *   a. If the scope is the root scope, then return a Free `LocalVarHead`
     *   b. Else, return a standard `LocalVarHead`
     * 4. If the tag name is a path and the variable is not in the current scope, Syntax Error
     * 5. If the variable is uppercase return a FreeVar(ResolveAsComponentHead)
     * 6. Otherwise, return `'ElementHead'`
     */
    ;

    _proto4.classifyTag = function classifyTag(variable, tail, loc) {
      var uppercase = isUpperCase(variable);
      var inScope = variable[0] === '@' || variable === 'this' || this.ctx.hasBinding(variable);

      if (this.ctx.strict && !inScope) {
        if (uppercase) {
          throw generateSyntaxError("Attempted to invoke a component that was not in scope in a strict mode template, `<" + variable + ">`. If you wanted to create an element with that name, convert it to lowercase - `<" + variable.toLowerCase() + ">`", loc);
        } // In strict mode, values are always elements unless they are in scope


        return 'ElementHead';
      } // Since the parser handed us the HTML element name as a string, we need
      // to convert it into an ASTv1 path so it can be processed using the
      // expression normalizer.


      var isComponent = inScope || uppercase;
      var variableLoc = loc.sliceStartChars({
        skipStart: 1,
        chars: variable.length
      });
      var tailLength = tail.reduce(function (accum, part) {
        return accum + 1 + part.length;
      }, 0);
      var pathEnd = variableLoc.getEnd().move(tailLength);
      var pathLoc = variableLoc.withEnd(pathEnd);

      if (isComponent) {
        var path = b.path({
          head: b.head(variable, variableLoc),
          tail: tail,
          loc: pathLoc
        });
        var resolution = this.ctx.resolutionFor(path, ComponentSyntaxContext);

        if (resolution.resolution === 'error') {
          throw generateSyntaxError("You attempted to invoke a path (`<" + resolution.path + ">`) but " + resolution.head + " was not in scope", loc);
        }

        return new ExpressionNormalizer(this.ctx).normalize(path, resolution.resolution);
      } // If the tag name wasn't a valid component but contained a `.`, it's
      // a syntax error.


      if (tail.length > 0) {
        throw generateSyntaxError("You used " + variable + "." + tail.join('.') + " as a tag name, but " + variable + " is not in scope", loc);
      }

      return 'ElementHead';
    };

    _createClass$a(ElementNormalizer, [{
      key: "expr",
      get: function get() {
        return new ExpressionNormalizer(this.ctx);
      }
    }]);

    return ElementNormalizer;
  }();

  var Children = function Children(loc, children, block) {
    this.loc = loc;
    this.children = children;
    this.block = block;
    this.namedBlocks = children.filter(function (c) {
      return c instanceof NamedBlock;
    });
    this.hasSemanticContent = Boolean(children.filter(function (c) {
      if (c instanceof NamedBlock) {
        return false;
      }

      switch (c.type) {
        case 'GlimmerComment':
        case 'HtmlComment':
          return false;

        case 'HtmlText':
          return !/^\s*$/.exec(c.chars);

        default:
          return true;
      }
    }).length);
    this.nonBlockChildren = children.filter(function (c) {
      return !(c instanceof NamedBlock);
    });
  };

  var TemplateChildren = /*#__PURE__*/function (_Children) {
    _inheritsLoose$a(TemplateChildren, _Children);

    function TemplateChildren() {
      return _Children.apply(this, arguments) || this;
    }

    var _proto5 = TemplateChildren.prototype;

    _proto5.assertTemplate = function assertTemplate(table) {
      if (util.isPresent(this.namedBlocks)) {
        throw generateSyntaxError("Unexpected named block at the top-level of a template", this.loc);
      }

      return this.block.builder.template(table, this.nonBlockChildren, this.block.loc(this.loc));
    };

    return TemplateChildren;
  }(Children);

  var BlockChildren = /*#__PURE__*/function (_Children2) {
    _inheritsLoose$a(BlockChildren, _Children2);

    function BlockChildren() {
      return _Children2.apply(this, arguments) || this;
    }

    var _proto6 = BlockChildren.prototype;

    _proto6.assertBlock = function assertBlock(table) {
      if (util.isPresent(this.namedBlocks)) {
        throw generateSyntaxError("Unexpected named block nested in a normal block", this.loc);
      }

      return this.block.builder.block(table, this.nonBlockChildren, this.loc);
    };

    return BlockChildren;
  }(Children);

  var ElementChildren = /*#__PURE__*/function (_Children3) {
    _inheritsLoose$a(ElementChildren, _Children3);

    function ElementChildren(el, loc, children, block) {
      var _this4;

      _this4 = _Children3.call(this, loc, children, block) || this;
      _this4.el = el;
      return _this4;
    }

    var _proto7 = ElementChildren.prototype;

    _proto7.assertNamedBlock = function assertNamedBlock(name, table) {
      if (this.el.base.selfClosing) {
        throw generateSyntaxError("<:" + name.chars + "/> is not a valid named block: named blocks cannot be self-closing", this.loc);
      }

      if (util.isPresent(this.namedBlocks)) {
        throw generateSyntaxError("Unexpected named block inside <:" + name.chars + "> named block: named blocks cannot contain nested named blocks", this.loc);
      }

      if (!isLowerCase(name.chars)) {
        throw generateSyntaxError("<:" + name.chars + "> is not a valid named block, and named blocks must begin with a lowercase letter", this.loc);
      }

      if (this.el.base.attrs.length > 0 || this.el.base.componentArgs.length > 0 || this.el.base.modifiers.length > 0) {
        throw generateSyntaxError("named block <:" + name.chars + "> cannot have attributes, arguments, or modifiers", this.loc);
      }

      var offsets = SpanList.range(this.nonBlockChildren, this.loc);
      return this.block.builder.namedBlock(name, this.block.builder.block(table, this.nonBlockChildren, offsets), this.loc);
    };

    _proto7.assertElement = function assertElement(name, hasBlockParams) {
      if (hasBlockParams) {
        throw generateSyntaxError("Unexpected block params in <" + name + ">: simple elements cannot have block params", this.loc);
      }

      if (util.isPresent(this.namedBlocks)) {
        var names = this.namedBlocks.map(function (b) {
          return b.name;
        });

        if (names.length === 1) {
          throw generateSyntaxError("Unexpected named block <:foo> inside <" + name.chars + "> HTML element", this.loc);
        } else {
          var printedNames = names.map(function (n) {
            return "<:" + n.chars + ">";
          }).join(', ');
          throw generateSyntaxError("Unexpected named blocks inside <" + name.chars + "> HTML element (" + printedNames + ")", this.loc);
        }
      }

      return this.el.simple(name, this.nonBlockChildren, this.loc);
    };

    _proto7.assertComponent = function assertComponent(name, table, hasBlockParams) {
      if (util.isPresent(this.namedBlocks) && this.hasSemanticContent) {
        throw generateSyntaxError("Unexpected content inside <" + name + "> component invocation: when using named blocks, the tag cannot contain other content", this.loc);
      }

      if (util.isPresent(this.namedBlocks)) {
        if (hasBlockParams) {
          throw generateSyntaxError("Unexpected block params list on <" + name + "> component invocation: when passing named blocks, the invocation tag cannot take block params", this.loc);
        }

        var seenNames = new Set();

        for (var _iterator2 = _createForOfIteratorHelperLoose$4(this.namedBlocks), _step2; !(_step2 = _iterator2()).done;) {
          var block = _step2.value;
          var _name = block.name.chars;

          if (seenNames.has(_name)) {
            throw generateSyntaxError("Component had two named blocks with the same name, `<:" + _name + ">`. Only one block with a given name may be passed", this.loc);
          }

          if (_name === 'inverse' && seenNames.has('else') || _name === 'else' && seenNames.has('inverse')) {
            throw generateSyntaxError("Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>", this.loc);
          }

          seenNames.add(_name);
        }

        return this.namedBlocks;
      } else {
        return [this.block.builder.namedBlock(SourceSlice.synthetic('default'), this.block.builder.block(table, this.nonBlockChildren, this.loc), this.loc)];
      }
    };

    return ElementChildren;
  }(Children);

  function printPath(node) {
    if (node.type !== 'PathExpression' && node.path.type === 'PathExpression') {
      return printPath(node.path);
    } else {
      return new Printer({
        entityEncoding: 'raw'
      }).print(node);
    }
  }

  function printHead(node) {
    if (node.type === 'PathExpression') {
      switch (node.head.type) {
        case 'AtHead':
        case 'VarHead':
          return node.head.name;

        case 'ThisHead':
          return 'this';
      }
    } else if (node.path.type === 'PathExpression') {
      return printHead(node.path);
    } else {
      return new Printer({
        entityEncoding: 'raw'
      }).print(node);
    }
  }

  function isKeyword(word) {
    return word in KEYWORDS_TYPES;
  }
  /**
   * This includes the full list of keywords currently in use in the template
   * language, and where their valid usages are.
   */

  var KEYWORDS_TYPES = {
    component: ['Call', 'Append', 'Block'],
    "debugger": ['Append'],
    'each-in': ['Block'],
    each: ['Block'],
    'has-block-params': ['Call', 'Append'],
    'has-block': ['Call', 'Append'],
    helper: ['Call', 'Append'],
    "if": ['Call', 'Append', 'Block'],
    'in-element': ['Block'],
    "let": ['Block'],
    'link-to': ['Append', 'Block'],
    log: ['Call', 'Append'],
    modifier: ['Call'],
    mount: ['Append'],
    mut: ['Call', 'Append'],
    outlet: ['Append'],
    'query-params': ['Call'],
    readonly: ['Call', 'Append'],
    unbound: ['Call', 'Append'],
    unless: ['Call', 'Append', 'Block'],
    "with": ['Block'],
    "yield": ['Append']
  };

  /**
   * Gets the correct Token from the Node based on it's type
   */

  function tokensFromType(node, scopedTokens, options) {
    if (node.type === 'PathExpression') {
      if (node.head.type === 'AtHead' || node.head.type === 'ThisHead') {
        return;
      }

      var possbleToken = node.head.name;

      if (scopedTokens.indexOf(possbleToken) === -1) {
        return possbleToken;
      }
    } else if (node.type === 'ElementNode') {
      var tag = node.tag;

      var _char = tag.charAt(0);

      if (_char === ':' || _char === '@') {
        return;
      }

      if (!options.includeHtmlElements && tag.indexOf('.') === -1 && tag.toLowerCase() === tag) {
        return;
      }

      if (tag.substr(0, 5) === 'this.') {
        return;
      }

      if (scopedTokens.indexOf(tag) !== -1) {
        return;
      }

      return tag;
    }
  }
  /**
   * Adds tokens to the tokensSet based on their node.type
   */


  function addTokens(tokensSet, node, scopedTokens, options) {
    var maybeTokens = tokensFromType(node, scopedTokens, options);
    (Array.isArray(maybeTokens) ? maybeTokens : [maybeTokens]).forEach(function (maybeToken) {
      if (maybeToken !== undefined && maybeToken[0] !== '@') {
        tokensSet.add(maybeToken.split('.')[0]);
      }
    });
  }
  /**
   * Parses and traverses a given handlebars html template to extract all template locals
   * referenced that could possible come from the praent scope. Can exclude known keywords
   * optionally.
   */


  function getTemplateLocals(html, options) {
    if (options === void 0) {
      options = {
        includeHtmlElements: false,
        includeKeywords: false
      };
    }

    var ast = preprocess(html);
    var tokensSet = new Set();
    var scopedTokens = [];
    traverse(ast, {
      Block: {
        enter: function enter(_ref) {
          var blockParams = _ref.blockParams;
          blockParams.forEach(function (param) {
            scopedTokens.push(param);
          });
        },
        exit: function exit(_ref2) {
          var blockParams = _ref2.blockParams;
          blockParams.forEach(function () {
            scopedTokens.pop();
          });
        }
      },
      ElementNode: {
        enter: function enter(node) {
          node.blockParams.forEach(function (param) {
            scopedTokens.push(param);
          });
          addTokens(tokensSet, node, scopedTokens, options);
        },
        exit: function exit(_ref3) {
          var blockParams = _ref3.blockParams;
          blockParams.forEach(function () {
            scopedTokens.pop();
          });
        }
      },
      PathExpression: function PathExpression(node) {
        addTokens(tokensSet, node, scopedTokens, options);
      }
    });
    var tokens = [];
    tokensSet.forEach(function (s) {
      return tokens.push(s);
    });

    if (!(options === null || options === void 0 ? void 0 : options.includeKeywords)) {
      tokens = tokens.filter(function (token) {
        return !isKeyword(token);
      });
    }

    return tokens;
  }

  exports.AST = api;
  exports.ASTv1 = api;
  exports.ASTv2 = api$1;
  exports.BlockSymbolTable = BlockSymbolTable;
  exports.KEYWORDS_TYPES = KEYWORDS_TYPES;
  exports.Path = Walker;
  exports.ProgramSymbolTable = ProgramSymbolTable;
  exports.Source = Source;
  exports.SourceSlice = SourceSlice;
  exports.SourceSpan = SourceSpan;
  exports.SpanList = SpanList;
  exports.SymbolTable = SymbolTable;
  exports.Walker = Walker;
  exports.WalkerPath = WalkerPath;
  exports.builders = publicBuilder;
  exports.cannotRemoveNode = cannotRemoveNode;
  exports.cannotReplaceNode = cannotReplaceNode;
  exports.generateSyntaxError = generateSyntaxError;
  exports.getTemplateLocals = getTemplateLocals;
  exports.hasSpan = hasSpan;
  exports.isKeyword = isKeyword;
  exports.loc = loc;
  exports.maybeLoc = maybeLoc;
  exports.node = node;
  exports.normalize = normalize;
  exports.preprocess = preprocess;
  exports.print = build;
  exports.sortByLoc = sortByLoc;
  exports.traverse = traverse;

  Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci1zeW50YXguanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvc291cmNlL2xvY2F0aW9uLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9zb3VyY2Uvc2xpY2UudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3NvdXJjZS9sb2MvbWF0Y2gudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3NvdXJjZS9sb2Mvb2Zmc2V0LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9zb3VyY2UvbG9jL3NwYW4udHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3NvdXJjZS9zb3VyY2UudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3YxL2xlZ2FjeS1pbnRlcm9wLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi92MS9wdWJsaWMtYnVpbGRlcnMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3YyLWEvb2JqZWN0cy9yZXNvbHV0aW9uLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi92Mi1hL29iamVjdHMvbm9kZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdjItYS9vYmplY3RzL2FyZ3MudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3YyLWEvb2JqZWN0cy9hdHRyLWJsb2NrLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9zb3VyY2Uvc3Bhbi1saXN0LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi92Mi1hL29iamVjdHMvY29udGVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdjItYS9vYmplY3RzL2V4cHIudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3YyLWEvb2JqZWN0cy9yZWZzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi92Mi1hL29iamVjdHMvaW50ZXJuYWwtbm9kZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvZ2VuZXJhdGlvbi91dGlsLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9nZW5lcmF0aW9uL3ByaW50ZXIudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL2dlbmVyYXRpb24vcHJpbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3N5bnRheC1lcnJvci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdjEvdmlzaXRvci1rZXlzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi90cmF2ZXJzYWwvZXJyb3JzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi90cmF2ZXJzYWwvc2NvcGUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3RyYXZlcnNhbC9wYXRoLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi90cmF2ZXJzYWwvdHJhdmVyc2UudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3RyYXZlcnNhbC93YWxrZXIudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3V0aWxzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi92MS9wYXJzZXItYnVpbGRlcnMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3BhcnNlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvcGFyc2VyL2hhbmRsZWJhcnMtbm9kZS12aXNpdG9ycy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvcGFyc2VyL3Rva2VuaXplci1ldmVudC1oYW5kbGVycy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvc3ltYm9sLXRhYmxlLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi92Mi1hL2J1aWxkZXJzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi92Mi1hL2xvb3NlLXJlc29sdXRpb24udHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3YyLWEvbm9ybWFsaXplLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9rZXl3b3Jkcy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvZ2V0LXRlbXBsYXRlLWxvY2Fscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcmVzZW50QXJyYXkgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGlzUHJlc2VudCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5pbXBvcnQgeyBTb3VyY2VTcGFuIH0gZnJvbSAnLi9zcGFuJztcblxuZXhwb3J0IGludGVyZmFjZSBTb3VyY2VMb2NhdGlvbiB7XG4gIHN0YXJ0OiBTb3VyY2VQb3NpdGlvbjtcbiAgZW5kOiBTb3VyY2VQb3NpdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb3VyY2VQb3NpdGlvbiB7XG4gIC8qKiA+PSAxICovXG4gIGxpbmU6IG51bWJlcjtcbiAgLyoqID49IDAgKi9cbiAgY29sdW1uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBVTktOT1dOX1BPU0lUSU9OID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGxpbmU6IDEsXG4gIGNvbHVtbjogMCxcbn0gYXMgY29uc3QpO1xuXG5leHBvcnQgY29uc3QgU1lOVEhFVElDX0xPQ0FUSU9OID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHNvdXJjZTogJyhzeW50aGV0aWMpJyxcbiAgc3RhcnQ6IFVOS05PV05fUE9TSVRJT04sXG4gIGVuZDogVU5LTk9XTl9QT1NJVElPTixcbn0gYXMgY29uc3QpO1xuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBjb25zdCBTWU5USEVUSUMgPSBTWU5USEVUSUNfTE9DQVRJT047XG5cbmV4cG9ydCBjb25zdCBURU1QT1JBUllfTE9DQVRJT04gPSBPYmplY3QuZnJlZXplKHtcbiAgc291cmNlOiAnKHRlbXBvcmFyeSknLFxuICBzdGFydDogVU5LTk9XTl9QT1NJVElPTixcbiAgZW5kOiBVTktOT1dOX1BPU0lUSU9OLFxufSBhcyBjb25zdCk7XG5cbmV4cG9ydCBjb25zdCBOT05fRVhJU1RFTlRfTE9DQVRJT04gPSBPYmplY3QuZnJlZXplKHtcbiAgc291cmNlOiAnKG5vbmV4aXN0ZW50KScsXG4gIHN0YXJ0OiBVTktOT1dOX1BPU0lUSU9OLFxuICBlbmQ6IFVOS05PV05fUE9TSVRJT04sXG59IGFzIGNvbnN0KTtcblxuZXhwb3J0IGNvbnN0IEJST0tFTl9MT0NBVElPTiA9IE9iamVjdC5mcmVlemUoe1xuICBzb3VyY2U6ICcoYnJva2VuKScsXG4gIHN0YXJ0OiBVTktOT1dOX1BPU0lUSU9OLFxuICBlbmQ6IFVOS05PV05fUE9TSVRJT04sXG59IGFzIGNvbnN0KTtcblxuZXhwb3J0IHR5cGUgTG9jYXRlZFdpdGhTcGFuID0geyBvZmZzZXRzOiBTb3VyY2VTcGFuIH07XG5leHBvcnQgdHlwZSBMb2NhdGVkV2l0aE9wdGlvbmFsU3BhbiA9IHsgb2Zmc2V0czogU291cmNlU3BhbiB8IG51bGwgfTtcblxuZXhwb3J0IHR5cGUgTG9jYXRlZFdpdGhQb3NpdGlvbnMgPSB7IGxvYzogU291cmNlTG9jYXRpb24gfTtcbmV4cG9ydCB0eXBlIExvY2F0ZWRXaXRoT3B0aW9uYWxQb3NpdGlvbnMgPSB7IGxvYz86IFNvdXJjZUxvY2F0aW9uIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2F0ZWRXaXRoUG9zaXRpb25zQXJyYXkoXG4gIGxvY2F0aW9uOiBMb2NhdGVkV2l0aE9wdGlvbmFsUG9zaXRpb25zW11cbik6IGxvY2F0aW9uIGlzIFByZXNlbnRBcnJheTxMb2NhdGVkV2l0aFBvc2l0aW9ucz4ge1xuICByZXR1cm4gaXNQcmVzZW50KGxvY2F0aW9uKSAmJiBsb2NhdGlvbi5ldmVyeShpc0xvY2F0ZWRXaXRoUG9zaXRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTG9jYXRlZFdpdGhQb3NpdGlvbnMoXG4gIGxvY2F0aW9uOiBMb2NhdGVkV2l0aE9wdGlvbmFsUG9zaXRpb25zXG4pOiBsb2NhdGlvbiBpcyBMb2NhdGVkV2l0aFBvc2l0aW9ucyB7XG4gIHJldHVybiBsb2NhdGlvbi5sb2MgIT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IHR5cGUgSGFzU291cmNlTG9jYXRpb24gPVxuICB8IFNvdXJjZUxvY2F0aW9uXG4gIHwgTG9jYXRlZFdpdGhQb3NpdGlvbnNcbiAgfCBQcmVzZW50QXJyYXk8TG9jYXRlZFdpdGhQb3NpdGlvbnM+O1xuXG5leHBvcnQgdHlwZSBNYXliZUhhc1NvdXJjZUxvY2F0aW9uID1cbiAgfCBudWxsXG4gIHwgTG9jYXRlZFdpdGhPcHRpb25hbFBvc2l0aW9uc1xuICB8IExvY2F0ZWRXaXRoT3B0aW9uYWxQb3NpdGlvbnNbXTtcbiIsImltcG9ydCB7IFNvdXJjZSB9IGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgU2VyaWFsaXplZFNvdXJjZVNwYW4sIFNvdXJjZVNwYW4gfSBmcm9tICcuL3NwYW4nO1xuXG5leHBvcnQgdHlwZSBTZXJpYWxpemVkU291cmNlU2xpY2U8Q2hhcnMgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+ID0gW1xuICBjaGFyczogQ2hhcnMsXG4gIHNwYW46IFNlcmlhbGl6ZWRTb3VyY2VTcGFuXG5dO1xuXG5leHBvcnQgY2xhc3MgU291cmNlU2xpY2U8Q2hhcnMgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgc3RhdGljIHN5bnRoZXRpYzxTIGV4dGVuZHMgc3RyaW5nPihjaGFyczogUyk6IFNvdXJjZVNsaWNlPFM+IHtcbiAgICBsZXQgb2Zmc2V0cyA9IFNvdXJjZVNwYW4uc3ludGhldGljKGNoYXJzKTtcbiAgICByZXR1cm4gbmV3IFNvdXJjZVNsaWNlKHsgbG9jOiBvZmZzZXRzLCBjaGFyczogY2hhcnMgfSk7XG4gIH1cblxuICBzdGF0aWMgbG9hZChzb3VyY2U6IFNvdXJjZSwgc2xpY2U6IFNlcmlhbGl6ZWRTb3VyY2VTbGljZSk6IFNvdXJjZVNsaWNlIHtcbiAgICByZXR1cm4gbmV3IFNvdXJjZVNsaWNlKHtcbiAgICAgIGxvYzogU291cmNlU3Bhbi5sb2FkKHNvdXJjZSwgc2xpY2VbMV0pLFxuICAgICAgY2hhcnM6IHNsaWNlWzBdLFxuICAgIH0pO1xuICB9XG5cbiAgcmVhZG9ubHkgY2hhcnM6IENoYXJzO1xuICByZWFkb25seSBsb2M6IFNvdXJjZVNwYW47XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogeyBsb2M6IFNvdXJjZVNwYW47IGNoYXJzOiBDaGFycyB9KSB7XG4gICAgdGhpcy5sb2MgPSBvcHRpb25zLmxvYztcbiAgICB0aGlzLmNoYXJzID0gb3B0aW9ucy5jaGFycztcbiAgfVxuXG4gIGdldFN0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNoYXJzO1xuICB9XG5cbiAgc2VyaWFsaXplKCk6IFNlcmlhbGl6ZWRTb3VyY2VTbGljZTxDaGFycz4ge1xuICAgIHJldHVybiBbdGhpcy5jaGFycywgdGhpcy5sb2Muc2VyaWFsaXplKCldO1xuICB9XG59XG4iLCJpbXBvcnQgeyBhc3NlcnQsIGlzUHJlc2VudCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5pbXBvcnQgeyBDaGFyUG9zaXRpb24sIEhic1Bvc2l0aW9uLCBJbnZpc2libGVQb3NpdGlvbiwgT2Zmc2V0S2luZCwgUG9zaXRpb25EYXRhIH0gZnJvbSAnLi9vZmZzZXQnO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBpbXBsZW1lbnRzIHRoZSBEU0wgdXNlZCBieSBzcGFuIGFuZCBvZmZzZXQgaW4gcGxhY2VzIHdoZXJlIHRoZXkgbmVlZCB0byBleGhhdXN0aXZlbHlcbiAqIGNvbnNpZGVyIGFsbCBjb21iaW5hdGlvbnMgb2Ygc3RhdGVzIChIYW5kbGViYXJzIG9mZnNldHMsIGNoYXJhY3RlciBvZmZzZXRzIGFuZCBpbnZpc2libGUvYnJva2VuXG4gKiBvZmZzZXRzKS5cbiAqXG4gKiBJdCdzIHByb2JhYmx5IG92ZXJraWxsLCBidXQgaXQgbWFrZXMgdGhlIGNvZGUgdGhhdCB1c2VzIGl0IGNsZWFyLiBJdCBjb3VsZCBiZSByZWZhY3RvcmVkIG9yXG4gKiByZW1vdmVkLlxuICovXG5cbmV4cG9ydCBjb25zdCBNYXRjaEFueSA9ICdNQVRDSF9BTlknO1xuZXhwb3J0IHR5cGUgTWF0Y2hBbnkgPSAnTUFUQ0hfQU5ZJztcblxudHlwZSBNYXRjaGVzID1cbiAgfCAnQ2hhcixIYnMnXG4gIHwgJ0hicyxDaGFyJ1xuICB8ICdIYnMsSGJzJ1xuICB8ICdDaGFyLENoYXInXG4gIHwgJ0ludmlzaWJsZSxBbnknXG4gIHwgJ0FueSxJbnZpc2libGUnO1xuXG5leHBvcnQgY29uc3QgSXNJbnZpc2libGUgPSAnSVNfSU5WSVNJQkxFJztcbmV4cG9ydCB0eXBlIElzSW52aXNpYmxlID0gJ0lTX0lOVklTSUJMRSc7XG5cbnR5cGUgUGF0dGVybiA9IE9mZnNldEtpbmQgfCBJc0ludmlzaWJsZSB8IE1hdGNoQW55O1xuXG5jbGFzcyBXaGVuTGlzdDxPdXQ+IHtcbiAgI3doZW5zOiBXaGVuPE91dD5bXTtcblxuICBjb25zdHJ1Y3Rvcih3aGVuczogV2hlbjxPdXQ+W10pIHtcbiAgICB0aGlzLiN3aGVucyA9IHdoZW5zO1xuICB9XG5cbiAgZmlyc3Qoa2luZDogT2Zmc2V0S2luZCk6IE91dCB8IG51bGwge1xuICAgIGZvciAobGV0IHdoZW4gb2YgdGhpcy4jd2hlbnMpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHdoZW4ubWF0Y2goa2luZCk7XG4gICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVbMF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuY2xhc3MgV2hlbjxPdXQ+IHtcbiAgI21hcDogTWFwPFBhdHRlcm4sIE91dD4gPSBuZXcgTWFwKCk7XG5cbiAgZ2V0KHBhdHRlcm46IFBhdHRlcm4sIG9yOiAoKSA9PiBPdXQpOiBPdXQge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuI21hcC5nZXQocGF0dGVybik7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IG9yKCk7XG5cbiAgICB0aGlzLiNtYXAuc2V0KHBhdHRlcm4sIHZhbHVlKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGFkZChwYXR0ZXJuOiBQYXR0ZXJuLCBvdXQ6IE91dCk6IHZvaWQge1xuICAgIHRoaXMuI21hcC5zZXQocGF0dGVybiwgb3V0KTtcbiAgfVxuXG4gIG1hdGNoKGtpbmQ6IE9mZnNldEtpbmQpOiBPdXRbXSB7XG4gICAgbGV0IHBhdHRlcm4gPSBwYXR0ZXJuRm9yKGtpbmQpO1xuXG4gICAgbGV0IG91dDogT3V0W10gPSBbXTtcblxuICAgIGxldCBleGFjdCA9IHRoaXMuI21hcC5nZXQocGF0dGVybik7XG4gICAgbGV0IGZhbGxiYWNrID0gdGhpcy4jbWFwLmdldChNYXRjaEFueSk7XG5cbiAgICBpZiAoZXhhY3QpIHtcbiAgICAgIG91dC5wdXNoKGV4YWN0KTtcbiAgICB9XG5cbiAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgIG91dC5wdXNoKGZhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG59XG5cbnR5cGUgRXhoYXVzdGl2ZUNoZWNrPE91dCwgSW4gZXh0ZW5kcyBNYXRjaGVzLCBSZW1vdmVkIGV4dGVuZHMgTWF0Y2hlcz4gPSBFeGNsdWRlPFxuICBJbixcbiAgUmVtb3ZlZFxuPiBleHRlbmRzIG5ldmVyXG4gID8gRXhoYXVzdGl2ZU1hdGNoZXI8T3V0PlxuICA6IE1hdGNoZXI8T3V0LCBFeGNsdWRlPEluLCBSZW1vdmVkPj47XG5cbmV4cG9ydCB0eXBlIE1hdGNoRm48T3V0PiA9IChsZWZ0OiBQb3NpdGlvbkRhdGEsIHJpZ2h0OiBQb3NpdGlvbkRhdGEpID0+IE91dDtcblxuaW50ZXJmYWNlIEV4aGF1c3RpdmVNYXRjaGVyPE91dD4ge1xuICBjaGVjaygpOiBNYXRjaEZuPE91dD47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaDxPdXQ+KGNhbGxiYWNrOiAobTogTWF0Y2hlcjxPdXQ+KSA9PiBFeGhhdXN0aXZlTWF0Y2hlcjxPdXQ+KTogTWF0Y2hGbjxPdXQ+IHtcbiAgcmV0dXJuIGNhbGxiYWNrKG5ldyBNYXRjaGVyKCkpLmNoZWNrKCk7XG59XG5cbmNsYXNzIE1hdGNoZXI8T3V0LCBNIGV4dGVuZHMgTWF0Y2hlcyA9IE1hdGNoZXM+IHtcbiAgI3doZW5zOiBXaGVuPFdoZW48KGxlZnQ6IFBvc2l0aW9uRGF0YSwgcmlnaHQ6IFBvc2l0aW9uRGF0YSkgPT4gT3V0Pj4gPSBuZXcgV2hlbigpO1xuXG4gIC8qKlxuICAgKiBZb3UgZGlkbid0IGV4aGF1c3RpdmVseSBtYXRjaCBhbGwgcG9zc2liaWxpdGllcy5cbiAgICovXG4gIHByb3RlY3RlZCBjaGVjaygpOiBNYXRjaEZuPE91dD4ge1xuICAgIHJldHVybiAobGVmdCwgcmlnaHQpID0+IHRoaXMubWF0Y2hGb3IobGVmdC5raW5kLCByaWdodC5raW5kKShsZWZ0LCByaWdodCk7XG4gIH1cblxuICBwcml2YXRlIG1hdGNoRm9yKFxuICAgIGxlZnQ6IE9mZnNldEtpbmQsXG4gICAgcmlnaHQ6IE9mZnNldEtpbmRcbiAgKTogKGxlZnQ6IFBvc2l0aW9uRGF0YSwgcmlnaHQ6IFBvc2l0aW9uRGF0YSkgPT4gT3V0IHtcbiAgICBsZXQgbmVzdGVkcyA9IHRoaXMuI3doZW5zLm1hdGNoKGxlZnQpO1xuXG4gICAgYXNzZXJ0KFxuICAgICAgaXNQcmVzZW50KG5lc3RlZHMpLFxuICAgICAgYG5vIG1hdGNoIGRlZmluZWQgZm9yICgke2xlZnR9LCAke3JpZ2h0fSkgYW5kIG5vIEFueU1hdGNoIGRlZmluZWQgZWl0aGVyYFxuICAgICk7XG5cbiAgICBsZXQgY2FsbGJhY2sgPSBuZXcgV2hlbkxpc3QobmVzdGVkcykuZmlyc3QocmlnaHQpO1xuXG4gICAgYXNzZXJ0KFxuICAgICAgY2FsbGJhY2sgIT09IG51bGwsXG4gICAgICBgbm8gbWF0Y2ggZGVmaW5lZCBmb3IgKCR7bGVmdH0sICR7cmlnaHR9KSBhbmQgbm8gQW55TWF0Y2ggZGVmaW5lZCBlaXRoZXJgXG4gICAgKTtcblxuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfVxuXG4gIC8vIFRoaXMgYmlnIGJsb2NrIGlzIHRoZSBidWxrIG9mIHRoZSBoZWF2eSBsaWZ0aW5nIGluIHRoaXMgZmlsZS4gSXQgZmFjaWxpdGF0ZXMgZXhoYXVzdGl2ZW5lc3NcbiAgLy8gY2hlY2tpbmcgc28gdGhhdCBtYXRjaGVycyBjYW4gZW5zdXJlIHRoZXkndmUgYWN0dWFsbHkgY292ZXJlZCBhbGwgdGhlIGNhc2VzIChhbmQgVHlwZVNjcmlwdFxuICAvLyB3aWxsIHRyZWF0IGl0IGFzIGFuIGV4aGF1c3RpdmUgbWF0Y2gpLlxuICB3aGVuKFxuICAgIGxlZnQ6IE9mZnNldEtpbmQuQ2hhclBvc2l0aW9uLFxuICAgIHJpZ2h0OiBPZmZzZXRLaW5kLkhic1Bvc2l0aW9uLFxuICAgIGNhbGxiYWNrOiAobGVmdDogQ2hhclBvc2l0aW9uLCByaWdodDogSGJzUG9zaXRpb24pID0+IE91dFxuICApOiBFeGhhdXN0aXZlQ2hlY2s8T3V0LCBNLCAnQ2hhcixIYnMnPjtcbiAgd2hlbihcbiAgICBsZWZ0OiBPZmZzZXRLaW5kLkhic1Bvc2l0aW9uLFxuICAgIHJpZ2h0OiBPZmZzZXRLaW5kLkNoYXJQb3NpdGlvbixcbiAgICBjYWxsYmFjazogKGxlZnQ6IEhic1Bvc2l0aW9uLCByaWdodDogQ2hhclBvc2l0aW9uKSA9PiBPdXRcbiAgKTogRXhoYXVzdGl2ZUNoZWNrPE91dCwgTSwgJ0hicyxDaGFyJz47XG4gIHdoZW4oXG4gICAgbGVmdDogT2Zmc2V0S2luZC5IYnNQb3NpdGlvbixcbiAgICByaWdodDogT2Zmc2V0S2luZC5IYnNQb3NpdGlvbixcbiAgICBjYWxsYmFjazogKGxlZnQ6IEhic1Bvc2l0aW9uLCByaWdodDogSGJzUG9zaXRpb24pID0+IE91dFxuICApOiBFeGhhdXN0aXZlQ2hlY2s8T3V0LCBNLCAnSGJzLEhicyc+O1xuICB3aGVuKFxuICAgIGxlZnQ6IE9mZnNldEtpbmQuQ2hhclBvc2l0aW9uLFxuICAgIHJpZ2h0OiBPZmZzZXRLaW5kLkNoYXJQb3NpdGlvbixcbiAgICBjYWxsYmFjazogKGxlZnQ6IENoYXJQb3NpdGlvbiwgcmlnaHQ6IENoYXJQb3NpdGlvbikgPT4gT3V0XG4gICk6IEV4aGF1c3RpdmVDaGVjazxPdXQsIE0sICdDaGFyLENoYXInPjtcbiAgd2hlbihcbiAgICBsZWZ0OiBJc0ludmlzaWJsZSxcbiAgICByaWdodDogTWF0Y2hBbnksXG4gICAgY2FsbGJhY2s6IChsZWZ0OiBJbnZpc2libGVQb3NpdGlvbiwgcmlnaHQ6IFBvc2l0aW9uRGF0YSkgPT4gT3V0XG4gICk6IE1hdGNoZXI8T3V0LCBFeGNsdWRlPE0sICdJbnZpc2libGUsQW55Jz4+O1xuICB3aGVuKFxuICAgIGxlZnQ6IE1hdGNoQW55LFxuICAgIHJpZ2h0OiBJc0ludmlzaWJsZSxcbiAgICBjYWxsYmFjazogKGxlZnQ6IFBvc2l0aW9uRGF0YSwgcmlnaHQ6IEludmlzaWJsZVBvc2l0aW9uKSA9PiBPdXRcbiAgKTogRXhoYXVzdGl2ZUNoZWNrPE91dCwgTSwgJ0FueSxJbnZpc2libGUnPjtcbiAgd2hlbihcbiAgICBsZWZ0OiBNYXRjaEFueSxcbiAgICByaWdodDogTWF0Y2hBbnksXG4gICAgY2FsbGJhY2s6IChsZWZ0OiBQb3NpdGlvbkRhdGEsIHJpZ2h0OiBQb3NpdGlvbkRhdGEpID0+IE91dFxuICApOiBFeGhhdXN0aXZlTWF0Y2hlcjxPdXQ+O1xuICB3aGVuKFxuICAgIGxlZnQ6IFBhdHRlcm4sXG4gICAgcmlnaHQ6IFBhdHRlcm4sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsYmFjazogKGxlZnQ6IGFueSwgcmlnaHQ6IGFueSkgPT4gT3V0XG4gICk6IE1hdGNoZXI8T3V0LCBNYXRjaGVzPiB8IEV4aGF1c3RpdmVNYXRjaGVyPE91dD4ge1xuICAgIHRoaXMuI3doZW5zLmdldChsZWZ0LCAoKSA9PiBuZXcgV2hlbigpKS5hZGQocmlnaHQsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhdHRlcm5Gb3Ioa2luZDogT2Zmc2V0S2luZCk6IFBhdHRlcm4ge1xuICBzd2l0Y2ggKGtpbmQpIHtcbiAgICBjYXNlIE9mZnNldEtpbmQuQnJva2VuOlxuICAgIGNhc2UgT2Zmc2V0S2luZC5JbnRlcm5hbHNTeW50aGV0aWM6XG4gICAgY2FzZSBPZmZzZXRLaW5kLk5vbkV4aXN0ZW50OlxuICAgICAgcmV0dXJuIElzSW52aXNpYmxlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ga2luZDtcbiAgfVxufVxuIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuaW1wb3J0IHsgU291cmNlUG9zaXRpb24sIFVOS05PV05fUE9TSVRJT04gfSBmcm9tICcuLi9sb2NhdGlvbic7XG5pbXBvcnQgeyBTb3VyY2UgfSBmcm9tICcuLi9zb3VyY2UnO1xuaW1wb3J0IHsgbWF0Y2gsIE1hdGNoQW55IH0gZnJvbSAnLi9tYXRjaCc7XG5pbXBvcnQgeyBTb3VyY2VTcGFuLCBzcGFuIH0gZnJvbSAnLi9zcGFuJztcblxuZXhwb3J0IGNvbnN0IGVudW0gT2Zmc2V0S2luZCB7XG4gIC8qKlxuICAgKiBXZSBoYXZlIGFscmVhZHkgY29tcHV0ZWQgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiBvZiB0aGlzIG9mZnNldCBvciBzcGFuLlxuICAgKi9cbiAgQ2hhclBvc2l0aW9uID0gJ0NoYXJQb3NpdGlvbicsXG5cbiAgLyoqXG4gICAqIFRoaXMgb2Zmc2V0IG9yIHNwYW4gd2FzIGluc3RhbnRpYXRlZCB3aXRoIGEgSGFuZGxlYmFycyBTb3VyY2VQb3NpdGlvbiBvciBTb3VyY2VMb2NhdGlvbi4gSXRzXG4gICAqIGNoYXJhY3RlciBwb3NpdGlvbiB3aWxsIGJlIGNvbXB1dGVkIG9uIGRlbWFuZC5cbiAgICovXG4gIEhic1Bvc2l0aW9uID0gJ0hic1Bvc2l0aW9uJyxcblxuICAvKipcbiAgICogZm9yIChyYXJlKSBzaXR1YXRpb25zIHdoZXJlIGEgbm9kZSBpcyBjcmVhdGVkIGJ1dCB0aGVyZSB3YXMgbm8gc291cmNlIGxvY2F0aW9uIChlLmcuIHRoZSBuYW1lXG4gICAqIFwiZGVmYXVsdFwiIGluIGRlZmF1bHQgYmxvY2tzIHdoZW4gdGhlIHdvcmQgXCJkZWZhdWx0XCIgbmV2ZXIgYXBwZWFyZWQgaW4gc291cmNlKS4gVGhpcyBpcyB1c2VkXG4gICAqIGJ5IHRoZSBpbnRlcm5hbHMgd2hlbiB0aGVyZSBpcyBhIGxlZ2l0aW1hdGUgcmVhc29uIGZvciB0aGUgaW50ZXJuYWxzIHRvIHN5bnRoZXNpemUgYSBub2RlXG4gICAqIHdpdGggbm8gbG9jYXRpb24uXG4gICAqL1xuICBJbnRlcm5hbHNTeW50aGV0aWMgPSAnSW50ZXJuYWxzU3ludGhldGljJyxcbiAgLyoqXG4gICAqIEZvciBzaXR1YXRpb25zIHdoZXJlIGEgbm9kZSByZXByZXNlbnRzIHplcm8gcGFydHMgb2YgdGhlIHNvdXJjZSAoZm9yIGV4YW1wbGUsIGVtcHR5IGFyZ3VtZW50cykuXG4gICAqIEluIGdlbmVyYWwsIHdlIGF0dGVtcHQgdG8gYXNzaWduIHRoZXNlIG5vZGVzICpzb21lKiBwb3NpdGlvbiAoZW1wdHkgYXJndW1lbnRzIGNhbiBiZVxuICAgKiBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjYWxsZWUpLCBidXQgaXQncyBub3QgYWx3YXlzIHBvc3NpYmxlXG4gICAqL1xuICBOb25FeGlzdGVudCA9ICdOb25FeGlzdGVudCcsXG4gIC8qKlxuICAgKiBGb3Igc2l0dWF0aW9ucyB3aGVyZSBhIHNvdXJjZSBsb2NhdGlvbiB3YXMgZXhwZWN0ZWQsIGJ1dCBpdCBkaWRuJ3QgY29ycmVzcG9uZCB0byB0aGUgbm9kZSBpblxuICAgKiB0aGUgc291cmNlLiBUaGlzIGhhcHBlbnMgaWYgYSBwbHVnaW4gY3JlYXRlcyBicm9rZW4gbG9jYXRpb25zLlxuICAgKi9cbiAgQnJva2VuID0gJ0Jyb2tlbicsXG59XG5cbi8qKlxuICogQWxsIHBvc2l0aW9ucyBoYXZlIHRoZXNlIGRldGFpbHMgaW4gY29tbW9uLiBNb3N0IG5vdGFibHksIGFsbCB0aHJlZSBraW5kcyBvZiBwb3NpdGlvbnMgY2FuXG4gKiBtdXN0IGJlIGFibGUgdG8gYXR0ZW1wdCB0byBjb252ZXJ0IHRoZW1zZWx2ZXMgaW50byB7QHNlZSBDaGFyUG9zaXRpb259LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBvc2l0aW9uRGF0YSB7XG4gIHJlYWRvbmx5IGtpbmQ6IE9mZnNldEtpbmQ7XG4gIHRvQ2hhclBvcygpOiBDaGFyUG9zaXRpb24gfCBudWxsO1xuICB0b0pTT04oKTogU291cmNlUG9zaXRpb247XG59XG5cbi8qKlxuICogVXNlZCB0byBpbmRpY2F0ZSB0aGF0IGFuIGF0dGVtcHQgdG8gY29udmVydCBhIGBTb3VyY2VQb3NpdGlvbmAgdG8gYSBjaGFyYWN0ZXIgb2Zmc2V0IGZhaWxlZC4gSXRcbiAqIGlzIHNlcGFyYXRlIGZyb20gYG51bGxgIHNvIHRoYXQgYG51bGxgIGNhbiBiZSB1c2VkIHRvIGluZGljYXRlIHRoYXQgdGhlIGNvbXB1dGF0aW9uIHdhc24ndCB5ZXRcbiAqIGF0dGVtcHRlZCAoYW5kIHRoZXJlZm9yZSB0byBjYWNoZSB0aGUgZmFpbHVyZSlcbiAqL1xuZXhwb3J0IGNvbnN0IEJST0tFTiA9ICdCUk9LRU4nO1xuZXhwb3J0IHR5cGUgQlJPS0VOID0gJ0JST0tFTic7XG5cbmV4cG9ydCB0eXBlIEFueVBvc2l0aW9uID0gSGJzUG9zaXRpb24gfCBDaGFyUG9zaXRpb24gfCBJbnZpc2libGVQb3NpdGlvbjtcblxuLyoqXG4gKiBBIGBTb3VyY2VPZmZzZXRgIHJlcHJlc2VudHMgYSBzaW5nbGUgcG9zaXRpb24gaW4gdGhlIHNvdXJjZS5cbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUga2luZHMgb2YgYmFja2luZyBkYXRhIGZvciBgU291cmNlT2Zmc2V0YCBvYmplY3RzOlxuICpcbiAqIC0gYENoYXJQb3NpdGlvbmAsIHdoaWNoIGNvbnRhaW5zIGEgY2hhcmFjdGVyIG9mZnNldCBpbnRvIHRoZSByYXcgc291cmNlIHN0cmluZ1xuICogLSBgSGJzUG9zaXRpb25gLCB3aGljaCBjb250YWlucyBhIGBTb3VyY2VQb3NpdGlvbmAgZnJvbSB0aGUgSGFuZGxlYmFycyBBU1QsIHdoaWNoIGNhbiBiZVxuICogICBjb252ZXJ0ZWQgdG8gYSBgQ2hhclBvc2l0aW9uYCBvbiBkZW1hbmQuXG4gKiAtIGBJbnZpc2libGVQb3NpdGlvbmAsIHdoaWNoIHJlcHJlc2VudHMgYSBwb3NpdGlvbiBub3QgaW4gc291cmNlIChAc2VlIHtJbnZpc2libGVQb3NpdGlvbn0pXG4gKi9cbmV4cG9ydCBjbGFzcyBTb3VyY2VPZmZzZXQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgYFNvdXJjZU9mZnNldGAgZnJvbSBhIEhhbmRsZWJhcnMgYFNvdXJjZVBvc2l0aW9uYC4gSXQncyBzdG9yZWQgYXMtaXMsIGFuZCBjb252ZXJ0ZWRcbiAgICogaW50byBhIGNoYXJhY3RlciBvZmZzZXQgb24gZGVtYW5kLCB3aGljaCBhdm9pZHMgdW5uZWNlc3NhcmlseSBjb21wdXRpbmcgdGhlIG9mZnNldCBvZiBldmVyeVxuICAgKiBgU291cmNlTG9jYXRpb25gLCBidXQgYWxzbyBtZWFucyB0aGF0IGJyb2tlbiBgU291cmNlUG9zaXRpb25gcyBhcmUgbm90IGFsd2F5cyBkZXRlY3RlZC5cbiAgICovXG4gIHN0YXRpYyBmb3JIYnNQb3Moc291cmNlOiBTb3VyY2UsIHBvczogU291cmNlUG9zaXRpb24pOiBTb3VyY2VPZmZzZXQge1xuICAgIHJldHVybiBuZXcgSGJzUG9zaXRpb24oc291cmNlLCBwb3MsIG51bGwpLndyYXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgU291cmNlT2Zmc2V0YCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgYnJva2VuIGBTb3VyY2VQb3NpdGlvbmAuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbiAgICogY2FsbGluZyBjb2RlIGRldGVybWluZWQgKG9yIGtub3dzKSB0aGF0IHRoZSBgU291cmNlTG9jYXRpb25gIGRvZXNuJ3QgY29ycmVzcG9uZCBjb3JyZWN0bHkgdG9cbiAgICogYW55IHBhcnQgb2YgdGhlIHNvdXJjZS5cbiAgICovXG4gIHN0YXRpYyBicm9rZW4ocG9zOiBTb3VyY2VQb3NpdGlvbiA9IFVOS05PV05fUE9TSVRJT04pOiBTb3VyY2VPZmZzZXQge1xuICAgIHJldHVybiBuZXcgSW52aXNpYmxlUG9zaXRpb24oT2Zmc2V0S2luZC5Ccm9rZW4sIHBvcykud3JhcCgpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgZGF0YTogUG9zaXRpb25EYXRhICYgQW55UG9zaXRpb24pIHt9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY2hhcmFjdGVyIG9mZnNldCBmb3IgdGhpcyBgU291cmNlT2Zmc2V0YCwgaWYgcG9zc2libGUuXG4gICAqL1xuICBnZXQgb2Zmc2V0KCk6IG51bWJlciB8IG51bGwge1xuICAgIGxldCBjaGFyUG9zID0gdGhpcy5kYXRhLnRvQ2hhclBvcygpO1xuICAgIHJldHVybiBjaGFyUG9zID09PSBudWxsID8gbnVsbCA6IGNoYXJQb3Mub2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmUgdGhpcyBvZmZzZXQgd2l0aCBhbm90aGVyIG9uZS5cbiAgICpcbiAgICogSWYgYm90aCBvZmZzZXRzIGFyZSBgSGJzUG9zaXRpb25gcywgdGhleSdyZSBlcXVpdmFsZW50IGFzIGxvbmcgYXMgdGhlaXIgbGluZXMgYW5kIGNvbHVtbnMgYXJlXG4gICAqIHRoZSBzYW1lLiBUaGlzIGF2b2lkcyBjb21wdXRpbmcgb2Zmc2V0cyB1bm5lY2Vzc2FyaWx5LlxuICAgKlxuICAgKiBPdGhlcndpc2UsIHR3byBgU291cmNlT2Zmc2V0YHMgYXJlIGVxdWl2YWxlbnQgaWYgdGhlaXIgc3VjY2Vzc2Z1bGx5IGNvbXB1dGVkIGNoYXJhY3RlciBvZmZzZXRzXG4gICAqIGFyZSB0aGUgc2FtZS5cbiAgICovXG4gIGVxbChyaWdodDogU291cmNlT2Zmc2V0KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVxbCh0aGlzLmRhdGEsIHJpZ2h0LmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNwYW4gdGhhdCBzdGFydHMgZnJvbSB0aGlzIHNvdXJjZSBvZmZzZXQgYW5kIGVuZHMgd2l0aCBhbm90aGVyIHNvdXJjZSBvZmZzZXQuIEF2b2lkXG4gICAqIGNvbXB1dGluZyBjaGFyYWN0ZXIgb2Zmc2V0cyBpZiBib3RoIGBTb3VyY2VPZmZzZXRgcyBhcmUgc3RpbGwgbGF6eS5cbiAgICovXG4gIHVudGlsKG90aGVyOiBTb3VyY2VPZmZzZXQpOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gc3Bhbih0aGlzLmRhdGEsIG90aGVyLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBTb3VyY2VPZmZzZXRgIGJ5IG1vdmluZyB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIHJlcHJlc2VudGVkIGJ5IHRoaXMgc291cmNlIG9mZnNldFxuICAgKiBmb3J3YXJkIG9yIGJhY2t3YXJkIChpZiBgYnlgIGlzIG5lZ2F0aXZlKSwgaWYgcG9zc2libGUuXG4gICAqXG4gICAqIElmIHRoaXMgYFNvdXJjZU9mZnNldGAgY2FuJ3QgY29tcHV0ZSBhIHZhbGlkIGNoYXJhY3RlciBvZmZzZXQsIGBtb3ZlYCByZXR1cm5zIGEgYnJva2VuIG9mZnNldC5cbiAgICpcbiAgICogSWYgdGhlIHJlc3VsdGluZyBjaGFyYWN0ZXIgb2Zmc2V0IGlzIGxlc3MgdGhhbiAwIG9yIGdyZWF0ZXIgdGhhbiB0aGUgc2l6ZSBvZiB0aGUgc291cmNlLCBgbW92ZWBcbiAgICogcmV0dXJucyBhIGJyb2tlbiBvZmZzZXQuXG4gICAqL1xuICBtb3ZlKGJ5OiBudW1iZXIpOiBTb3VyY2VPZmZzZXQge1xuICAgIGxldCBjaGFyUG9zID0gdGhpcy5kYXRhLnRvQ2hhclBvcygpO1xuXG4gICAgaWYgKGNoYXJQb3MgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBTb3VyY2VPZmZzZXQuYnJva2VuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXN1bHQgPSBjaGFyUG9zLm9mZnNldCArIGJ5O1xuXG4gICAgICBpZiAoY2hhclBvcy5zb3VyY2UuY2hlY2socmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gbmV3IENoYXJQb3NpdGlvbihjaGFyUG9zLnNvdXJjZSwgcmVzdWx0KS53cmFwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gU291cmNlT2Zmc2V0LmJyb2tlbigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYFNvdXJjZVNwYW5gIHRoYXQgcmVwcmVzZW50cyBhIGNvbGxhcHNlZCByYW5nZSBhdCB0aGlzIHNvdXJjZSBvZmZzZXQuIEF2b2lkXG4gICAqIGNvbXB1dGluZyB0aGUgY2hhcmFjdGVyIG9mZnNldCBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlbiBjb21wdXRlZC5cbiAgICovXG4gIGNvbGxhcHNlZCgpOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gc3Bhbih0aGlzLmRhdGEsIHRoaXMuZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGlzIGBTb3VyY2VPZmZzZXRgIGludG8gYSBIYW5kbGViYXJzIHtAc2VlIFNvdXJjZVBvc2l0aW9ufSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoXG4gICAqIGV4aXN0aW5nIHBsdWdpbnMuXG4gICAqL1xuICB0b0pTT04oKTogU291cmNlUG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmRhdGEudG9KU09OKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENoYXJQb3NpdGlvbiBpbXBsZW1lbnRzIFBvc2l0aW9uRGF0YSB7XG4gIHJlYWRvbmx5IGtpbmQgPSBPZmZzZXRLaW5kLkNoYXJQb3NpdGlvbjtcblxuICAvKiogQ29tcHV0ZWQgZnJvbSBjaGFyIG9mZnNldCAqL1xuICAjbG9jUG9zOiBIYnNQb3NpdGlvbiB8IEJST0tFTiB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHNvdXJjZTogU291cmNlLCByZWFkb25seSBjaGFyUG9zOiBudW1iZXIpIHt9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYWxyZWFkeSBhIGBDaGFyUG9zaXRpb25gLlxuICAgKlxuICAgKiB7QHNlZSBIYnNQb3NpdGlvbn0gZm9yIHRoZSBhbHRlcm5hdGl2ZS5cbiAgICpcbiAgICogQGltcGxlbWVudHMge1Bvc2l0aW9uRGF0YX1cbiAgICovXG4gIHRvQ2hhclBvcygpOiBDaGFyUG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgYSBIYW5kbGViYXJzIHtAc2VlIFNvdXJjZVBvc2l0aW9ufSBmb3IgdGhpcyBgQ2hhclBvc2l0aW9uYC4gSWYgdGhpcyBgQ2hhclBvc2l0aW9uYCB3YXNcbiAgICogY29tcHV0ZWQgdXNpbmcge0BzZWUgU291cmNlT2Zmc2V0I21vdmV9LCB0aGlzIHdpbGwgY29tcHV0ZSB0aGUgYFNvdXJjZVBvc2l0aW9uYCBmb3IgdGhlIG9mZnNldC5cbiAgICpcbiAgICogQGltcGxlbWVudHMge1Bvc2l0aW9uRGF0YX1cbiAgICovXG4gIHRvSlNPTigpOiBTb3VyY2VQb3NpdGlvbiB7XG4gICAgbGV0IGhicyA9IHRoaXMudG9IYnNQb3MoKTtcbiAgICByZXR1cm4gaGJzID09PSBudWxsID8gVU5LTk9XTl9QT1NJVElPTiA6IGhicy50b0pTT04oKTtcbiAgfVxuXG4gIHdyYXAoKTogU291cmNlT2Zmc2V0IHtcbiAgICByZXR1cm4gbmV3IFNvdXJjZU9mZnNldCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGBDaGFyUG9zaXRpb25gIGFsd2F5cyBoYXMgYW4gb2Zmc2V0IGl0IGNhbiBwcm9kdWNlIHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgY29tcHV0YXRpb24uXG4gICAqL1xuICBnZXQgb2Zmc2V0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY2hhclBvcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBjdXJyZW50IGNoYXJhY3RlciBvZmZzZXQgdG8gYW4gYEhic1Bvc2l0aW9uYCwgaWYgaXQgd2FzIG5vdCBhbHJlYWR5IGNvbXB1dGVkLiBPbmNlXG4gICAqIGEgYENoYXJQb3NpdGlvbmAgaGFzIGNvbXB1dGVkIGl0cyBgSGJzUG9zaXRpb25gLCBpdCB3aWxsIG5vdCBuZWVkIHRvIGRvIGNvbXB1dGUgaXQgYWdhaW4sIGFuZFxuICAgKiB0aGUgc2FtZSBgQ2hhclBvc2l0aW9uYCBpcyByZXRhaW5lZCB3aGVuIHVzZWQgYXMgb25lIG9mIHRoZSBlbmRzIG9mIGEgYFNvdXJjZVNwYW5gLCBzb1xuICAgKiBjb21wdXRpbmcgdGhlIGBIYnNQb3NpdGlvbmAgc2hvdWxkIGJlIGEgb25lLXRpbWUgb3BlcmF0aW9uLlxuICAgKi9cbiAgdG9IYnNQb3MoKTogSGJzUG9zaXRpb24gfCBudWxsIHtcbiAgICBsZXQgbG9jUG9zID0gdGhpcy4jbG9jUG9zO1xuXG4gICAgaWYgKGxvY1BvcyA9PT0gbnVsbCkge1xuICAgICAgbGV0IGhic1BvcyA9IHRoaXMuc291cmNlLmhic1Bvc0Zvcih0aGlzLmNoYXJQb3MpO1xuXG4gICAgICBpZiAoaGJzUG9zID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuI2xvY1BvcyA9IGxvY1BvcyA9IEJST0tFTjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI2xvY1BvcyA9IGxvY1BvcyA9IG5ldyBIYnNQb3NpdGlvbih0aGlzLnNvdXJjZSwgaGJzUG9zLCB0aGlzLmNoYXJQb3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsb2NQb3MgPT09IEJST0tFTiA/IG51bGwgOiBsb2NQb3M7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEhic1Bvc2l0aW9uIGltcGxlbWVudHMgUG9zaXRpb25EYXRhIHtcbiAgcmVhZG9ubHkga2luZCA9IE9mZnNldEtpbmQuSGJzUG9zaXRpb247XG5cbiAgI2NoYXJQb3M6IENoYXJQb3NpdGlvbiB8IEJST0tFTiB8IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgc291cmNlOiBTb3VyY2UsXG4gICAgcmVhZG9ubHkgaGJzUG9zOiBTb3VyY2VQb3NpdGlvbixcbiAgICBjaGFyUG9zOiBudW1iZXIgfCBudWxsID0gbnVsbFxuICApIHtcbiAgICB0aGlzLiNjaGFyUG9zID0gY2hhclBvcyA9PT0gbnVsbCA/IG51bGwgOiBuZXcgQ2hhclBvc2l0aW9uKHNvdXJjZSwgY2hhclBvcyk7XG4gIH1cblxuICAvKipcbiAgICogTGF6aWx5IGNvbXB1dGUgdGhlIGNoYXJhY3RlciBvZmZzZXQgZnJvbSB0aGUge0BzZWUgU291cmNlUG9zaXRpb259LiBPbmNlIGFuIGBIYnNQb3NpdGlvbmAgaGFzXG4gICAqIGNvbXB1dGVkIGl0cyBgQ2hhclBvc2l0aW9uYCwgaXQgd2lsbCBub3QgbmVlZCB0byBkbyBjb21wdXRlIGl0IGFnYWluLCBhbmQgdGhlIHNhbWVcbiAgICogYEhic1Bvc2l0aW9uYCBpcyByZXRhaW5lZCB3aGVuIHVzZWQgYXMgb25lIG9mIHRoZSBlbmRzIG9mIGEgYFNvdXJjZVNwYW5gLCBzbyBjb21wdXRpbmcgdGhlXG4gICAqIGBDaGFyUG9zaXRpb25gIHNob3VsZCBiZSBhIG9uZS10aW1lIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQGltcGxlbWVudHMge1Bvc2l0aW9uRGF0YX1cbiAgICovXG4gIHRvQ2hhclBvcygpOiBDaGFyUG9zaXRpb24gfCBudWxsIHtcbiAgICBsZXQgY2hhclBvcyA9IHRoaXMuI2NoYXJQb3M7XG5cbiAgICBpZiAoY2hhclBvcyA9PT0gbnVsbCkge1xuICAgICAgbGV0IGNoYXJQb3NOdW1iZXIgPSB0aGlzLnNvdXJjZS5jaGFyUG9zRm9yKHRoaXMuaGJzUG9zKTtcblxuICAgICAgaWYgKGNoYXJQb3NOdW1iZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy4jY2hhclBvcyA9IGNoYXJQb3MgPSBCUk9LRU47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNjaGFyUG9zID0gY2hhclBvcyA9IG5ldyBDaGFyUG9zaXRpb24odGhpcy5zb3VyY2UsIGNoYXJQb3NOdW1iZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFyUG9zID09PSBCUk9LRU4gPyBudWxsIDogY2hhclBvcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHtAc2VlIFNvdXJjZVBvc2l0aW9ufSB0aGF0IHRoaXMgYEhic1Bvc2l0aW9uYCB3YXMgaW5zdGFudGlhdGVkIHdpdGguIFRoaXMgb3BlcmF0aW9uXG4gICAqIGRvZXMgbm90IG5lZWQgdG8gY29tcHV0ZSBhbnl0aGluZy5cbiAgICpcbiAgICogQGltcGxlbWVudHMge1Bvc2l0aW9uRGF0YX1cbiAgICovXG4gIHRvSlNPTigpOiBTb3VyY2VQb3NpdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuaGJzUG9zO1xuICB9XG5cbiAgd3JhcCgpOiBTb3VyY2VPZmZzZXQge1xuICAgIHJldHVybiBuZXcgU291cmNlT2Zmc2V0KHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYWxyZWFkeSBhbiBgSGJzUG9zaXRpb25gLlxuICAgKlxuICAgKiB7QHNlZSBDaGFyUG9zaXRpb259IGZvciB0aGUgYWx0ZXJuYXRpdmUuXG4gICAqL1xuICB0b0hic1BvcygpOiBIYnNQb3NpdGlvbiB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEludmlzaWJsZVBvc2l0aW9uIGltcGxlbWVudHMgUG9zaXRpb25EYXRhIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkga2luZDogT2Zmc2V0S2luZC5Ccm9rZW4gfCBPZmZzZXRLaW5kLkludGVybmFsc1N5bnRoZXRpYyB8IE9mZnNldEtpbmQuTm9uRXhpc3RlbnQsXG4gICAgLy8gd2hhdGV2ZXIgd2FzIHByb3ZpZGVkLCBwb3NzaWJseSBicm9rZW5cbiAgICByZWFkb25seSBwb3M6IFNvdXJjZVBvc2l0aW9uXG4gICkge31cblxuICAvKipcbiAgICogQSBicm9rZW4gcG9zaXRpb24gY2Fubm90IGJlIHR1cm5lZCBpbnRvIGEge0BzZWUgQ2hhcmFjdGVyUG9zaXRpb259LlxuICAgKi9cbiAgdG9DaGFyUG9zKCk6IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzZXJpYWxpemF0aW9uIG9mIGFuIGBJbnZpc2libGVQb3NpdGlvbiBpcyB3aGF0ZXZlciBIYW5kbGViYXJzIHtAc2VlIFNvdXJjZVBvc2l0aW9ufSB3YXNcbiAgICogb3JpZ2luYWxseSBpZGVudGlmaWVkIGFzIGJyb2tlbiwgbm9uLWV4aXN0ZW50IG9yIHN5bnRoZXRpYy5cbiAgICpcbiAgICogSWYgYW4gYEludmlzaWJsZVBvc2l0aW9uYCBuZXZlciBoYWQgYW4gc291cmNlIG9mZnNldCBhdCBhbGwsIHRoaXMgbWV0aG9kIHJldHVybnNcbiAgICoge0BzZWUgVU5LTk9XTl9QT1NJVElPTn0gZm9yIGNvbXBhdGliaWxpdHkuXG4gICAqL1xuICB0b0pTT04oKTogU291cmNlUG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLnBvcztcbiAgfVxuXG4gIHdyYXAoKTogU291cmNlT2Zmc2V0IHtcbiAgICByZXR1cm4gbmV3IFNvdXJjZU9mZnNldCh0aGlzKTtcbiAgfVxuXG4gIGdldCBvZmZzZXQoKTogbnVsbCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wYXJlIHR3byB7QHNlZSBBbnlQb3NpdGlvbn0gYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXkgYXJlIGVxdWFsLlxuICpcbiAqIEBzZWUge1NvdXJjZU9mZnNldCNlcWx9XG4gKi9cbmNvbnN0IGVxbCA9IG1hdGNoPGJvb2xlYW4+KChtKSA9PlxuICBtXG4gICAgLndoZW4oXG4gICAgICBPZmZzZXRLaW5kLkhic1Bvc2l0aW9uLFxuICAgICAgT2Zmc2V0S2luZC5IYnNQb3NpdGlvbixcbiAgICAgICh7IGhic1BvczogbGVmdCB9LCB7IGhic1BvczogcmlnaHQgfSkgPT5cbiAgICAgICAgbGVmdC5jb2x1bW4gPT09IHJpZ2h0LmNvbHVtbiAmJiBsZWZ0LmxpbmUgPT09IHJpZ2h0LmxpbmVcbiAgICApXG4gICAgLndoZW4oXG4gICAgICBPZmZzZXRLaW5kLkNoYXJQb3NpdGlvbixcbiAgICAgIE9mZnNldEtpbmQuQ2hhclBvc2l0aW9uLFxuICAgICAgKHsgY2hhclBvczogbGVmdCB9LCB7IGNoYXJQb3M6IHJpZ2h0IH0pID0+IGxlZnQgPT09IHJpZ2h0XG4gICAgKVxuICAgIC53aGVuKFxuICAgICAgT2Zmc2V0S2luZC5DaGFyUG9zaXRpb24sXG4gICAgICBPZmZzZXRLaW5kLkhic1Bvc2l0aW9uLFxuICAgICAgKHsgb2Zmc2V0OiBsZWZ0IH0sIHJpZ2h0KSA9PiBsZWZ0ID09PSByaWdodC50b0NoYXJQb3MoKT8ub2Zmc2V0XG4gICAgKVxuICAgIC53aGVuKFxuICAgICAgT2Zmc2V0S2luZC5IYnNQb3NpdGlvbixcbiAgICAgIE9mZnNldEtpbmQuQ2hhclBvc2l0aW9uLFxuICAgICAgKGxlZnQsIHsgb2Zmc2V0OiByaWdodCB9KSA9PiBsZWZ0LnRvQ2hhclBvcygpPy5vZmZzZXQgPT09IHJpZ2h0XG4gICAgKVxuICAgIC53aGVuKE1hdGNoQW55LCBNYXRjaEFueSwgKCkgPT4gZmFsc2UpXG4pO1xuIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgTE9DQUxfREVCVUcgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBhc3NlcnROZXZlciB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5pbXBvcnQge1xuICBCUk9LRU5fTE9DQVRJT04sXG4gIE5PTl9FWElTVEVOVF9MT0NBVElPTixcbiAgU291cmNlTG9jYXRpb24sXG4gIFNvdXJjZVBvc2l0aW9uLFxufSBmcm9tICcuLi9sb2NhdGlvbic7XG5pbXBvcnQgeyBTb3VyY2VTbGljZSB9IGZyb20gJy4uL3NsaWNlJztcbmltcG9ydCB7IFNvdXJjZSB9IGZyb20gJy4uL3NvdXJjZSc7XG5pbXBvcnQgeyBJc0ludmlzaWJsZSwgbWF0Y2gsIE1hdGNoQW55LCBNYXRjaEZuIH0gZnJvbSAnLi9tYXRjaCc7XG5pbXBvcnQge1xuICBBbnlQb3NpdGlvbixcbiAgQlJPS0VOLFxuICBDaGFyUG9zaXRpb24sXG4gIEhic1Bvc2l0aW9uLFxuICBJbnZpc2libGVQb3NpdGlvbixcbiAgT2Zmc2V0S2luZCxcbiAgU291cmNlT2Zmc2V0LFxufSBmcm9tICcuL29mZnNldCc7XG5cbi8qKlxuICogQWxsIHNwYW5zIGhhdmUgdGhlc2UgZGV0YWlscyBpbiBjb21tb24uXG4gKi9cbmludGVyZmFjZSBTcGFuRGF0YSB7XG4gIHJlYWRvbmx5IGtpbmQ6IE9mZnNldEtpbmQ7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhpcyBzcGFuIGludG8gYSBzdHJpbmcuIElmIHRoZSBzcGFuIGlzIGJyb2tlbiwgcmV0dXJuIGAnJ2AuXG4gICAqL1xuICBhc1N0cmluZygpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1vZHVsZSB0aGUgc3BhbiB3YXMgbG9jYXRlZCBpbi5cbiAgICovXG4gIGdldE1vZHVsZSgpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gZm9yIHRoaXMgc3Bhbi4gVHJ5IHRvIGF2b2lkIGNyZWF0aW5nIG5ldyBwb3NpdGlvbiBvYmplY3RzLCBhcyB0aGV5XG4gICAqIGNhY2hlIGNvbXB1dGF0aW9ucy5cbiAgICovXG4gIGdldFN0YXJ0KCk6IEFueVBvc2l0aW9uO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVuZGluZyBwb3NpdGlvbiBmb3IgdGhpcyBzcGFuLiBUcnkgdG8gYXZvaWQgY3JlYXRpbmcgbmV3IHBvc2l0aW9uIG9iamVjdHMsIGFzIHRoZXlcbiAgICogY2FjaGUgY29tcHV0YXRpb25zLlxuICAgKi9cbiAgZ2V0RW5kKCk6IEFueVBvc2l0aW9uO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBgU291cmNlTG9jYXRpb25gIGZvciB0aGlzIHNwYW4sIHJldHVybmVkIGFzIGFuIGluc3RhbmNlIG9mIGBIYnNTcGFuYC5cbiAgICovXG4gIHRvSGJzU3BhbigpOiBIYnNTcGFuIHwgbnVsbDtcblxuICAvKipcbiAgICogRm9yIGNvbXBhdGliaWxpdHksIHdoZW5ldmVyIHRoZSBgc3RhcnRgIG9yIGBlbmRgIG9mIGEge0BzZWUgU291cmNlT2Zmc2V0fSBjaGFuZ2VzLCBzcGFucyBhcmVcbiAgICogbm90aWZpZWQgb2YgdGhlIGNoYW5nZSBzbyB0aGV5IGNhbiB1cGRhdGUgdGhlbXNlbHZlcy4gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIG91dHNpZGUgb2YgQVNUXG4gICAqIHBsdWdpbnMuXG4gICAqL1xuICBsb2NEaWRVcGRhdGUoY2hhbmdlczogeyBzdGFydD86IFNvdXJjZVBvc2l0aW9uOyBlbmQ/OiBTb3VyY2VQb3NpdGlvbiB9KTogdm9pZDtcblxuICAvKipcbiAgICogU2VyaWFsaXplIGludG8gYSB7QHNlZSBTZXJpYWxpemVkU291cmNlU3Bhbn0sIHdoaWNoIGlzIGNvbXBhY3QgYW5kIGRlc2lnbmVkIGZvciByZWFkYWJpbGl0eSBpblxuICAgKiBjb250ZXh0IGxpa2UgQVNUIEV4cGxvcmVyLiBJZiB5b3UgbmVlZCBhIHtAc2VlIFNvdXJjZUxvY2F0aW9ufSwgdXNlIHtAc2VlIHRvSlNPTn0uXG4gICAqL1xuICBzZXJpYWxpemUoKTogU2VyaWFsaXplZFNvdXJjZVNwYW47XG59XG5cbi8qKlxuICogQSBgU291cmNlU3BhbmAgb2JqZWN0IHJlcHJlc2VudHMgYSBzcGFuIG9mIGNoYXJhY3RlcnMgaW5zaWRlIG9mIGEgdGVtcGxhdGUgc291cmNlLlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBraW5kcyBvZiBgU291cmNlU3BhbmAgb2JqZWN0czpcbiAqXG4gKiAtIGBDb25jcmV0ZVNvdXJjZVNwYW5gLCB3aGljaCBjb250YWlucyBieXRlIG9mZnNldHNcbiAqIC0gYExhenlTb3VyY2VTcGFuYCwgd2hpY2ggY29udGFpbnMgYFNvdXJjZUxvY2F0aW9uYHMgZnJvbSB0aGUgSGFuZGxlYmFycyBBU1QsIHdoaWNoIGNhbiBiZVxuICogICBjb252ZXJ0ZWQgdG8gYnl0ZSBvZmZzZXRzIG9uIGRlbWFuZC5cbiAqIC0gYEludmlzaWJsZVNvdXJjZVNwYW5gLCB3aGljaCByZXByZXNlbnQgc291cmNlIHN0cmluZ3MgdGhhdCBhcmVuJ3QgcHJlc2VudCBpbiB0aGUgc291cmNlLFxuICogICBiZWNhdXNlOlxuICogICAgIC0gdGhleSB3ZXJlIGNyZWF0ZWQgc3ludGhldGljYWxseVxuICogICAgIC0gdGhlaXIgbG9jYXRpb24gaXMgbm9uc2Vuc2ljYWwgKHRoZSBzcGFuIGlzIGJyb2tlbilcbiAqICAgICAtIHRoZXkgcmVwcmVzZW50IG5vdGhpbmcgaW4gdGhlIHNvdXJjZSAodGhpcyBjdXJyZW50bHkgaGFwcGVucyBvbmx5IHdoZW4gYSBidWcgaW4gdGhlXG4gKiAgICAgICB1cHN0cmVhbSBIYW5kbGViYXJzIHBhcnNlciBmYWlscyB0byBhc3NpZ24gYSBsb2NhdGlvbiB0byBlbXB0eSBibG9ja3MpXG4gKlxuICogQXQgYSBoaWdoIGxldmVsLCBhbGwgYFNvdXJjZVNwYW5gIG9iamVjdHMgcHJvdmlkZTpcbiAqXG4gKiAtIGJ5dGUgb2Zmc2V0c1xuICogLSBzb3VyY2UgaW4gY29sdW1uIGFuZCBsaW5lIGZvcm1hdFxuICpcbiAqIEFuZCB5b3UgY2FuIGRvIHRoZXNlIG9wZXJhdGlvbnMgb24gYFNvdXJjZVNwYW5gczpcbiAqXG4gKiAtIGNvbGxhcHNlIGl0IHRvIGEgYFNvdXJjZVNwYW5gIHJlcHJlc2VudGluZyBpdHMgc3RhcnRpbmcgb3IgZW5kaW5nIHBvc2l0aW9uXG4gKiAtIHNsaWNlIG91dCBzb21lIGNoYXJhY3RlcnMsIG9wdGlvbmFsbHkgc2tpcHBpbmcgc29tZSBjaGFyYWN0ZXJzIGF0IHRoZSBiZWdpbm5pbmcgb3IgZW5kXG4gKiAtIGNyZWF0ZSBhIG5ldyBgU291cmNlU3BhbmAgd2l0aCBhIGRpZmZlcmVudCBzdGFydGluZyBvciBlbmRpbmcgb2Zmc2V0XG4gKlxuICogQWxsIFNvdXJjZVNwYW4gb2JqZWN0cyBpbXBsZW1lbnQgYFNvdXJjZUxvY2F0aW9uYCwgZm9yIGNvbXBhdGliaWxpdHkuIEFsbCBTb3VyY2VTcGFuXG4gKiBvYmplY3RzIGhhdmUgYSBgdG9KU09OYCB0aGF0IGVtaXRzIGBTb3VyY2VMb2NhdGlvbmAsIGFsc28gZm9yIGNvbXBhdGliaWxpdHkuXG4gKlxuICogRm9yIGNvbXBhdGliaWxpdHksIHN1YmNsYXNzZXMgb2YgYEFic3RyYWN0U291cmNlU3BhbmAgbXVzdCBpbXBsZW1lbnQgYGxvY0RpZFVwZGF0ZWAsIHdoaWNoXG4gKiBoYXBwZW5zIHdoZW4gYW4gQVNUIHBsdWdpbiBhdHRlbXB0cyB0byBtb2RpZnkgdGhlIGBzdGFydGAgb3IgYGVuZGAgb2YgYSBzcGFuIGRpcmVjdGx5LlxuICpcbiAqIFRoZSBnb2FsIGlzIHRvIGF2b2lkIGNyZWF0aW5nIGFueSBwcm9ibGVtcyBmb3IgdXNlLWNhc2VzIGxpa2UgQVNUIEV4cGxvcmVyLlxuICovXG5leHBvcnQgY2xhc3MgU291cmNlU3BhbiBpbXBsZW1lbnRzIFNvdXJjZUxvY2F0aW9uIHtcbiAgc3RhdGljIGdldCBOT05fRVhJU1RFTlQoKTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIG5ldyBJbnZpc2libGVTcGFuKE9mZnNldEtpbmQuTm9uRXhpc3RlbnQsIE5PTl9FWElTVEVOVF9MT0NBVElPTikud3JhcCgpO1xuICB9XG5cbiAgc3RhdGljIGxvYWQoc291cmNlOiBTb3VyY2UsIHNlcmlhbGl6ZWQ6IFNlcmlhbGl6ZWRTb3VyY2VTcGFuKTogU291cmNlU3BhbiB7XG4gICAgaWYgKHR5cGVvZiBzZXJpYWxpemVkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIFNvdXJjZVNwYW4uZm9yQ2hhclBvc2l0aW9ucyhzb3VyY2UsIHNlcmlhbGl6ZWQsIHNlcmlhbGl6ZWQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlcmlhbGl6ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gU291cmNlU3Bhbi5zeW50aGV0aWMoc2VyaWFsaXplZCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlcmlhbGl6ZWQpKSB7XG4gICAgICByZXR1cm4gU291cmNlU3Bhbi5mb3JDaGFyUG9zaXRpb25zKHNvdXJjZSwgc2VyaWFsaXplZFswXSwgc2VyaWFsaXplZFsxXSk7XG4gICAgfSBlbHNlIGlmIChzZXJpYWxpemVkID09PSBPZmZzZXRLaW5kLk5vbkV4aXN0ZW50KSB7XG4gICAgICByZXR1cm4gU291cmNlU3Bhbi5OT05fRVhJU1RFTlQ7XG4gICAgfSBlbHNlIGlmIChzZXJpYWxpemVkID09PSBPZmZzZXRLaW5kLkJyb2tlbikge1xuICAgICAgcmV0dXJuIFNvdXJjZVNwYW4uYnJva2VuKEJST0tFTl9MT0NBVElPTik7XG4gICAgfVxuXG4gICAgYXNzZXJ0TmV2ZXIoc2VyaWFsaXplZCk7XG4gIH1cblxuICBzdGF0aWMgZm9ySGJzTG9jKHNvdXJjZTogU291cmNlLCBsb2M6IFNvdXJjZUxvY2F0aW9uKTogU291cmNlU3BhbiB7XG4gICAgbGV0IHN0YXJ0ID0gbmV3IEhic1Bvc2l0aW9uKHNvdXJjZSwgbG9jLnN0YXJ0KTtcbiAgICBsZXQgZW5kID0gbmV3IEhic1Bvc2l0aW9uKHNvdXJjZSwgbG9jLmVuZCk7XG4gICAgcmV0dXJuIG5ldyBIYnNTcGFuKHNvdXJjZSwgeyBzdGFydCwgZW5kIH0sIGxvYykud3JhcCgpO1xuICB9XG5cbiAgc3RhdGljIGZvckNoYXJQb3NpdGlvbnMoc291cmNlOiBTb3VyY2UsIHN0YXJ0UG9zOiBudW1iZXIsIGVuZFBvczogbnVtYmVyKTogU291cmNlU3BhbiB7XG4gICAgbGV0IHN0YXJ0ID0gbmV3IENoYXJQb3NpdGlvbihzb3VyY2UsIHN0YXJ0UG9zKTtcbiAgICBsZXQgZW5kID0gbmV3IENoYXJQb3NpdGlvbihzb3VyY2UsIGVuZFBvcyk7XG5cbiAgICByZXR1cm4gbmV3IENoYXJQb3NpdGlvblNwYW4oc291cmNlLCB7IHN0YXJ0LCBlbmQgfSkud3JhcCgpO1xuICB9XG5cbiAgc3RhdGljIHN5bnRoZXRpYyhjaGFyczogc3RyaW5nKTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIG5ldyBJbnZpc2libGVTcGFuKE9mZnNldEtpbmQuSW50ZXJuYWxzU3ludGhldGljLCBOT05fRVhJU1RFTlRfTE9DQVRJT04sIGNoYXJzKS53cmFwKCk7XG4gIH1cblxuICBzdGF0aWMgYnJva2VuKHBvczogU291cmNlTG9jYXRpb24gPSBCUk9LRU5fTE9DQVRJT04pOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gbmV3IEludmlzaWJsZVNwYW4oT2Zmc2V0S2luZC5Ccm9rZW4sIHBvcykud3JhcCgpO1xuICB9XG5cbiAgcmVhZG9ubHkgaXNJbnZpc2libGU6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhOiBTcGFuRGF0YSAmIEFueVNwYW4pIHtcbiAgICB0aGlzLmlzSW52aXNpYmxlID1cbiAgICAgIGRhdGEua2luZCAhPT0gT2Zmc2V0S2luZC5DaGFyUG9zaXRpb24gJiYgZGF0YS5raW5kICE9PSBPZmZzZXRLaW5kLkhic1Bvc2l0aW9uO1xuICB9XG5cbiAgZ2V0U3RhcnQoKTogU291cmNlT2Zmc2V0IHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmdldFN0YXJ0KCkud3JhcCgpO1xuICB9XG5cbiAgZ2V0RW5kKCk6IFNvdXJjZU9mZnNldCB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5nZXRFbmQoKS53cmFwKCk7XG4gIH1cblxuICBnZXQgbG9jKCk6IFNvdXJjZUxvY2F0aW9uIHtcbiAgICBsZXQgc3BhbiA9IHRoaXMuZGF0YS50b0hic1NwYW4oKTtcbiAgICByZXR1cm4gc3BhbiA9PT0gbnVsbCA/IEJST0tFTl9MT0NBVElPTiA6IHNwYW4udG9IYnNMb2MoKTtcbiAgfVxuXG4gIGdldCBtb2R1bGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmdldE1vZHVsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhcnRpbmcgYFNvdXJjZVBvc2l0aW9uYCBmb3IgdGhpcyBgU291cmNlU3BhbmAsIGxhemlseSBjb21wdXRpbmcgaXQgaWYgbmVlZGVkLlxuICAgKi9cbiAgZ2V0IHN0YXJ0UG9zaXRpb24oKTogU291cmNlUG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmxvYy5zdGFydDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVuZGluZyBgU291cmNlUG9zaXRpb25gIGZvciB0aGlzIGBTb3VyY2VTcGFuYCwgbGF6aWx5IGNvbXB1dGluZyBpdCBpZiBuZWVkZWQuXG4gICAqL1xuICBnZXQgZW5kUG9zaXRpb24oKTogU291cmNlUG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmxvYy5lbmQ7XG4gIH1cblxuICAvKipcbiAgICogU3VwcG9ydCBjb252ZXJ0aW5nIEFTVHYxIG5vZGVzIGludG8gYSBzZXJpYWxpemVkIGZvcm1hdCB1c2luZyBKU09OLnN0cmluZ2lmeS5cbiAgICovXG4gIHRvSlNPTigpOiBTb3VyY2VMb2NhdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMubG9jO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzcGFuIHdpdGggdGhlIGN1cnJlbnQgc3BhbidzIGVuZCBhbmQgYSBuZXcgYmVnaW5uaW5nLlxuICAgKi9cbiAgd2l0aFN0YXJ0KG90aGVyOiBTb3VyY2VPZmZzZXQpOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gc3BhbihvdGhlci5kYXRhLCB0aGlzLmRhdGEuZ2V0RW5kKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzcGFuIHdpdGggdGhlIGN1cnJlbnQgc3BhbidzIGJlZ2lubmluZyBhbmQgYSBuZXcgZW5kaW5nLlxuICAgKi9cbiAgd2l0aEVuZCh0aGlzOiBTb3VyY2VTcGFuLCBvdGhlcjogU291cmNlT2Zmc2V0KTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIHNwYW4odGhpcy5kYXRhLmdldFN0YXJ0KCksIG90aGVyLmRhdGEpO1xuICB9XG5cbiAgYXNTdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmFzU3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGlzIGBTb3VyY2VTcGFuYCBpbnRvIGEgYFNvdXJjZVNsaWNlYC4gSW4gZGVidWcgbW9kZSwgdGhpcyBtZXRob2Qgb3B0aW9uYWxseSBjaGVja3NcbiAgICogdGhhdCB0aGUgYnl0ZSBvZmZzZXRzIHJlcHJlc2VudGVkIGJ5IHRoaXMgYFNvdXJjZVNwYW5gIGFjdHVhbGx5IGNvcnJlc3BvbmQgdG8gdGhlIGV4cGVjdGVkXG4gICAqIHN0cmluZy5cbiAgICovXG4gIHRvU2xpY2UoZXhwZWN0ZWQ/OiBzdHJpbmcpOiBTb3VyY2VTbGljZSB7XG4gICAgbGV0IGNoYXJzID0gdGhpcy5kYXRhLmFzU3RyaW5nKCk7XG5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIGlmIChleHBlY3RlZCAhPT0gdW5kZWZpbmVkICYmIGNoYXJzICE9PSBleHBlY3RlZCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYHVuZXhwZWN0ZWRseSBmb3VuZCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgY2hhcnNcbiAgICAgICAgICApfSB3aGVuIHNsaWNpbmcgc291cmNlLCBidXQgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShleHBlY3RlZCl9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgU291cmNlU2xpY2Uoe1xuICAgICAgbG9jOiB0aGlzLFxuICAgICAgY2hhcnM6IGV4cGVjdGVkIHx8IGNoYXJzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBjb21wYXRpYmlsaXR5IHdpdGggU291cmNlTG9jYXRpb24gaW4gQVNUIHBsdWdpbnNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHN0YXJ0UG9zaXRpb24gaW5zdGVhZFxuICAgKi9cbiAgZ2V0IHN0YXJ0KCk6IFNvdXJjZVBvc2l0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5sb2Muc3RhcnQ7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGNvbXBhdGliaWxpdHkgd2l0aCBTb3VyY2VMb2NhdGlvbiBpbiBBU1QgcGx1Z2luc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2Ugd2l0aFN0YXJ0IGluc3RlYWRcbiAgICovXG4gIHNldCBzdGFydChwb3NpdGlvbjogU291cmNlUG9zaXRpb24pIHtcbiAgICB0aGlzLmRhdGEubG9jRGlkVXBkYXRlKHsgc3RhcnQ6IHBvc2l0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBjb21wYXRpYmlsaXR5IHdpdGggU291cmNlTG9jYXRpb24gaW4gQVNUIHBsdWdpbnNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGVuZFBvc2l0aW9uIGluc3RlYWRcbiAgICovXG4gIGdldCBlbmQoKTogU291cmNlUG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmxvYy5lbmQ7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGNvbXBhdGliaWxpdHkgd2l0aCBTb3VyY2VMb2NhdGlvbiBpbiBBU1QgcGx1Z2luc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2Ugd2l0aEVuZCBpbnN0ZWFkXG4gICAqL1xuICBzZXQgZW5kKHBvc2l0aW9uOiBTb3VyY2VQb3NpdGlvbikge1xuICAgIHRoaXMuZGF0YS5sb2NEaWRVcGRhdGUoeyBlbmQ6IHBvc2l0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBjb21wYXRpYmlsaXR5IHdpdGggU291cmNlTG9jYXRpb24gaW4gQVNUIHBsdWdpbnNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdXNlIG1vZHVsZSBpbnN0ZWFkXG4gICAqL1xuICBnZXQgc291cmNlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlO1xuICB9XG5cbiAgY29sbGFwc2Uod2hlcmU6ICdzdGFydCcgfCAnZW5kJyk6IFNvdXJjZVNwYW4ge1xuICAgIHN3aXRjaCAod2hlcmUpIHtcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhcnQoKS5jb2xsYXBzZWQoKTtcbiAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuZCgpLmNvbGxhcHNlZCgpO1xuICAgIH1cbiAgfVxuXG4gIGV4dGVuZChvdGhlcjogU291cmNlU3Bhbik6IFNvdXJjZVNwYW4ge1xuICAgIHJldHVybiBzcGFuKHRoaXMuZGF0YS5nZXRTdGFydCgpLCBvdGhlci5kYXRhLmdldEVuZCgpKTtcbiAgfVxuXG4gIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemVkU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zZXJpYWxpemUoKTtcbiAgfVxuXG4gIHNsaWNlKHsgc2tpcFN0YXJ0ID0gMCwgc2tpcEVuZCA9IDAgfTogeyBza2lwU3RhcnQ/OiBudW1iZXI7IHNraXBFbmQ/OiBudW1iZXIgfSk6IFNvdXJjZVNwYW4ge1xuICAgIHJldHVybiBzcGFuKHRoaXMuZ2V0U3RhcnQoKS5tb3ZlKHNraXBTdGFydCkuZGF0YSwgdGhpcy5nZXRFbmQoKS5tb3ZlKC1za2lwRW5kKS5kYXRhKTtcbiAgfVxuXG4gIHNsaWNlU3RhcnRDaGFycyh7IHNraXBTdGFydCA9IDAsIGNoYXJzIH06IHsgc2tpcFN0YXJ0PzogbnVtYmVyOyBjaGFyczogbnVtYmVyIH0pOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gc3Bhbih0aGlzLmdldFN0YXJ0KCkubW92ZShza2lwU3RhcnQpLmRhdGEsIHRoaXMuZ2V0U3RhcnQoKS5tb3ZlKHNraXBTdGFydCArIGNoYXJzKS5kYXRhKTtcbiAgfVxuXG4gIHNsaWNlRW5kQ2hhcnMoeyBza2lwRW5kID0gMCwgY2hhcnMgfTogeyBza2lwRW5kPzogbnVtYmVyOyBjaGFyczogbnVtYmVyIH0pOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gc3Bhbih0aGlzLmdldEVuZCgpLm1vdmUoc2tpcEVuZCAtIGNoYXJzKS5kYXRhLCB0aGlzLmdldFN0YXJ0KCkubW92ZSgtc2tpcEVuZCkuZGF0YSk7XG4gIH1cbn1cblxudHlwZSBBbnlTcGFuID0gSGJzU3BhbiB8IENoYXJQb3NpdGlvblNwYW4gfCBJbnZpc2libGVTcGFuO1xuXG5jbGFzcyBDaGFyUG9zaXRpb25TcGFuIGltcGxlbWVudHMgU3BhbkRhdGEge1xuICByZWFkb25seSBraW5kID0gT2Zmc2V0S2luZC5DaGFyUG9zaXRpb247XG5cbiAgI2xvY1Bvc1NwYW46IEhic1NwYW4gfCBCUk9LRU4gfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBzb3VyY2U6IFNvdXJjZSxcbiAgICByZWFkb25seSBjaGFyUG9zaXRpb25zOiB7IHN0YXJ0OiBDaGFyUG9zaXRpb247IGVuZDogQ2hhclBvc2l0aW9uIH1cbiAgKSB7fVxuXG4gIHdyYXAoKTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIG5ldyBTb3VyY2VTcGFuKHRoaXMpO1xuICB9XG5cbiAgYXNTdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc2xpY2UodGhpcy5jaGFyUG9zaXRpb25zLnN0YXJ0LmNoYXJQb3MsIHRoaXMuY2hhclBvc2l0aW9ucy5lbmQuY2hhclBvcyk7XG4gIH1cblxuICBnZXRNb2R1bGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UubW9kdWxlO1xuICB9XG5cbiAgZ2V0U3RhcnQoKTogQW55UG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmNoYXJQb3NpdGlvbnMuc3RhcnQ7XG4gIH1cblxuICBnZXRFbmQoKTogQW55UG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmNoYXJQb3NpdGlvbnMuZW5kO1xuICB9XG5cbiAgbG9jRGlkVXBkYXRlKCkge1xuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYHVwZGF0aW5nIGEgbG9jYXRpb24gdGhhdCBjYW1lIGZyb20gYSBDaGFyUG9zaXRpb24gc3BhbiBkb2Vzbid0IHdvcmsgcmVsaWFibHkuIERvbid0IHRyeSB0byB1cGRhdGUgbG9jYXRpb25zIGFmdGVyIHRoZSBwbHVnaW4gcGhhc2VgXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHRvSGJzU3BhbigpOiBIYnNTcGFuIHwgbnVsbCB7XG4gICAgbGV0IGxvY1Bvc1NwYW4gPSB0aGlzLiNsb2NQb3NTcGFuO1xuXG4gICAgaWYgKGxvY1Bvc1NwYW4gPT09IG51bGwpIHtcbiAgICAgIGxldCBzdGFydCA9IHRoaXMuY2hhclBvc2l0aW9ucy5zdGFydC50b0hic1BvcygpO1xuICAgICAgbGV0IGVuZCA9IHRoaXMuY2hhclBvc2l0aW9ucy5lbmQudG9IYnNQb3MoKTtcblxuICAgICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCkge1xuICAgICAgICBsb2NQb3NTcGFuID0gdGhpcy4jbG9jUG9zU3BhbiA9IEJST0tFTjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY1Bvc1NwYW4gPSB0aGlzLiNsb2NQb3NTcGFuID0gbmV3IEhic1NwYW4odGhpcy5zb3VyY2UsIHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsb2NQb3NTcGFuID09PSBCUk9LRU4gPyBudWxsIDogbG9jUG9zU3BhbjtcbiAgfVxuXG4gIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemVkU291cmNlU3BhbiB7XG4gICAgbGV0IHtcbiAgICAgIHN0YXJ0OiB7IGNoYXJQb3M6IHN0YXJ0IH0sXG4gICAgICBlbmQ6IHsgY2hhclBvczogZW5kIH0sXG4gICAgfSA9IHRoaXMuY2hhclBvc2l0aW9ucztcblxuICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICByZXR1cm4gc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbc3RhcnQsIGVuZF07XG4gICAgfVxuICB9XG5cbiAgdG9DaGFyUG9zU3BhbigpOiBDaGFyUG9zaXRpb25TcGFuIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSGJzU3BhbiBpbXBsZW1lbnRzIFNwYW5EYXRhIHtcbiAgcmVhZG9ubHkga2luZCA9IE9mZnNldEtpbmQuSGJzUG9zaXRpb247XG5cbiAgI2NoYXJQb3NTcGFuOiBDaGFyUG9zaXRpb25TcGFuIHwgQlJPS0VOIHwgbnVsbCA9IG51bGw7XG5cbiAgLy8gdGhlIHNvdXJjZSBsb2NhdGlvbiBmcm9tIEhhbmRsZWJhcnMgKyBBU1QgUGx1Z2lucyAtLSBjb3VsZCBiZSB3cm9uZ1xuICAjcHJvdmlkZWRIYnNMb2M6IFNvdXJjZUxvY2F0aW9uIHwgbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBzb3VyY2U6IFNvdXJjZSxcbiAgICByZWFkb25seSBoYnNQb3NpdGlvbnM6IHsgc3RhcnQ6IEhic1Bvc2l0aW9uOyBlbmQ6IEhic1Bvc2l0aW9uIH0sXG4gICAgcHJvdmlkZWRIYnNMb2M6IFNvdXJjZUxvY2F0aW9uIHwgbnVsbCA9IG51bGxcbiAgKSB7XG4gICAgdGhpcy4jcHJvdmlkZWRIYnNMb2MgPSBwcm92aWRlZEhic0xvYztcbiAgfVxuXG4gIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemVkQ29uY3JldGVTb3VyY2VTcGFuIHtcbiAgICBsZXQgY2hhclBvcyA9IHRoaXMudG9DaGFyUG9zU3BhbigpO1xuICAgIHJldHVybiBjaGFyUG9zID09PSBudWxsID8gT2Zmc2V0S2luZC5Ccm9rZW4gOiBjaGFyUG9zLndyYXAoKS5zZXJpYWxpemUoKTtcbiAgfVxuXG4gIHdyYXAoKTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIG5ldyBTb3VyY2VTcGFuKHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVQcm92aWRlZChwb3M6IFNvdXJjZVBvc2l0aW9uLCBlZGdlOiAnc3RhcnQnIHwgJ2VuZCcpIHtcbiAgICBpZiAodGhpcy4jcHJvdmlkZWRIYnNMb2MpIHtcbiAgICAgIHRoaXMuI3Byb3ZpZGVkSGJzTG9jW2VkZ2VdID0gcG9zO1xuICAgIH1cblxuICAgIC8vIGludmFsaWRhdGUgY29tcHV0ZWQgY2hhcmFjdGVyIG9mZnNldHNcbiAgICB0aGlzLiNjaGFyUG9zU3BhbiA9IG51bGw7XG4gICAgdGhpcy4jcHJvdmlkZWRIYnNMb2MgPSB7XG4gICAgICBzdGFydDogcG9zLFxuICAgICAgZW5kOiBwb3MsXG4gICAgfTtcbiAgfVxuXG4gIGxvY0RpZFVwZGF0ZSh7IHN0YXJ0LCBlbmQgfTogeyBzdGFydD86IFNvdXJjZVBvc2l0aW9uOyBlbmQ/OiBTb3VyY2VQb3NpdGlvbiB9KTogdm9pZCB7XG4gICAgaWYgKHN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlUHJvdmlkZWQoc3RhcnQsICdzdGFydCcpO1xuICAgICAgdGhpcy5oYnNQb3NpdGlvbnMuc3RhcnQgPSBuZXcgSGJzUG9zaXRpb24odGhpcy5zb3VyY2UsIHN0YXJ0LCBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlUHJvdmlkZWQoZW5kLCAnZW5kJyk7XG4gICAgICB0aGlzLmhic1Bvc2l0aW9ucy5lbmQgPSBuZXcgSGJzUG9zaXRpb24odGhpcy5zb3VyY2UsIGVuZCwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgYXNTdHJpbmcoKTogc3RyaW5nIHtcbiAgICBsZXQgc3BhbiA9IHRoaXMudG9DaGFyUG9zU3BhbigpO1xuICAgIHJldHVybiBzcGFuID09PSBudWxsID8gJycgOiBzcGFuLmFzU3RyaW5nKCk7XG4gIH1cblxuICBnZXRNb2R1bGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UubW9kdWxlO1xuICB9XG5cbiAgZ2V0U3RhcnQoKTogQW55UG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmhic1Bvc2l0aW9ucy5zdGFydDtcbiAgfVxuXG4gIGdldEVuZCgpOiBBbnlQb3NpdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuaGJzUG9zaXRpb25zLmVuZDtcbiAgfVxuXG4gIHRvSGJzTG9jKCk6IFNvdXJjZUxvY2F0aW9uIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHRoaXMuaGJzUG9zaXRpb25zLnN0YXJ0Lmhic1BvcyxcbiAgICAgIGVuZDogdGhpcy5oYnNQb3NpdGlvbnMuZW5kLmhic1BvcyxcbiAgICB9O1xuICB9XG5cbiAgdG9IYnNTcGFuKCk6IEhic1NwYW4ge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG9DaGFyUG9zU3BhbigpOiBDaGFyUG9zaXRpb25TcGFuIHwgbnVsbCB7XG4gICAgbGV0IGNoYXJQb3NTcGFuID0gdGhpcy4jY2hhclBvc1NwYW47XG5cbiAgICBpZiAoY2hhclBvc1NwYW4gPT09IG51bGwpIHtcbiAgICAgIGxldCBzdGFydCA9IHRoaXMuaGJzUG9zaXRpb25zLnN0YXJ0LnRvQ2hhclBvcygpO1xuICAgICAgbGV0IGVuZCA9IHRoaXMuaGJzUG9zaXRpb25zLmVuZC50b0NoYXJQb3MoKTtcblxuICAgICAgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgICAgICBjaGFyUG9zU3BhbiA9IHRoaXMuI2NoYXJQb3NTcGFuID0gbmV3IENoYXJQb3NpdGlvblNwYW4odGhpcy5zb3VyY2UsIHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhclBvc1NwYW4gPSB0aGlzLiNjaGFyUG9zU3BhbiA9IEJST0tFTjtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYXJQb3NTcGFuID09PSBCUk9LRU4gPyBudWxsIDogY2hhclBvc1NwYW47XG4gIH1cbn1cblxuY2xhc3MgSW52aXNpYmxlU3BhbiBpbXBsZW1lbnRzIFNwYW5EYXRhIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkga2luZDogT2Zmc2V0S2luZC5Ccm9rZW4gfCBPZmZzZXRLaW5kLkludGVybmFsc1N5bnRoZXRpYyB8IE9mZnNldEtpbmQuTm9uRXhpc3RlbnQsXG4gICAgLy8gd2hhdGV2ZXIgd2FzIHByb3ZpZGVkLCBwb3NzaWJseSBicm9rZW5cbiAgICByZWFkb25seSBsb2M6IFNvdXJjZUxvY2F0aW9uLFxuICAgIC8vIGlmIHRoZSBzcGFuIHJlcHJlc2VudHMgYSBzeW50aGV0aWMgc3RyaW5nXG4gICAgcmVhZG9ubHkgc3RyaW5nOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICApIHt9XG5cbiAgc2VyaWFsaXplKCk6IFNlcmlhbGl6ZWRDb25jcmV0ZVNvdXJjZVNwYW4ge1xuICAgIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gICAgICBjYXNlIE9mZnNldEtpbmQuQnJva2VuOlxuICAgICAgY2FzZSBPZmZzZXRLaW5kLk5vbkV4aXN0ZW50OlxuICAgICAgICByZXR1cm4gdGhpcy5raW5kO1xuICAgICAgY2FzZSBPZmZzZXRLaW5kLkludGVybmFsc1N5bnRoZXRpYzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nIHx8ICcnO1xuICAgIH1cbiAgfVxuXG4gIHdyYXAoKTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIG5ldyBTb3VyY2VTcGFuKHRoaXMpO1xuICB9XG5cbiAgYXNTdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmcgfHwgJyc7XG4gIH1cblxuICBsb2NEaWRVcGRhdGUoeyBzdGFydCwgZW5kIH06IHsgc3RhcnQ/OiBTb3VyY2VQb3NpdGlvbjsgZW5kPzogU291cmNlUG9zaXRpb24gfSkge1xuICAgIGlmIChzdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxvYy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sb2MuZW5kID0gZW5kO1xuICAgIH1cbiAgfVxuXG4gIGdldE1vZHVsZSgpOiBzdHJpbmcge1xuICAgIC8vIFRPRE86IE1ha2UgdGhpcyByZWZsZWN0IHRoZSBhY3R1YWwgbW9kdWxlIHRoaXMgc3BhbiBvcmlnaW5hdGVkIGZyb21cbiAgICByZXR1cm4gJ2FuIHVua25vd24gbW9kdWxlJztcbiAgfVxuXG4gIGdldFN0YXJ0KCk6IEFueVBvc2l0aW9uIHtcbiAgICByZXR1cm4gbmV3IEludmlzaWJsZVBvc2l0aW9uKHRoaXMua2luZCwgdGhpcy5sb2Muc3RhcnQpO1xuICB9XG5cbiAgZ2V0RW5kKCk6IEFueVBvc2l0aW9uIHtcbiAgICByZXR1cm4gbmV3IEludmlzaWJsZVBvc2l0aW9uKHRoaXMua2luZCwgdGhpcy5sb2MuZW5kKTtcbiAgfVxuXG4gIHRvQ2hhclBvc1NwYW4oKTogSW52aXNpYmxlU3BhbiB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b0hic1NwYW4oKTogbnVsbCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0b0hic0xvYygpOiBTb3VyY2VMb2NhdGlvbiB7XG4gICAgcmV0dXJuIEJST0tFTl9MT0NBVElPTjtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3BhbjogTWF0Y2hGbjxTb3VyY2VTcGFuPiA9IG1hdGNoKChtKSA9PlxuICBtXG4gICAgLndoZW4oT2Zmc2V0S2luZC5IYnNQb3NpdGlvbiwgT2Zmc2V0S2luZC5IYnNQb3NpdGlvbiwgKGxlZnQsIHJpZ2h0KSA9PlxuICAgICAgbmV3IEhic1NwYW4obGVmdC5zb3VyY2UsIHtcbiAgICAgICAgc3RhcnQ6IGxlZnQsXG4gICAgICAgIGVuZDogcmlnaHQsXG4gICAgICB9KS53cmFwKClcbiAgICApXG4gICAgLndoZW4oT2Zmc2V0S2luZC5DaGFyUG9zaXRpb24sIE9mZnNldEtpbmQuQ2hhclBvc2l0aW9uLCAobGVmdCwgcmlnaHQpID0+XG4gICAgICBuZXcgQ2hhclBvc2l0aW9uU3BhbihsZWZ0LnNvdXJjZSwge1xuICAgICAgICBzdGFydDogbGVmdCxcbiAgICAgICAgZW5kOiByaWdodCxcbiAgICAgIH0pLndyYXAoKVxuICAgIClcbiAgICAud2hlbihPZmZzZXRLaW5kLkNoYXJQb3NpdGlvbiwgT2Zmc2V0S2luZC5IYnNQb3NpdGlvbiwgKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBsZXQgcmlnaHRDaGFyUG9zID0gcmlnaHQudG9DaGFyUG9zKCk7XG5cbiAgICAgIGlmIChyaWdodENoYXJQb3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZpc2libGVTcGFuKE9mZnNldEtpbmQuQnJva2VuLCBCUk9LRU5fTE9DQVRJT04pLndyYXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzcGFuKGxlZnQsIHJpZ2h0Q2hhclBvcyk7XG4gICAgICB9XG4gICAgfSlcbiAgICAud2hlbihPZmZzZXRLaW5kLkhic1Bvc2l0aW9uLCBPZmZzZXRLaW5kLkNoYXJQb3NpdGlvbiwgKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBsZXQgbGVmdENoYXJQb3MgPSBsZWZ0LnRvQ2hhclBvcygpO1xuXG4gICAgICBpZiAobGVmdENoYXJQb3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZpc2libGVTcGFuKE9mZnNldEtpbmQuQnJva2VuLCBCUk9LRU5fTE9DQVRJT04pLndyYXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzcGFuKGxlZnRDaGFyUG9zLCByaWdodCk7XG4gICAgICB9XG4gICAgfSlcbiAgICAud2hlbihJc0ludmlzaWJsZSwgTWF0Y2hBbnksIChsZWZ0KSA9PiBuZXcgSW52aXNpYmxlU3BhbihsZWZ0LmtpbmQsIEJST0tFTl9MT0NBVElPTikud3JhcCgpKVxuICAgIC53aGVuKE1hdGNoQW55LCBJc0ludmlzaWJsZSwgKF8sIHJpZ2h0KSA9PlxuICAgICAgbmV3IEludmlzaWJsZVNwYW4ocmlnaHQua2luZCwgQlJPS0VOX0xPQ0FUSU9OKS53cmFwKClcbiAgICApXG4pO1xuXG5leHBvcnQgdHlwZSBTZXJpYWxpemVkQ29uY3JldGVTb3VyY2VTcGFuID1cbiAgfCAvKiogY29sbGFwc2VkICovIG51bWJlclxuICB8IC8qKiBub3JtYWwgKi8gW3N0YXJ0OiBudW1iZXIsIHNpemU6IG51bWJlcl1cbiAgfCAvKiogc3ludGhldGljICovIHN0cmluZztcblxuZXhwb3J0IHR5cGUgU2VyaWFsaXplZFNvdXJjZVNwYW4gPVxuICB8IFNlcmlhbGl6ZWRDb25jcmV0ZVNvdXJjZVNwYW5cbiAgfCBPZmZzZXRLaW5kLk5vbkV4aXN0ZW50XG4gIHwgT2Zmc2V0S2luZC5Ccm9rZW47XG4iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgdHlwZSB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmltcG9ydCB7IFNvdXJjZUxvY2F0aW9uLCBTb3VyY2VQb3NpdGlvbiB9IGZyb20gJy4vbG9jYXRpb24nO1xuaW1wb3J0IHsgU291cmNlT2Zmc2V0LCBTb3VyY2VTcGFuIH0gZnJvbSAnLi9zcGFuJztcblxuZXhwb3J0IGNsYXNzIFNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHNvdXJjZTogc3RyaW5nLCByZWFkb25seSBtb2R1bGU6IHN0cmluZyA9ICdhbiB1bmtub3duIG1vZHVsZScpIHt9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoYXQgdGhlIGNoYXJhY3RlciBvZmZzZXQgcmVwcmVzZW50cyBhIHBvc2l0aW9uIGluIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgKi9cbiAgY2hlY2sob2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gb2Zmc2V0ID49IDAgJiYgb2Zmc2V0IDw9IHRoaXMuc291cmNlLmxlbmd0aDtcbiAgfVxuXG4gIHNsaWNlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIH1cblxuICBvZmZzZXRGb3IobGluZTogbnVtYmVyLCBjb2x1bW46IG51bWJlcik6IFNvdXJjZU9mZnNldCB7XG4gICAgcmV0dXJuIFNvdXJjZU9mZnNldC5mb3JIYnNQb3ModGhpcywgeyBsaW5lLCBjb2x1bW4gfSk7XG4gIH1cblxuICBzcGFuRm9yKHsgc3RhcnQsIGVuZCB9OiBSZWFkb25seTxTb3VyY2VMb2NhdGlvbj4pOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gU291cmNlU3Bhbi5mb3JIYnNMb2ModGhpcywge1xuICAgICAgc3RhcnQ6IHsgbGluZTogc3RhcnQubGluZSwgY29sdW1uOiBzdGFydC5jb2x1bW4gfSxcbiAgICAgIGVuZDogeyBsaW5lOiBlbmQubGluZSwgY29sdW1uOiBlbmQuY29sdW1uIH0sXG4gICAgfSk7XG4gIH1cblxuICBoYnNQb3NGb3Iob2Zmc2V0OiBudW1iZXIpOiBPcHRpb248U291cmNlUG9zaXRpb24+IHtcbiAgICBsZXQgc2VlbkxpbmVzID0gMDtcbiAgICBsZXQgc2VlbkNoYXJzID0gMDtcblxuICAgIGlmIChvZmZzZXQgPiB0aGlzLnNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgbmV4dExpbmUgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nLCBzZWVuQ2hhcnMpO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IG5leHRMaW5lIHx8IG5leHRMaW5lID09PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHNlZW5MaW5lcyArIDEsXG4gICAgICAgICAgY29sdW1uOiBvZmZzZXQgLSBzZWVuQ2hhcnMsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuTGluZXMgKz0gMTtcbiAgICAgICAgc2VlbkNoYXJzID0gbmV4dExpbmUgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNoYXJQb3NGb3IocG9zaXRpb246IFNvdXJjZVBvc2l0aW9uKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgbGV0IHsgbGluZSwgY29sdW1uIH0gPSBwb3NpdGlvbjtcbiAgICBsZXQgc291cmNlU3RyaW5nID0gdGhpcy5zb3VyY2U7XG4gICAgbGV0IHNvdXJjZUxlbmd0aCA9IHNvdXJjZVN0cmluZy5sZW5ndGg7XG4gICAgbGV0IHNlZW5MaW5lcyA9IDA7XG4gICAgbGV0IHNlZW5DaGFycyA9IDA7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHNlZW5DaGFycyA+PSBzb3VyY2VMZW5ndGgpIHJldHVybiBzb3VyY2VMZW5ndGg7XG5cbiAgICAgIGxldCBuZXh0TGluZSA9IHRoaXMuc291cmNlLmluZGV4T2YoJ1xcbicsIHNlZW5DaGFycyk7XG4gICAgICBpZiAobmV4dExpbmUgPT09IC0xKSBuZXh0TGluZSA9IHRoaXMuc291cmNlLmxlbmd0aDtcblxuICAgICAgaWYgKHNlZW5MaW5lcyA9PT0gbGluZSAtIDEpIHtcbiAgICAgICAgaWYgKHNlZW5DaGFycyArIGNvbHVtbiA+IG5leHRMaW5lKSByZXR1cm4gbmV4dExpbmU7XG5cbiAgICAgICAgaWYgKERFQlVHKSB7XG4gICAgICAgICAgbGV0IHJvdW5kVHJpcCA9IHRoaXMuaGJzUG9zRm9yKHNlZW5DaGFycyArIGNvbHVtbik7XG4gICAgICAgICAgYXNzZXJ0KHJvdW5kVHJpcCAhPT0gbnVsbCwgYHRoZSByZXR1cm5lZCBvZmZzZXQgZmFpbGVkIHRvIHJvdW5kLXRyaXBgKTtcbiAgICAgICAgICBhc3NlcnQocm91bmRUcmlwLmxpbmUgPT09IGxpbmUsIGB0aGUgcm91bmQtdHJpcHBlZCBsaW5lIGRpZG4ndCBtYXRjaCB0aGUgb3JpZ2luYWwgbGluZWApO1xuICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgIHJvdW5kVHJpcC5jb2x1bW4gPT09IGNvbHVtbixcbiAgICAgICAgICAgIGB0aGUgcm91bmQtdHJpcHBlZCBjb2x1bW4gZGlkbid0IG1hdGNoIHRoZSBvcmlnaW5hbCBjb2x1bW5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWVuQ2hhcnMgKyBjb2x1bW47XG4gICAgICB9IGVsc2UgaWYgKG5leHRMaW5lID09PSAtMSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW5MaW5lcyArPSAxO1xuICAgICAgICBzZWVuQ2hhcnMgPSBuZXh0TGluZSArIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBTb3VyY2VTcGFuIH0gZnJvbSAnLi4vc291cmNlL3NwYW4nO1xuaW1wb3J0IHsgUGF0aEV4cHJlc3Npb24sIFBhdGhIZWFkIH0gZnJvbSAnLi9ub2Rlcy12MSc7XG5pbXBvcnQgYiBmcm9tICcuL3B1YmxpYy1idWlsZGVycyc7XG5cbmV4cG9ydCBjbGFzcyBQYXRoRXhwcmVzc2lvbkltcGxWMSBpbXBsZW1lbnRzIFBhdGhFeHByZXNzaW9uIHtcbiAgdHlwZTogJ1BhdGhFeHByZXNzaW9uJyA9ICdQYXRoRXhwcmVzc2lvbic7XG4gIHB1YmxpYyBwYXJ0czogc3RyaW5nW107XG4gIHB1YmxpYyB0aGlzID0gZmFsc2U7XG4gIHB1YmxpYyBkYXRhID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocHVibGljIG9yaWdpbmFsOiBzdHJpbmcsIGhlYWQ6IFBhdGhIZWFkLCB0YWlsOiBzdHJpbmdbXSwgcHVibGljIGxvYzogU291cmNlU3Bhbikge1xuICAgIGxldCBwYXJ0cyA9IHRhaWwuc2xpY2UoKTtcblxuICAgIGlmIChoZWFkLnR5cGUgPT09ICdUaGlzSGVhZCcpIHtcbiAgICAgIHRoaXMudGhpcyA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChoZWFkLnR5cGUgPT09ICdBdEhlYWQnKSB7XG4gICAgICB0aGlzLmRhdGEgPSB0cnVlO1xuICAgICAgcGFydHMudW5zaGlmdChoZWFkLm5hbWUuc2xpY2UoMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KGhlYWQubmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICB9XG5cbiAgZ2V0IGhlYWQoKTogUGF0aEhlYWQge1xuICAgIGxldCBmaXJzdFBhcnQ6IHN0cmluZztcblxuICAgIGlmICh0aGlzLnRoaXMpIHtcbiAgICAgIGZpcnN0UGFydCA9ICd0aGlzJztcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgZmlyc3RQYXJ0ID0gYEAke3RoaXMucGFydHNbMF19YDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3RQYXJ0ID0gdGhpcy5wYXJ0c1swXTtcbiAgICB9XG5cbiAgICBsZXQgZmlyc3RQYXJ0TG9jID0gdGhpcy5sb2MuY29sbGFwc2UoJ3N0YXJ0Jykuc2xpY2VTdGFydENoYXJzKHtcbiAgICAgIGNoYXJzOiBmaXJzdFBhcnQubGVuZ3RoLFxuICAgIH0pLmxvYztcblxuICAgIHJldHVybiBiLmhlYWQoZmlyc3RQYXJ0LCBmaXJzdFBhcnRMb2MpO1xuICB9XG5cbiAgZ2V0IHRhaWwoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLnRoaXMgPyB0aGlzLnBhcnRzIDogdGhpcy5wYXJ0cy5zbGljZSgxKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGljdCwgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBMT0NBTF9ERUJVRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7IGFzc2VydCwgYXNzaWduLCBkZXByZWNhdGUsIGlzUHJlc2VudCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5pbXBvcnQgeyBTb3VyY2VMb2NhdGlvbiwgU291cmNlUG9zaXRpb24sIFNZTlRIRVRJQ19MT0NBVElPTiB9IGZyb20gJy4uL3NvdXJjZS9sb2NhdGlvbic7XG5pbXBvcnQgeyBTb3VyY2UgfSBmcm9tICcuLi9zb3VyY2Uvc291cmNlJztcbmltcG9ydCB7IFNvdXJjZVNwYW4gfSBmcm9tICcuLi9zb3VyY2Uvc3Bhbic7XG5pbXBvcnQgKiBhcyBBU1R2MSBmcm9tICcuL2FwaSc7XG5pbXBvcnQgeyBQYXRoRXhwcmVzc2lvbkltcGxWMSB9IGZyb20gJy4vbGVnYWN5LWludGVyb3AnO1xuXG5sZXQgX1NPVVJDRTogU291cmNlIHwgdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBTT1VSQ0UoKTogU291cmNlIHtcbiAgaWYgKCFfU09VUkNFKSB7XG4gICAgX1NPVVJDRSA9IG5ldyBTb3VyY2UoJycsICcoc3ludGhldGljKScpO1xuICB9XG5cbiAgcmV0dXJuIF9TT1VSQ0U7XG59XG5cbi8vIGNvbnN0IFNPVVJDRSA9IG5ldyBTb3VyY2UoJycsICcodGVzdHMpJyk7XG5cbi8vIFN0YXRlbWVudHNcblxuZXhwb3J0IHR5cGUgQnVpbGRlckhlYWQgPSBzdHJpbmcgfCBBU1R2MS5FeHByZXNzaW9uO1xuZXhwb3J0IHR5cGUgVGFnRGVzY3JpcHRvciA9IHN0cmluZyB8IHsgbmFtZTogc3RyaW5nOyBzZWxmQ2xvc2luZzogYm9vbGVhbiB9O1xuXG5mdW5jdGlvbiBidWlsZE11c3RhY2hlKFxuICBwYXRoOiBCdWlsZGVySGVhZCB8IEFTVHYxLkxpdGVyYWwsXG4gIHBhcmFtcz86IEFTVHYxLkV4cHJlc3Npb25bXSxcbiAgaGFzaD86IEFTVHYxLkhhc2gsXG4gIHJhdz86IGJvb2xlYW4sXG4gIGxvYz86IFNvdXJjZUxvY2F0aW9uLFxuICBzdHJpcD86IEFTVHYxLlN0cmlwRmxhZ3Ncbik6IEFTVHYxLk11c3RhY2hlU3RhdGVtZW50IHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIHBhdGggPSBidWlsZFBhdGgocGF0aCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNdXN0YWNoZVN0YXRlbWVudCcsXG4gICAgcGF0aCxcbiAgICBwYXJhbXM6IHBhcmFtcyB8fCBbXSxcbiAgICBoYXNoOiBoYXNoIHx8IGJ1aWxkSGFzaChbXSksXG4gICAgZXNjYXBlZDogIXJhdyxcbiAgICB0cnVzdGluZzogISFyYXcsXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gICAgc3RyaXA6IHN0cmlwIHx8IHsgb3BlbjogZmFsc2UsIGNsb3NlOiBmYWxzZSB9LFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZEJsb2NrKFxuICBwYXRoOiBCdWlsZGVySGVhZCxcbiAgcGFyYW1zOiBPcHRpb248QVNUdjEuRXhwcmVzc2lvbltdPixcbiAgaGFzaDogT3B0aW9uPEFTVHYxLkhhc2g+LFxuICBfZGVmYXVsdEJsb2NrOiBBU1R2MS5Qb3NzaWJseURlcHJlY2F0ZWRCbG9jayxcbiAgX2Vsc2VCbG9jaz86IE9wdGlvbjxBU1R2MS5Qb3NzaWJseURlcHJlY2F0ZWRCbG9jaz4sXG4gIGxvYz86IFNvdXJjZUxvY2F0aW9uLFxuICBvcGVuU3RyaXA/OiBBU1R2MS5TdHJpcEZsYWdzLFxuICBpbnZlcnNlU3RyaXA/OiBBU1R2MS5TdHJpcEZsYWdzLFxuICBjbG9zZVN0cmlwPzogQVNUdjEuU3RyaXBGbGFnc1xuKTogQVNUdjEuQmxvY2tTdGF0ZW1lbnQge1xuICBsZXQgZGVmYXVsdEJsb2NrOiBBU1R2MS5CbG9jaztcbiAgbGV0IGVsc2VCbG9jazogT3B0aW9uPEFTVHYxLkJsb2NrPiB8IHVuZGVmaW5lZDtcblxuICBpZiAoX2RlZmF1bHRCbG9jay50eXBlID09PSAnVGVtcGxhdGUnKSB7XG4gICAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgICBkZXByZWNhdGUoYGIucHJvZ3JhbSBpcyBkZXByZWNhdGVkLiBVc2UgYi5ibG9ja0l0c2VsZiBpbnN0ZWFkLmApO1xuICAgIH1cblxuICAgIGRlZmF1bHRCbG9jayA9IChhc3NpZ24oe30sIF9kZWZhdWx0QmxvY2ssIHsgdHlwZTogJ0Jsb2NrJyB9KSBhcyB1bmtub3duKSBhcyBBU1R2MS5CbG9jaztcbiAgfSBlbHNlIHtcbiAgICBkZWZhdWx0QmxvY2sgPSBfZGVmYXVsdEJsb2NrO1xuICB9XG5cbiAgaWYgKF9lbHNlQmxvY2sgIT09IHVuZGVmaW5lZCAmJiBfZWxzZUJsb2NrICE9PSBudWxsICYmIF9lbHNlQmxvY2sudHlwZSA9PT0gJ1RlbXBsYXRlJykge1xuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgZGVwcmVjYXRlKGBiLnByb2dyYW0gaXMgZGVwcmVjYXRlZC4gVXNlIGIuYmxvY2tJdHNlbGYgaW5zdGVhZC5gKTtcbiAgICB9XG5cbiAgICBlbHNlQmxvY2sgPSAoYXNzaWduKHt9LCBfZWxzZUJsb2NrLCB7IHR5cGU6ICdCbG9jaycgfSkgYXMgdW5rbm93bikgYXMgQVNUdjEuQmxvY2s7XG4gIH0gZWxzZSB7XG4gICAgZWxzZUJsb2NrID0gX2Vsc2VCbG9jaztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICBwYXRoOiBidWlsZFBhdGgocGF0aCksXG4gICAgcGFyYW1zOiBwYXJhbXMgfHwgW10sXG4gICAgaGFzaDogaGFzaCB8fCBidWlsZEhhc2goW10pLFxuICAgIHByb2dyYW06IGRlZmF1bHRCbG9jayB8fCBudWxsLFxuICAgIGludmVyc2U6IGVsc2VCbG9jayB8fCBudWxsLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICAgIG9wZW5TdHJpcDogb3BlblN0cmlwIHx8IHsgb3BlbjogZmFsc2UsIGNsb3NlOiBmYWxzZSB9LFxuICAgIGludmVyc2VTdHJpcDogaW52ZXJzZVN0cmlwIHx8IHsgb3BlbjogZmFsc2UsIGNsb3NlOiBmYWxzZSB9LFxuICAgIGNsb3NlU3RyaXA6IGNsb3NlU3RyaXAgfHwgeyBvcGVuOiBmYWxzZSwgY2xvc2U6IGZhbHNlIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRWxlbWVudE1vZGlmaWVyKFxuICBwYXRoOiBCdWlsZGVySGVhZCB8IEFTVHYxLkV4cHJlc3Npb24sXG4gIHBhcmFtcz86IEFTVHYxLkV4cHJlc3Npb25bXSxcbiAgaGFzaD86IEFTVHYxLkhhc2gsXG4gIGxvYz86IE9wdGlvbjxTb3VyY2VMb2NhdGlvbj5cbik6IEFTVHYxLkVsZW1lbnRNb2RpZmllclN0YXRlbWVudCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0VsZW1lbnRNb2RpZmllclN0YXRlbWVudCcsXG4gICAgcGF0aDogYnVpbGRQYXRoKHBhdGgpLFxuICAgIHBhcmFtczogcGFyYW1zIHx8IFtdLFxuICAgIGhhc2g6IGhhc2ggfHwgYnVpbGRIYXNoKFtdKSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRQYXJ0aWFsKFxuICBuYW1lOiBBU1R2MS5QYXRoRXhwcmVzc2lvbixcbiAgcGFyYW1zPzogQVNUdjEuRXhwcmVzc2lvbltdLFxuICBoYXNoPzogQVNUdjEuSGFzaCxcbiAgaW5kZW50Pzogc3RyaW5nLFxuICBsb2M/OiBTb3VyY2VMb2NhdGlvblxuKTogQVNUdjEuUGFydGlhbFN0YXRlbWVudCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1BhcnRpYWxTdGF0ZW1lbnQnLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcGFyYW1zOiBwYXJhbXMgfHwgW10sXG4gICAgaGFzaDogaGFzaCB8fCBidWlsZEhhc2goW10pLFxuICAgIGluZGVudDogaW5kZW50IHx8ICcnLFxuICAgIHN0cmlwOiB7IG9wZW46IGZhbHNlLCBjbG9zZTogZmFsc2UgfSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRDb21tZW50KHZhbHVlOiBzdHJpbmcsIGxvYz86IFNvdXJjZUxvY2F0aW9uKTogQVNUdjEuQ29tbWVudFN0YXRlbWVudCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0NvbW1lbnRTdGF0ZW1lbnQnLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRNdXN0YWNoZUNvbW1lbnQodmFsdWU6IHN0cmluZywgbG9jPzogU291cmNlTG9jYXRpb24pOiBBU1R2MS5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQnLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRDb25jYXQoXG4gIHBhcnRzOiAoQVNUdjEuVGV4dE5vZGUgfCBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudClbXSxcbiAgbG9jPzogU291cmNlTG9jYXRpb25cbik6IEFTVHYxLkNvbmNhdFN0YXRlbWVudCB7XG4gIGlmICghaXNQcmVzZW50KHBhcnRzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYi5jb25jYXQgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHBhcnRgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0NvbmNhdFN0YXRlbWVudCcsXG4gICAgcGFydHM6IHBhcnRzIHx8IFtdLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG4vLyBOb2Rlc1xuXG5leHBvcnQgdHlwZSBFbGVtZW50UGFydHMgPVxuICB8IFsnYXR0cnMnLCAuLi5BdHRyU2V4cFtdXVxuICB8IFsnbW9kaWZpZXJzJywgLi4uTW9kaWZpZXJTZXhwW11dXG4gIHwgWydib2R5JywgLi4uQVNUdjEuU3RhdGVtZW50W11dXG4gIHwgWydjb21tZW50cycsIC4uLkVsZW1lbnRDb21tZW50W11dXG4gIHwgWydhcycsIC4uLnN0cmluZ1tdXVxuICB8IFsnbG9jJywgU291cmNlTG9jYXRpb25dO1xuXG5leHBvcnQgdHlwZSBQYXRoU2V4cCA9IHN0cmluZyB8IFsncGF0aCcsIHN0cmluZywgTG9jU2V4cD9dO1xuXG5leHBvcnQgdHlwZSBNb2RpZmllclNleHAgPVxuICB8IHN0cmluZ1xuICB8IFtQYXRoU2V4cCwgTG9jU2V4cD9dXG4gIHwgW1BhdGhTZXhwLCBBU1R2MS5FeHByZXNzaW9uW10sIExvY1NleHA/XVxuICB8IFtQYXRoU2V4cCwgQVNUdjEuRXhwcmVzc2lvbltdLCBEaWN0PEFTVHYxLkV4cHJlc3Npb24+LCBMb2NTZXhwP107XG5cbmV4cG9ydCB0eXBlIEF0dHJTZXhwID0gW3N0cmluZywgQVNUdjEuQXR0ck5vZGVbJ3ZhbHVlJ10gfCBzdHJpbmcsIExvY1NleHA/XTtcblxuZXhwb3J0IHR5cGUgTG9jU2V4cCA9IFsnbG9jJywgU291cmNlTG9jYXRpb25dO1xuXG5leHBvcnQgdHlwZSBFbGVtZW50Q29tbWVudCA9IEFTVHYxLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudCB8IFNvdXJjZUxvY2F0aW9uIHwgc3RyaW5nO1xuXG5leHBvcnQgdHlwZSBTZXhwVmFsdWUgPVxuICB8IHN0cmluZ1xuICB8IEFTVHYxLkV4cHJlc3Npb25bXVxuICB8IERpY3Q8QVNUdjEuRXhwcmVzc2lvbj5cbiAgfCBMb2NTZXhwXG4gIHwgUGF0aFNleHBcbiAgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVpbGRFbGVtZW50T3B0aW9ucyB7XG4gIGF0dHJzPzogQVNUdjEuQXR0ck5vZGVbXTtcbiAgbW9kaWZpZXJzPzogQVNUdjEuRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50W107XG4gIGNoaWxkcmVuPzogQVNUdjEuU3RhdGVtZW50W107XG4gIGNvbW1lbnRzPzogRWxlbWVudENvbW1lbnRbXTtcbiAgYmxvY2tQYXJhbXM/OiBzdHJpbmdbXTtcbiAgbG9jPzogU291cmNlU3Bhbjtcbn1cblxuZnVuY3Rpb24gYnVpbGRFbGVtZW50KHRhZzogVGFnRGVzY3JpcHRvciwgb3B0aW9uczogQnVpbGRFbGVtZW50T3B0aW9ucyk6IEFTVHYxLkVsZW1lbnROb2RlIHtcbiAgbGV0IHsgYXR0cnMsIGJsb2NrUGFyYW1zLCBtb2RpZmllcnMsIGNvbW1lbnRzLCBjaGlsZHJlbiwgbG9jIH0gPSBvcHRpb25zO1xuXG4gIGxldCB0YWdOYW1lOiBzdHJpbmc7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIGZvciBiYWNrd2FyZHMgY29tcGF0LCBwcmlvciB0byBgc2VsZkNsb3NpbmdgIGJlaW5nIHBhcnQgb2YgdGhlIEVsZW1lbnROb2RlIEFTVFxuICBsZXQgc2VsZkNsb3NpbmcgPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdvYmplY3QnKSB7XG4gICAgc2VsZkNsb3NpbmcgPSB0YWcuc2VsZkNsb3Npbmc7XG4gICAgdGFnTmFtZSA9IHRhZy5uYW1lO1xuICB9IGVsc2UgaWYgKHRhZy5zbGljZSgtMSkgPT09ICcvJykge1xuICAgIHRhZ05hbWUgPSB0YWcuc2xpY2UoMCwgLTEpO1xuICAgIHNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0YWdOYW1lID0gdGFnO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnRWxlbWVudE5vZGUnLFxuICAgIHRhZzogdGFnTmFtZSxcbiAgICBzZWxmQ2xvc2luZzogc2VsZkNsb3NpbmcsXG4gICAgYXR0cmlidXRlczogYXR0cnMgfHwgW10sXG4gICAgYmxvY2tQYXJhbXM6IGJsb2NrUGFyYW1zIHx8IFtdLFxuICAgIG1vZGlmaWVyczogbW9kaWZpZXJzIHx8IFtdLFxuICAgIGNvbW1lbnRzOiAoY29tbWVudHMgYXMgQVNUdjEuTXVzdGFjaGVDb21tZW50U3RhdGVtZW50W10pIHx8IFtdLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbiB8fCBbXSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRBdHRyKFxuICBuYW1lOiBzdHJpbmcsXG4gIHZhbHVlOiBBU1R2MS5BdHRyTm9kZVsndmFsdWUnXSxcbiAgbG9jPzogU291cmNlTG9jYXRpb25cbik6IEFTVHYxLkF0dHJOb2RlIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQXR0ck5vZGUnLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFRleHQoY2hhcnM/OiBzdHJpbmcsIGxvYz86IFNvdXJjZUxvY2F0aW9uKTogQVNUdjEuVGV4dE5vZGUge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdUZXh0Tm9kZScsXG4gICAgY2hhcnM6IGNoYXJzIHx8ICcnLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG4vLyBFeHByZXNzaW9uc1xuXG5mdW5jdGlvbiBidWlsZFNleHByKFxuICBwYXRoOiBCdWlsZGVySGVhZCxcbiAgcGFyYW1zPzogQVNUdjEuRXhwcmVzc2lvbltdLFxuICBoYXNoPzogQVNUdjEuSGFzaCxcbiAgbG9jPzogU291cmNlTG9jYXRpb25cbik6IEFTVHYxLlN1YkV4cHJlc3Npb24ge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdTdWJFeHByZXNzaW9uJyxcbiAgICBwYXRoOiBidWlsZFBhdGgocGF0aCksXG4gICAgcGFyYW1zOiBwYXJhbXMgfHwgW10sXG4gICAgaGFzaDogaGFzaCB8fCBidWlsZEhhc2goW10pLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBoZWFkVG9TdHJpbmcoaGVhZDogQVNUdjEuUGF0aEhlYWQpOiB7IG9yaWdpbmFsOiBzdHJpbmc7IHBhcnRzOiBzdHJpbmdbXSB9IHtcbiAgc3dpdGNoIChoZWFkLnR5cGUpIHtcbiAgICBjYXNlICdBdEhlYWQnOlxuICAgICAgcmV0dXJuIHsgb3JpZ2luYWw6IGhlYWQubmFtZSwgcGFydHM6IFtoZWFkLm5hbWVdIH07XG4gICAgY2FzZSAnVGhpc0hlYWQnOlxuICAgICAgcmV0dXJuIHsgb3JpZ2luYWw6IGB0aGlzYCwgcGFydHM6IFtdIH07XG4gICAgY2FzZSAnVmFySGVhZCc6XG4gICAgICByZXR1cm4geyBvcmlnaW5hbDogaGVhZC5uYW1lLCBwYXJ0czogW2hlYWQubmFtZV0gfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEhlYWQoXG4gIG9yaWdpbmFsOiBzdHJpbmcsXG4gIGxvYzogU291cmNlTG9jYXRpb25cbik6IHsgaGVhZDogQVNUdjEuUGF0aEhlYWQ7IHRhaWw6IHN0cmluZ1tdIH0ge1xuICBsZXQgW2hlYWQsIC4uLnRhaWxdID0gb3JpZ2luYWwuc3BsaXQoJy4nKTtcbiAgbGV0IGhlYWROb2RlOiBBU1R2MS5QYXRoSGVhZDtcblxuICBpZiAoaGVhZCA9PT0gJ3RoaXMnKSB7XG4gICAgaGVhZE5vZGUgPSB7XG4gICAgICB0eXBlOiAnVGhpc0hlYWQnLFxuICAgICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gICAgfTtcbiAgfSBlbHNlIGlmIChoZWFkWzBdID09PSAnQCcpIHtcbiAgICBoZWFkTm9kZSA9IHtcbiAgICAgIHR5cGU6ICdBdEhlYWQnLFxuICAgICAgbmFtZTogaGVhZCxcbiAgICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaGVhZE5vZGUgPSB7XG4gICAgICB0eXBlOiAnVmFySGVhZCcsXG4gICAgICBuYW1lOiBoZWFkLFxuICAgICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaGVhZDogaGVhZE5vZGUsXG4gICAgdGFpbCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRUaGlzKGxvYzogU291cmNlTG9jYXRpb24pOiBBU1R2MS5QYXRoSGVhZCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1RoaXNIZWFkJyxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRBdE5hbWUobmFtZTogc3RyaW5nLCBsb2M6IFNvdXJjZUxvY2F0aW9uKTogQVNUdjEuUGF0aEhlYWQge1xuICAvLyB0aGUgYEBgIHNob3VsZCBiZSBpbmNsdWRlZCBzbyB3ZSBoYXZlIGEgY29tcGxldGUgc291cmNlIHJhbmdlXG4gIGFzc2VydChuYW1lWzBdID09PSAnQCcsIGBjYWxsIGJ1aWxkZXJzLmF0KCkgd2l0aCBhIHN0cmluZyB0aGF0IHN0YXJ0cyB3aXRoICdAJ2ApO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0F0SGVhZCcsXG4gICAgbmFtZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRWYXIobmFtZTogc3RyaW5nLCBsb2M6IFNvdXJjZUxvY2F0aW9uKTogQVNUdjEuUGF0aEhlYWQge1xuICBhc3NlcnQobmFtZSAhPT0gJ3RoaXMnLCBgWW91IGNhbGxlZCBidWlsZGVycy52YXIoKSB3aXRoICd0aGlzJy4gQ2FsbCBidWlsZGVycy50aGlzIGluc3RlYWRgKTtcbiAgYXNzZXJ0KFxuICAgIG5hbWVbMF0gIT09ICdAJyxcbiAgICBgWW91IGNhbGxlZCBidWlsZGVycy52YXIoKSB3aXRoICcke25hbWV9Jy4gQ2FsbCBidWlsZGVycy5hdCgnJHtuYW1lfScpIGluc3RlYWRgXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnVmFySGVhZCcsXG4gICAgbmFtZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRIZWFkRnJvbVN0cmluZyhoZWFkOiBzdHJpbmcsIGxvYzogU291cmNlTG9jYXRpb24pOiBBU1R2MS5QYXRoSGVhZCB7XG4gIGlmIChoZWFkWzBdID09PSAnQCcpIHtcbiAgICByZXR1cm4gYnVpbGRBdE5hbWUoaGVhZCwgbG9jKTtcbiAgfSBlbHNlIGlmIChoZWFkID09PSAndGhpcycpIHtcbiAgICByZXR1cm4gYnVpbGRUaGlzKGxvYyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1aWxkVmFyKGhlYWQsIGxvYyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGROYW1lZEJsb2NrTmFtZShuYW1lOiBzdHJpbmcsIGxvYz86IFNvdXJjZUxvY2F0aW9uKTogQVNUdjEuTmFtZWRCbG9ja05hbWUge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdOYW1lZEJsb2NrTmFtZScsXG4gICAgbmFtZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRDbGVhblBhdGgoXG4gIGhlYWQ6IEFTVHYxLlBhdGhIZWFkLFxuICB0YWlsOiBzdHJpbmdbXSxcbiAgbG9jOiBTb3VyY2VMb2NhdGlvblxuKTogQVNUdjEuUGF0aEV4cHJlc3Npb24ge1xuICBsZXQgeyBvcmlnaW5hbDogb3JpZ2luYWxIZWFkLCBwYXJ0czogaGVhZFBhcnRzIH0gPSBoZWFkVG9TdHJpbmcoaGVhZCk7XG4gIGxldCBwYXJ0cyA9IFsuLi5oZWFkUGFydHMsIC4uLnRhaWxdO1xuICBsZXQgb3JpZ2luYWwgPSBbLi4ub3JpZ2luYWxIZWFkLCAuLi5wYXJ0c10uam9pbignLicpO1xuXG4gIHJldHVybiBuZXcgUGF0aEV4cHJlc3Npb25JbXBsVjEob3JpZ2luYWwsIGhlYWQsIHRhaWwsIGJ1aWxkTG9jKGxvYyB8fCBudWxsKSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aChcbiAgcGF0aDogQVNUdjEuUGF0aEV4cHJlc3Npb24gfCBzdHJpbmcgfCB7IGhlYWQ6IHN0cmluZzsgdGFpbDogc3RyaW5nW10gfSxcbiAgbG9jPzogU291cmNlTG9jYXRpb25cbik6IEFTVHYxLlBhdGhFeHByZXNzaW9uO1xuZnVuY3Rpb24gYnVpbGRQYXRoKHBhdGg6IEFTVHYxLkV4cHJlc3Npb24sIGxvYz86IFNvdXJjZUxvY2F0aW9uKTogQVNUdjEuRXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGJ1aWxkUGF0aChwYXRoOiBCdWlsZGVySGVhZCB8IEFTVHYxLkV4cHJlc3Npb24sIGxvYz86IFNvdXJjZUxvY2F0aW9uKTogQVNUdjEuRXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGJ1aWxkUGF0aChcbiAgcGF0aDogQnVpbGRlckhlYWQgfCBBU1R2MS5FeHByZXNzaW9uIHwgeyBoZWFkOiBzdHJpbmc7IHRhaWw6IHN0cmluZ1tdIH0sXG4gIGxvYz86IFNvdXJjZUxvY2F0aW9uXG4pOiBBU1R2MS5FeHByZXNzaW9uIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIGlmICgndHlwZScgaW4gcGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB7IGhlYWQsIHRhaWwgfSA9IGJ1aWxkSGVhZChwYXRoLmhlYWQsIFNvdXJjZVNwYW4uYnJva2VuKCkpO1xuXG4gICAgICBhc3NlcnQoXG4gICAgICAgIHRhaWwubGVuZ3RoID09PSAwLFxuICAgICAgICBgYnVpbGRlci5wYXRoKHsgaGVhZCwgdGFpbCB9KSBzaG91bGQgbm90IGJlIGNhbGxlZCB3aXRoIGEgaGVhZCB3aXRoIGRvdHMgaW4gaXRgXG4gICAgICApO1xuXG4gICAgICBsZXQgeyBvcmlnaW5hbDogb3JpZ2luYWxIZWFkIH0gPSBoZWFkVG9TdHJpbmcoaGVhZCk7XG5cbiAgICAgIHJldHVybiBuZXcgUGF0aEV4cHJlc3Npb25JbXBsVjEoXG4gICAgICAgIFtvcmlnaW5hbEhlYWQsIC4uLnRhaWxdLmpvaW4oJy4nKSxcbiAgICAgICAgaGVhZCxcbiAgICAgICAgdGFpbCxcbiAgICAgICAgYnVpbGRMb2MobG9jIHx8IG51bGwpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGxldCB7IGhlYWQsIHRhaWwgfSA9IGJ1aWxkSGVhZChwYXRoLCBTb3VyY2VTcGFuLmJyb2tlbigpKTtcblxuICByZXR1cm4gbmV3IFBhdGhFeHByZXNzaW9uSW1wbFYxKHBhdGgsIGhlYWQsIHRhaWwsIGJ1aWxkTG9jKGxvYyB8fCBudWxsKSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGl0ZXJhbDxUIGV4dGVuZHMgQVNUdjEuTGl0ZXJhbD4oXG4gIHR5cGU6IFRbJ3R5cGUnXSxcbiAgdmFsdWU6IFRbJ3ZhbHVlJ10sXG4gIGxvYz86IFNvdXJjZUxvY2F0aW9uXG4pOiBUIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHZhbHVlLFxuICAgIG9yaWdpbmFsOiB2YWx1ZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfSBhcyBUO1xufVxuXG4vLyBNaXNjZWxsYW5lb3VzXG5cbmZ1bmN0aW9uIGJ1aWxkSGFzaChwYWlycz86IEFTVHYxLkhhc2hQYWlyW10sIGxvYz86IFNvdXJjZUxvY2F0aW9uKTogQVNUdjEuSGFzaCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0hhc2gnLFxuICAgIHBhaXJzOiBwYWlycyB8fCBbXSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRQYWlyKGtleTogc3RyaW5nLCB2YWx1ZTogQVNUdjEuRXhwcmVzc2lvbiwgbG9jPzogU291cmNlTG9jYXRpb24pOiBBU1R2MS5IYXNoUGFpciB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0hhc2hQYWlyJyxcbiAgICBrZXk6IGtleSxcbiAgICB2YWx1ZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRQcm9ncmFtKFxuICBib2R5PzogQVNUdjEuU3RhdGVtZW50W10sXG4gIGJsb2NrUGFyYW1zPzogc3RyaW5nW10sXG4gIGxvYz86IFNvdXJjZUxvY2F0aW9uXG4pOiBBU1R2MS5UZW1wbGF0ZSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1RlbXBsYXRlJyxcbiAgICBib2R5OiBib2R5IHx8IFtdLFxuICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyB8fCBbXSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRCbG9ja0l0c2VsZihcbiAgYm9keT86IEFTVHYxLlN0YXRlbWVudFtdLFxuICBibG9ja1BhcmFtcz86IHN0cmluZ1tdLFxuICBjaGFpbmVkID0gZmFsc2UsXG4gIGxvYz86IFNvdXJjZUxvY2F0aW9uXG4pOiBBU1R2MS5CbG9jayB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0Jsb2NrJyxcbiAgICBib2R5OiBib2R5IHx8IFtdLFxuICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyB8fCBbXSxcbiAgICBjaGFpbmVkLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFRlbXBsYXRlKFxuICBib2R5PzogQVNUdjEuU3RhdGVtZW50W10sXG4gIGJsb2NrUGFyYW1zPzogc3RyaW5nW10sXG4gIGxvYz86IFNvdXJjZUxvY2F0aW9uXG4pOiBBU1R2MS5UZW1wbGF0ZSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1RlbXBsYXRlJyxcbiAgICBib2R5OiBib2R5IHx8IFtdLFxuICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyB8fCBbXSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRQb3NpdGlvbihsaW5lOiBudW1iZXIsIGNvbHVtbjogbnVtYmVyKTogU291cmNlUG9zaXRpb24ge1xuICByZXR1cm4ge1xuICAgIGxpbmUsXG4gICAgY29sdW1uLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZExvYyhsb2M6IE9wdGlvbjxTb3VyY2VMb2NhdGlvbj4pOiBTb3VyY2VTcGFuO1xuZnVuY3Rpb24gYnVpbGRMb2MoXG4gIHN0YXJ0TGluZTogbnVtYmVyLFxuICBzdGFydENvbHVtbjogbnVtYmVyLFxuICBlbmRMaW5lPzogbnVtYmVyLFxuICBlbmRDb2x1bW4/OiBudW1iZXIsXG4gIHNvdXJjZT86IHN0cmluZ1xuKTogU291cmNlU3BhbjtcblxuZnVuY3Rpb24gYnVpbGRMb2MoLi4uYXJnczogYW55W10pOiBTb3VyY2VTcGFuIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgbGV0IGxvYyA9IGFyZ3NbMF07XG5cbiAgICBpZiAobG9jICYmIHR5cGVvZiBsb2MgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gU291cmNlU3Bhbi5mb3JIYnNMb2MoU09VUkNFKCksIGxvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBTb3VyY2VTcGFuLmZvckhic0xvYyhTT1VSQ0UoKSwgU1lOVEhFVElDX0xPQ0FUSU9OKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IFtzdGFydExpbmUsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4sIF9zb3VyY2VdID0gYXJncztcbiAgICBsZXQgc291cmNlID0gX3NvdXJjZSA/IG5ldyBTb3VyY2UoJycsIF9zb3VyY2UpIDogU09VUkNFKCk7XG5cbiAgICByZXR1cm4gU291cmNlU3Bhbi5mb3JIYnNMb2Moc291cmNlLCB7XG4gICAgICBzdGFydDoge1xuICAgICAgICBsaW5lOiBzdGFydExpbmUsXG4gICAgICAgIGNvbHVtbjogc3RhcnRDb2x1bW4sXG4gICAgICB9LFxuICAgICAgZW5kOiB7XG4gICAgICAgIGxpbmU6IGVuZExpbmUsXG4gICAgICAgIGNvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG11c3RhY2hlOiBidWlsZE11c3RhY2hlLFxuICBibG9jazogYnVpbGRCbG9jayxcbiAgcGFydGlhbDogYnVpbGRQYXJ0aWFsLFxuICBjb21tZW50OiBidWlsZENvbW1lbnQsXG4gIG11c3RhY2hlQ29tbWVudDogYnVpbGRNdXN0YWNoZUNvbW1lbnQsXG4gIGVsZW1lbnQ6IGJ1aWxkRWxlbWVudCxcbiAgZWxlbWVudE1vZGlmaWVyOiBidWlsZEVsZW1lbnRNb2RpZmllcixcbiAgYXR0cjogYnVpbGRBdHRyLFxuICB0ZXh0OiBidWlsZFRleHQsXG4gIHNleHByOiBidWlsZFNleHByLFxuXG4gIGNvbmNhdDogYnVpbGRDb25jYXQsXG4gIGhhc2g6IGJ1aWxkSGFzaCxcbiAgcGFpcjogYnVpbGRQYWlyLFxuICBsaXRlcmFsOiBidWlsZExpdGVyYWwsXG4gIHByb2dyYW06IGJ1aWxkUHJvZ3JhbSxcbiAgYmxvY2tJdHNlbGY6IGJ1aWxkQmxvY2tJdHNlbGYsXG4gIHRlbXBsYXRlOiBidWlsZFRlbXBsYXRlLFxuICBsb2M6IGJ1aWxkTG9jLFxuICBwb3M6IGJ1aWxkUG9zaXRpb24sXG5cbiAgcGF0aDogYnVpbGRQYXRoLFxuXG4gIGZ1bGxQYXRoOiBidWlsZENsZWFuUGF0aCxcbiAgaGVhZDogYnVpbGRIZWFkRnJvbVN0cmluZyxcbiAgYXQ6IGJ1aWxkQXROYW1lLFxuICB2YXI6IGJ1aWxkVmFyLFxuICB0aGlzOiBidWlsZFRoaXMsXG4gIGJsb2NrTmFtZTogYnVpbGROYW1lZEJsb2NrTmFtZSxcblxuICBzdHJpbmc6IGxpdGVyYWwoJ1N0cmluZ0xpdGVyYWwnKSBhcyAodmFsdWU6IHN0cmluZykgPT4gQVNUdjEuU3RyaW5nTGl0ZXJhbCxcbiAgYm9vbGVhbjogbGl0ZXJhbCgnQm9vbGVhbkxpdGVyYWwnKSBhcyAodmFsdWU6IGJvb2xlYW4pID0+IEFTVHYxLkJvb2xlYW5MaXRlcmFsLFxuICBudW1iZXI6IGxpdGVyYWwoJ051bWJlckxpdGVyYWwnKSBhcyAodmFsdWU6IG51bWJlcikgPT4gQVNUdjEuTnVtYmVyTGl0ZXJhbCxcbiAgdW5kZWZpbmVkKCk6IEFTVHYxLlVuZGVmaW5lZExpdGVyYWwge1xuICAgIHJldHVybiBidWlsZExpdGVyYWwoJ1VuZGVmaW5lZExpdGVyYWwnLCB1bmRlZmluZWQpO1xuICB9LFxuICBudWxsKCk6IEFTVHYxLk51bGxMaXRlcmFsIHtcbiAgICByZXR1cm4gYnVpbGRMaXRlcmFsKCdOdWxsTGl0ZXJhbCcsIG51bGwpO1xuICB9LFxufTtcblxudHlwZSBCdWlsZExpdGVyYWw8VCBleHRlbmRzIEFTVHYxLkxpdGVyYWw+ID0gKHZhbHVlOiBUWyd2YWx1ZSddKSA9PiBUO1xuXG5mdW5jdGlvbiBsaXRlcmFsPFQgZXh0ZW5kcyBBU1R2MS5MaXRlcmFsPih0eXBlOiBUWyd0eXBlJ10pOiBCdWlsZExpdGVyYWw8VD4ge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlOiBUWyd2YWx1ZSddLCBsb2M/OiBTb3VyY2VMb2NhdGlvbik6IFQge1xuICAgIHJldHVybiBidWlsZExpdGVyYWwodHlwZSwgdmFsdWUsIGxvYyk7XG4gIH07XG59XG4iLCIvKipcbiAqIEEgZnJlZSB2YXJpYWJsZSBpcyByZXNvbHZlZCBhY2NvcmRpbmcgdG8gYSByZXNvbHV0aW9uIHJ1bGU6XG4gKlxuICogMS4gU3RyaWN0IHJlc29sdXRpb25cbiAqIDIuIE5hbWVzcGFjZWQgcmVzb2x1dGlvblxuICogMy4gRmFsbGJhY2sgcmVzb2x1dGlvblxuICovXG5cbmltcG9ydCB7IEdldENvbnRleHR1YWxGcmVlT3AsIFNleHBPcGNvZGVzIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbi8qKlxuICogU3RyaWN0IHJlc29sdXRpb24gaXMgdXNlZDpcbiAqXG4gKiAxLiBpbiBhIHN0cmljdCBtb2RlIHRlbXBsYXRlXG4gKiAyLiBpbiBhbiB1bmFtYmlndW91cyBpbnZvY2F0aW9uIHdpdGggZG90IHBhdGhzXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJpY3RSZXNvbHV0aW9uIHtcbiAgcmVzb2x1dGlvbigpOiBHZXRDb250ZXh0dWFsRnJlZU9wIHtcbiAgICByZXR1cm4gU2V4cE9wY29kZXMuR2V0U3RyaWN0RnJlZTtcbiAgfVxuXG4gIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemVkUmVzb2x1dGlvbiB7XG4gICAgcmV0dXJuICdTdHJpY3QnO1xuICB9XG5cbiAgcmVhZG9ubHkgaXNBbmdsZUJyYWNrZXQgPSBmYWxzZTtcbn1cblxuZXhwb3J0IGNvbnN0IFNUUklDVF9SRVNPTFVUSU9OID0gbmV3IFN0cmljdFJlc29sdXRpb24oKTtcblxuLyoqXG4gKiBBIGBMb29zZU1vZGVSZXNvbHV0aW9uYCBpbmNsdWRlczpcbiAqXG4gKiAtIDAgb3IgbW9yZSBuYW1lc3BhY2VzIHRvIHJlc29sdmUgdGhlIHZhcmlhYmxlIGluXG4gKiAtIG9wdGlvbmFsIGZhbGxiYWNrIGJlaGF2aW9yXG4gKlxuICogSW4gcHJhY3RpY2UsIHRoZXJlIGFyZSBhIGxpbWl0ZWQgbnVtYmVyIG9mIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBvZiB0aGVzZSBkZWdyZWVzIG9mIGZyZWVkb20sXG4gKiBhbmQgdGhleSBhcmUgY2FwdHVyZWQgYnkgdGhlIGBBbWJpZ3VpdHlgIHVuaW9uIGJlbG93LlxuICovXG5leHBvcnQgY2xhc3MgTG9vc2VNb2RlUmVzb2x1dGlvbiB7XG4gIC8qKlxuICAgKiBOYW1lc3BhY2VkIHJlc29sdXRpb24gaXMgdXNlZCBpbiBhbiB1bmFtYmlndW91cyBzeW50YXggcG9zaXRpb246XG4gICAqXG4gICAqIDEuIGAoc2V4cClgIChuYW1lc3BhY2U6IGBIZWxwZXJgKVxuICAgKiAyLiBge3sjYmxvY2t9fWAgKG5hbWVzcGFjZTogYENvbXBvbmVudGApXG4gICAqIDMuIGA8YSB7e21vZGlmaWVyfX0+YCAobmFtZXNwYWNlOiBgTW9kaWZpZXJgKVxuICAgKiA0LiBgPENvbXBvbmVudCAvPmAgKG5hbWVzcGFjZTogYENvbXBvbmVudGApXG4gICAqXG4gICAqIEBzZWUge05hbWVzcGFjZWRBbWJpZ3VpdHl9XG4gICAqL1xuICBzdGF0aWMgbmFtZXNwYWNlZChuYW1lc3BhY2U6IEZyZWVWYXJOYW1lc3BhY2UsIGlzQW5nbGVCcmFja2V0ID0gZmFsc2UpOiBMb29zZU1vZGVSZXNvbHV0aW9uIHtcbiAgICByZXR1cm4gbmV3IExvb3NlTW9kZVJlc29sdXRpb24oXG4gICAgICB7XG4gICAgICAgIG5hbWVzcGFjZXM6IFtuYW1lc3BhY2VdLFxuICAgICAgICBmYWxsYmFjazogZmFsc2UsXG4gICAgICB9LFxuICAgICAgaXNBbmdsZUJyYWNrZXRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhbGxiYWNrIHJlc29sdXRpb24gaXMgdXNlZCB3aGVuIG5vIG5hbWVzcGFjZWQgcmVzb2x1dGlvbnMgYXJlIHBvc3NpYmxlLCBidXQgZmFsbGJhY2tcbiAgICogcmVzb2x1dGlvbiBpcyBzdGlsbCBhbGxvd2VkLlxuICAgKlxuICAgKiBgYGBoYnNcbiAgICoge3t4Lnl9fVxuICAgKiBgYGBcbiAgICpcbiAgICogQHNlZSB7RmFsbGJhY2tBbWJpZ3VpdHl9XG4gICAqL1xuICBzdGF0aWMgZmFsbGJhY2soKTogTG9vc2VNb2RlUmVzb2x1dGlvbiB7XG4gICAgcmV0dXJuIG5ldyBMb29zZU1vZGVSZXNvbHV0aW9uKHsgbmFtZXNwYWNlczogW10sIGZhbGxiYWNrOiB0cnVlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCByZXNvbHV0aW9uIGlzIHVzZWQgd2hlbiB0aGUgdmFyaWFibGUgc2hvdWxkIGJlIHJlc29sdmVkIGluIGJvdGggdGhlIGBjb21wb25lbnRgIGFuZFxuICAgKiBgaGVscGVyYCBuYW1lc3BhY2VzLiBGYWxsYmFjayByZXNvbHV0aW9uIGlzIG9wdGlvbmFsLlxuICAgKlxuICAgKiBgYGBoYnNcbiAgICoge3t4fX1cbiAgICogYGBgXG4gICAqXG4gICAqIF4gYHhgIHNob3VsZCBiZSByZXNvbHZlZCBpbiB0aGUgYGNvbXBvbmVudGAgYW5kIGBoZWxwZXJgIG5hbWVzcGFjZXMgd2l0aCBmYWxsYmFjayByZXNvbHV0aW9uLlxuICAgKlxuICAgKiBgYGBoYnNcbiAgICoge3t4IHl9fVxuICAgKiBgYGBcbiAgICpcbiAgICogXiBgeGAgc2hvdWxkIGJlIHJlc29sdmVkIGluIHRoZSBgY29tcG9uZW50YCBhbmQgYGhlbHBlcmAgbmFtZXNwYWNlcyB3aXRob3V0IGZhbGxiYWNrXG4gICAqIHJlc29sdXRpb24uXG4gICAqXG4gICAqIEBzZWUge0NvbXBvbmVudE9ySGVscGVyQW1iaWd1aXR5fVxuICAgKi9cbiAgc3RhdGljIGFwcGVuZCh7IGludm9rZSB9OiB7IGludm9rZTogYm9vbGVhbiB9KTogTG9vc2VNb2RlUmVzb2x1dGlvbiB7XG4gICAgcmV0dXJuIG5ldyBMb29zZU1vZGVSZXNvbHV0aW9uKHtcbiAgICAgIG5hbWVzcGFjZXM6IFtGcmVlVmFyTmFtZXNwYWNlLkNvbXBvbmVudCwgRnJlZVZhck5hbWVzcGFjZS5IZWxwZXJdLFxuICAgICAgZmFsbGJhY2s6ICFpbnZva2UsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVHJ1c3RpbmcgYXBwZW5kIHJlc29sdXRpb24gaXMgdXNlZCB3aGVuIHRoZSB2YXJpYWJsZSBzaG91bGQgYmUgcmVzb2x2ZWQgaW4gYm90aCB0aGUgYGNvbXBvbmVudGAgYW5kXG4gICAqIGBoZWxwZXJgIG5hbWVzcGFjZXMuIEZhbGxiYWNrIHJlc29sdXRpb24gaXMgb3B0aW9uYWwuXG4gICAqXG4gICAqIGBgYGhic1xuICAgKiB7e3t4fX19XG4gICAqIGBgYFxuICAgKlxuICAgKiBeIGB4YCBzaG91bGQgYmUgcmVzb2x2ZWQgaW4gdGhlIGBjb21wb25lbnRgIGFuZCBgaGVscGVyYCBuYW1lc3BhY2VzIHdpdGggZmFsbGJhY2sgcmVzb2x1dGlvbi5cbiAgICpcbiAgICogYGBgaGJzXG4gICAqIHt7e3ggeX19fVxuICAgKiBgYGBcbiAgICpcbiAgICogXiBgeGAgc2hvdWxkIGJlIHJlc29sdmVkIGluIHRoZSBgY29tcG9uZW50YCBhbmQgYGhlbHBlcmAgbmFtZXNwYWNlcyB3aXRob3V0IGZhbGxiYWNrXG4gICAqIHJlc29sdXRpb24uXG4gICAqXG4gICAqIEBzZWUge0hlbHBlckFtYmlndWl0eX1cbiAgICovXG4gIHN0YXRpYyB0cnVzdGluZ0FwcGVuZCh7IGludm9rZSB9OiB7IGludm9rZTogYm9vbGVhbiB9KTogTG9vc2VNb2RlUmVzb2x1dGlvbiB7XG4gICAgcmV0dXJuIG5ldyBMb29zZU1vZGVSZXNvbHV0aW9uKHtcbiAgICAgIG5hbWVzcGFjZXM6IFtGcmVlVmFyTmFtZXNwYWNlLkhlbHBlcl0sXG4gICAgICBmYWxsYmFjazogIWludm9rZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRyaWJ1dGUgcmVzb2x1dGlvbiBpcyB1c2VkIHdoZW4gdGhlIHZhcmlhYmxlIHNob3VsZCBiZSByZXNvbHZlZCBhcyBhIGBoZWxwZXJgIHdpdGggZmFsbGJhY2tcbiAgICogcmVzb2x1dGlvbi5cbiAgICpcbiAgICogYGBgaGJzXG4gICAqIDxhIGhyZWY9e3t4fX0gLz5cbiAgICogPGEgaHJlZj1cInt7eH19Lmh0bWxcIiAvPlxuICAgKiBgYGBcbiAgICpcbiAgICogXiByZXNvbHZlZCBpbiB0aGUgYGhlbHBlcmAgbmFtZXNwYWNlIHdpdGggZmFsbGJhY2tcbiAgICpcbiAgICogQHNlZSB7SGVscGVyQW1iaWd1aXR5fVxuICAgKi9cbiAgc3RhdGljIGF0dHIoKTogTG9vc2VNb2RlUmVzb2x1dGlvbiB7XG4gICAgcmV0dXJuIG5ldyBMb29zZU1vZGVSZXNvbHV0aW9uKHsgbmFtZXNwYWNlczogW0ZyZWVWYXJOYW1lc3BhY2UuSGVscGVyXSwgZmFsbGJhY2s6IHRydWUgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihyZWFkb25seSBhbWJpZ3VpdHk6IEFtYmlndWl0eSwgcmVhZG9ubHkgaXNBbmdsZUJyYWNrZXQgPSBmYWxzZSkge31cblxuICByZXNvbHV0aW9uKCk6IEdldENvbnRleHR1YWxGcmVlT3Age1xuICAgIGlmICh0aGlzLmFtYmlndWl0eS5uYW1lc3BhY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFNleHBPcGNvZGVzLkdldEZyZWVBc0ZhbGxiYWNrO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hbWJpZ3VpdHkubmFtZXNwYWNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0aGlzLmFtYmlndWl0eS5mYWxsYmFjaykge1xuICAgICAgICAvLyBzaW1wbGUgbmFtZXNwYWNlZCByZXNvbHV0aW9uIHdpdGggZmFsbGJhY2sgbXVzdCBiZSBhdHRyPXt7eH19XG4gICAgICAgIHJldHVybiBTZXhwT3Bjb2Rlcy5HZXRGcmVlQXNIZWxwZXJIZWFkT3JUaGlzRmFsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzaW1wbGUgbmFtZXNwYWNlZCByZXNvbHV0aW9uIHdpdGhvdXQgZmFsbGJhY2tcbiAgICAgICAgc3dpdGNoICh0aGlzLmFtYmlndWl0eS5uYW1lc3BhY2VzWzBdKSB7XG4gICAgICAgICAgY2FzZSBGcmVlVmFyTmFtZXNwYWNlLkhlbHBlcjpcbiAgICAgICAgICAgIHJldHVybiBTZXhwT3Bjb2Rlcy5HZXRGcmVlQXNIZWxwZXJIZWFkO1xuICAgICAgICAgIGNhc2UgRnJlZVZhck5hbWVzcGFjZS5Nb2RpZmllcjpcbiAgICAgICAgICAgIHJldHVybiBTZXhwT3Bjb2Rlcy5HZXRGcmVlQXNNb2RpZmllckhlYWQ7XG4gICAgICAgICAgY2FzZSBGcmVlVmFyTmFtZXNwYWNlLkNvbXBvbmVudDpcbiAgICAgICAgICAgIHJldHVybiBTZXhwT3Bjb2Rlcy5HZXRGcmVlQXNDb21wb25lbnRIZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmFtYmlndWl0eS5mYWxsYmFjaykge1xuICAgICAgLy8gY29tcG9uZW50IG9yIGhlbHBlciArIGZhbGxiYWNrICh7e3NvbWV0aGluZ319KVxuICAgICAgcmV0dXJuIFNleHBPcGNvZGVzLkdldEZyZWVBc0NvbXBvbmVudE9ySGVscGVySGVhZE9yVGhpc0ZhbGxiYWNrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wb25lbnQgb3IgaGVscGVyIHdpdGhvdXQgZmFsbGJhY2sgKHt7c29tZXRoaW5nIHNvbWV0aGluZ319KVxuICAgICAgcmV0dXJuIFNleHBPcGNvZGVzLkdldEZyZWVBc0NvbXBvbmVudE9ySGVscGVySGVhZDtcbiAgICB9XG4gIH1cblxuICBzZXJpYWxpemUoKTogU2VyaWFsaXplZFJlc29sdXRpb24ge1xuICAgIGlmICh0aGlzLmFtYmlndWl0eS5uYW1lc3BhY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICdMb29zZSc7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFtYmlndWl0eS5uYW1lc3BhY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHRoaXMuYW1iaWd1aXR5LmZhbGxiYWNrKSB7XG4gICAgICAgIC8vIHNpbXBsZSBuYW1lc3BhY2VkIHJlc29sdXRpb24gd2l0aCBmYWxsYmFjayBtdXN0IGJlIGF0dHI9e3t4fX1cbiAgICAgICAgcmV0dXJuIFsnYW1iaWd1b3VzJywgU2VyaWFsaXplZEFtYmlndWl0eS5BdHRyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbJ25zJywgdGhpcy5hbWJpZ3VpdHkubmFtZXNwYWNlc1swXV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmFtYmlndWl0eS5mYWxsYmFjaykge1xuICAgICAgLy8gY29tcG9uZW50IG9yIGhlbHBlciArIGZhbGxiYWNrICh7e3NvbWV0aGluZ319KVxuICAgICAgcmV0dXJuIFsnYW1iaWd1b3VzJywgU2VyaWFsaXplZEFtYmlndWl0eS5BcHBlbmRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wb25lbnQgb3IgaGVscGVyIHdpdGhvdXQgZmFsbGJhY2sgKHt7c29tZXRoaW5nIHNvbWV0aGluZ319KVxuICAgICAgcmV0dXJuIFsnYW1iaWd1b3VzJywgU2VyaWFsaXplZEFtYmlndWl0eS5JbnZva2VdO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQVJHVU1FTlRfUkVTT0xVVElPTiA9IExvb3NlTW9kZVJlc29sdXRpb24uZmFsbGJhY2soKTtcblxuZXhwb3J0IGNvbnN0IGVudW0gRnJlZVZhck5hbWVzcGFjZSB7XG4gIEhlbHBlciA9ICdIZWxwZXInLFxuICBNb2RpZmllciA9ICdNb2RpZmllcicsXG4gIENvbXBvbmVudCA9ICdDb21wb25lbnQnLFxufVxuXG4vKipcbiAqIEEgYENvbXBvbmVudE9ySGVscGVyQW1iaWd1aXR5YCBtaWdodCBiZSBhIGNvbXBvbmVudCBvciBhIGhlbHBlciwgd2l0aCBhbiBvcHRpb25hbCBmYWxsYmFja1xuICpcbiAqIGBgYGhic1xuICoge3t4fX1cbiAqIGBgYFxuICpcbiAqIF4gYHhgIGlzIHJlc29sdmVkIGluIHRoZSBgY29tcG9uZW50YCBhbmQgYGhlbHBlcmAgbmFtZXNwYWNlcywgd2l0aCBmYWxsYmFja1xuICpcbiAqIGBgYGhic1xuICoge3t4IHl9fVxuICogYGBgXG4gKlxuICogXiBgeGAgaXMgcmVzb2x2ZWQgaW4gdGhlIGBjb21wb25lbnRgIGFuZCBgaGVscGVyYCBuYW1lc3BhY2VzLCB3aXRob3V0IGZhbGxiYWNrXG4gKi9cbnR5cGUgQ29tcG9uZW50T3JIZWxwZXJBbWJpZ3VpdHkgPSB7XG4gIG5hbWVzcGFjZXM6IFtGcmVlVmFyTmFtZXNwYWNlLkNvbXBvbmVudCwgRnJlZVZhck5hbWVzcGFjZS5IZWxwZXJdO1xuICBmYWxsYmFjazogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogQSBgSGVscGVyQW1iaWd1aXR5YCBtdXN0IGJlIGEgaGVscGVyLCBidXQgaXQgaGFzIGZhbGxiYWNrLiBJZiBpdCBkaWRuJ3QgaGF2ZSBmYWxsYmFjaywgaXQgd291bGRcbiAqIGJlIGEgYE5hbWVzcGFjZWRBbWJpZ3VpdHlgLlxuICpcbiAqIGBgYGhic1xuICogPGEgaHJlZj17e3h9fSAvPlxuICogPGEgaHJlZj1cInt7eH19Lmh0bWxcIiAvPlxuICogYGBgXG4gKlxuICogXiBgeGAgaXMgcmVzb2x2ZWQgaW4gdGhlIGBoZWxwZXJgIG5hbWVzcGFjZSB3aXRoIGZhbGxiYWNrXG4gKi9cbnR5cGUgSGVscGVyQW1iaWd1aXR5ID0geyBuYW1lc3BhY2VzOiBbRnJlZVZhck5hbWVzcGFjZS5IZWxwZXJdOyBmYWxsYmFjazogYm9vbGVhbiB9O1xuXG4vKipcbiAqIEEgYE5hbWVzcGFjZWRBbWJpZ3VpdHlgIG11c3QgYmUgcmVzb2x2ZWQgaW4gYSBwYXJ0aWN1bGFyIG5hbWVzcGFjZSwgd2l0aG91dCBmYWxsYmFjay5cbiAqXG4gKiBgYGBoYnNcbiAqIDxYIC8+XG4gKiBgYGBcbiAqXG4gKiBeIGBYYCBpcyByZXNvbHZlZCBpbiB0aGUgYGNvbXBvbmVudGAgbmFtZXNwYWNlIHdpdGhvdXQgZmFsbGJhY2tcbiAqXG4gKiBgYGBoYnNcbiAqICh4KVxuICogYGBgXG4gKlxuICogXiBgeGAgaXMgcmVzb2x2ZWQgaW4gdGhlIGBoZWxwZXJgIG5hbWVzcGFjZSB3aXRob3V0IGZhbGxiYWNrXG4gKlxuICogYGBgaGJzXG4gKiA8YSB7e3h9fSAvPlxuICogYGBgXG4gKlxuICogXiBgeGAgaXMgcmVzb2x2ZWQgaW4gdGhlIGBtb2RpZmllcmAgbmFtZXNwYWNlIHdpdGhvdXQgZmFsbGJhY2tcbiAqL1xudHlwZSBOYW1lc3BhY2VkQW1iaWd1aXR5ID0ge1xuICBuYW1lc3BhY2VzOiBbRnJlZVZhck5hbWVzcGFjZS5Db21wb25lbnQgfCBGcmVlVmFyTmFtZXNwYWNlLkhlbHBlciB8IEZyZWVWYXJOYW1lc3BhY2UuTW9kaWZpZXJdO1xuICBmYWxsYmFjazogZmFsc2U7XG59O1xuXG50eXBlIEZhbGxiYWNrQW1iaWd1aXR5ID0ge1xuICBuYW1lc3BhY2VzOiBbXTtcbiAgZmFsbGJhY2s6IHRydWU7XG59O1xuXG50eXBlIEFtYmlndWl0eSA9XG4gIHwgQ29tcG9uZW50T3JIZWxwZXJBbWJpZ3VpdHlcbiAgfCBIZWxwZXJBbWJpZ3VpdHlcbiAgfCBOYW1lc3BhY2VkQW1iaWd1aXR5XG4gIHwgRmFsbGJhY2tBbWJpZ3VpdHk7XG5cbmV4cG9ydCB0eXBlIEZyZWVWYXJSZXNvbHV0aW9uID0gU3RyaWN0UmVzb2x1dGlvbiB8IExvb3NlTW9kZVJlc29sdXRpb247XG5cbi8vIFNlcmlhbGl6YXRpb25cblxuY29uc3QgZW51bSBTZXJpYWxpemVkQW1iaWd1aXR5IHtcbiAgLy8ge3t4fX1cbiAgQXBwZW5kID0gJ0FwcGVuZCcsXG4gIC8vIGhyZWY9e3t4fX1cbiAgQXR0ciA9ICdBdHRyJyxcbiAgLy8ge3t4IHl9fSAobm90IGF0dHIpXG4gIEludm9rZSA9ICdJbnZva2UnLFxufVxuXG5leHBvcnQgdHlwZSBTZXJpYWxpemVkUmVzb2x1dGlvbiA9XG4gIHwgJ1N0cmljdCdcbiAgfCAnTG9vc2UnXG4gIHwgWyducycsIEZyZWVWYXJOYW1lc3BhY2VdXG4gIHwgWydhbWJpZ3VvdXMnLCBTZXJpYWxpemVkQW1iaWd1aXR5XTtcblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRSZXNvbHV0aW9uKHJlc29sdXRpb246IFNlcmlhbGl6ZWRSZXNvbHV0aW9uKTogRnJlZVZhclJlc29sdXRpb24ge1xuICBpZiAodHlwZW9mIHJlc29sdXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgc3dpdGNoIChyZXNvbHV0aW9uKSB7XG4gICAgICBjYXNlICdMb29zZSc6XG4gICAgICAgIHJldHVybiBMb29zZU1vZGVSZXNvbHV0aW9uLmZhbGxiYWNrKCk7XG4gICAgICBjYXNlICdTdHJpY3QnOlxuICAgICAgICByZXR1cm4gU1RSSUNUX1JFU09MVVRJT047XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoIChyZXNvbHV0aW9uWzBdKSB7XG4gICAgY2FzZSAnYW1iaWd1b3VzJzpcbiAgICAgIHN3aXRjaCAocmVzb2x1dGlvblsxXSkge1xuICAgICAgICBjYXNlIFNlcmlhbGl6ZWRBbWJpZ3VpdHkuQXBwZW5kOlxuICAgICAgICAgIHJldHVybiBMb29zZU1vZGVSZXNvbHV0aW9uLmFwcGVuZCh7IGludm9rZTogZmFsc2UgfSk7XG4gICAgICAgIGNhc2UgU2VyaWFsaXplZEFtYmlndWl0eS5BdHRyOlxuICAgICAgICAgIHJldHVybiBMb29zZU1vZGVSZXNvbHV0aW9uLmF0dHIoKTtcbiAgICAgICAgY2FzZSBTZXJpYWxpemVkQW1iaWd1aXR5Lkludm9rZTpcbiAgICAgICAgICByZXR1cm4gTG9vc2VNb2RlUmVzb2x1dGlvbi5hcHBlbmQoeyBpbnZva2U6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICBjYXNlICducyc6XG4gICAgICByZXR1cm4gTG9vc2VNb2RlUmVzb2x1dGlvbi5uYW1lc3BhY2VkKHJlc29sdXRpb25bMV0pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBTb3VyY2VTcGFuIH0gZnJvbSAnLi4vLi4vc291cmNlL3NwYW4nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhc2VOb2RlRmllbGRzIHtcbiAgbG9jOiBTb3VyY2VTcGFuO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgQVNUdjIgbm9kZXMsIHdpdGggYW4gb3B0aW9uYWwgbmFtZSBhbmQgdGhlIG5vZGUnc1xuICogb3B0aW9ucy5cbiAqXG4gKiBgYGB0c1xuICogZXhwb3J0IGNsYXNzIEh0bWxUZXh0IGV4dGVuZHMgbm9kZSgnSHRtbFRleHQnKS5maWVsZHM8eyBjaGFyczogc3RyaW5nIH0+KCkge31cbiAqIGBgYFxuICpcbiAqIFRoaXMgY3JlYXRlcyBhIG5ldyBBU1R2MiBub2RlIHdpdGggdGhlIG5hbWUgYCdIdG1sVGV4dCdgIGFuZCBvbmUgZmllbGQgYGNoYXJzOiBzdHJpbmdgIChpblxuICogYWRkaXRpb24gdG8gYSBgbG9jOiBTb3VyY2VPZmZzZXRzYCBmaWVsZCwgd2hpY2ggYWxsIG5vZGVzIGhhdmUpLlxuICpcbiAqIGBgYHRzXG4gKiBleHBvcnQgY2xhc3MgQXJncyBleHRlbmRzIG5vZGUoKS5maWVsZHM8e1xuICogIHBvc2l0aW9uYWw6IFBvc2l0aW9uYWxBcmd1bWVudHM7XG4gKiAgbmFtZWQ6IE5hbWVkQXJndW1lbnRzXG4gKiB9PigpIHt9XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGNyZWF0ZXMgYSBuZXcgdW4tbmFtZWQgQVNUdjIgbm9kZSB3aXRoIHR3byBmaWVsZHMgKGBwb3NpdGlvbmFsOiBQb3NpdGlvbmFsYCBhbmQgYG5hbWVkOlxuICogTmFtZWRgLCBpbiBhZGRpdGlvbiB0byB0aGUgZ2VuZXJpYyBgbG9jOiBTb3VyY2VPZmZzZXRzYCBmaWVsZCkuXG4gKlxuICogT25jZSB5b3UgY3JlYXRlIGEgbm9kZSB1c2luZyBgbm9kZWAsIGl0IGlzIGluc3RhbnRpYXRlZCB3aXRoIGFsbCBvZiBpdHMgZmllbGRzIChpbmNsdWRpbmcgYGxvY2ApOlxuICpcbiAqIGBgYHRzXG4gKiBuZXcgSHRtbFRleHQoeyBsb2M6IG9mZnNldHMsIGNoYXJzOiBzb21lU3RyaW5nIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub2RlKCk6IHtcbiAgZmllbGRzPEZpZWxkcyBleHRlbmRzIG9iamVjdD4oKTogTm9kZUNvbnN0cnVjdG9yPEZpZWxkcyAmIEJhc2VOb2RlRmllbGRzPjtcbn07XG5leHBvcnQgZnVuY3Rpb24gbm9kZTxUIGV4dGVuZHMgc3RyaW5nPihcbiAgbmFtZTogVFxuKToge1xuICBmaWVsZHM8RmllbGRzIGV4dGVuZHMgb2JqZWN0PigpOiBUeXBlZE5vZGVDb25zdHJ1Y3RvcjxULCBGaWVsZHMgJiBCYXNlTm9kZUZpZWxkcz47XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbm9kZTxUIGV4dGVuZHMgc3RyaW5nPihcbiAgbmFtZT86IFRcbik6XG4gIHwge1xuICAgICAgZmllbGRzPEZpZWxkcyBleHRlbmRzIG9iamVjdD4oKTogVHlwZWROb2RlQ29uc3RydWN0b3I8VCwgRmllbGRzICYgQmFzZU5vZGVGaWVsZHM+O1xuICAgIH1cbiAgfCB7XG4gICAgICBmaWVsZHM8RmllbGRzIGV4dGVuZHMgb2JqZWN0PigpOiBOb2RlQ29uc3RydWN0b3I8RmllbGRzICYgQmFzZU5vZGVGaWVsZHM+O1xuICAgIH0ge1xuICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgdHlwZSA9IG5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpZWxkczxGaWVsZHMgZXh0ZW5kcyBvYmplY3Q+KCk6IFR5cGVkTm9kZUNvbnN0cnVjdG9yPFQsIEJhc2VOb2RlRmllbGRzICYgRmllbGRzPiB7XG4gICAgICAgIHJldHVybiBjbGFzcyB7XG4gICAgICAgICAgcmVhZG9ubHkgbG9jOiBTb3VyY2VTcGFuO1xuICAgICAgICAgIHJlYWRvbmx5IHR5cGU6IFQ7XG5cbiAgICAgICAgICBjb25zdHJ1Y3RvcihmaWVsZHM6IEJhc2VOb2RlRmllbGRzICYgRmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgdGhpcy5sb2MgPSBmaWVsZHMubG9jO1xuICAgICAgICAgICAgY29weShmaWVsZHMsICh0aGlzIGFzIHVua25vd24pIGFzIENvbnN0cnVjdGluZ1R5cGVkTm9kZTxGaWVsZHM+KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gYXMgVHlwZWROb2RlQ29uc3RydWN0b3I8VCwgQmFzZU5vZGVGaWVsZHMgJiBGaWVsZHM+O1xuICAgICAgfSxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBmaWVsZHM8RmllbGRzPigpOiBOb2RlQ29uc3RydWN0b3I8RmllbGRzICYgQmFzZU5vZGVGaWVsZHM+IHtcbiAgICAgICAgcmV0dXJuIGNsYXNzIHtcbiAgICAgICAgICByZWFkb25seSBsb2M6IFNvdXJjZVNwYW47XG5cbiAgICAgICAgICBjb25zdHJ1Y3RvcihmaWVsZHM6IEJhc2VOb2RlRmllbGRzICYgRmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLmxvYyA9IGZpZWxkcy5sb2M7XG5cbiAgICAgICAgICAgIGNvcHkoZmllbGRzLCAodGhpcyBhcyB1bmtub3duKSBhcyBDb25zdHJ1Y3RpbmdOb2RlPEZpZWxkcz4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBhcyBOb2RlQ29uc3RydWN0b3I8QmFzZU5vZGVGaWVsZHMgJiBGaWVsZHM+O1xuICAgICAgfSxcbiAgICB9O1xuICB9XG59XG5cbnR5cGUgQ29uc3RydWN0aW5nVHlwZWROb2RlPEZpZWxkcz4gPSBGaWVsZHMgJiBCYXNlTm9kZUZpZWxkcztcblxudHlwZSBDb25zdHJ1Y3RpbmdOb2RlPEZpZWxkcz4gPSBCYXNlTm9kZUZpZWxkcyAmIEZpZWxkcztcblxuZXhwb3J0IGludGVyZmFjZSBOb2RlQ29uc3RydWN0b3I8RmllbGRzPiB7XG4gIG5ldyAoZmllbGRzOiBGaWVsZHMpOiBSZWFkb25seTxGaWVsZHM+O1xufVxuXG50eXBlIFR5cGVkTm9kZTxUIGV4dGVuZHMgc3RyaW5nLCBGaWVsZHM+ID0geyB0eXBlOiBUIH0gJiBSZWFkb25seTxGaWVsZHM+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVkTm9kZUNvbnN0cnVjdG9yPFQgZXh0ZW5kcyBzdHJpbmcsIEZpZWxkcz4ge1xuICBuZXcgKG9wdGlvbnM6IEZpZWxkcyk6IFR5cGVkTm9kZTxULCBGaWVsZHM+O1xufVxuXG5mdW5jdGlvbiBrZXlzPE8gZXh0ZW5kcyBvYmplY3Q+KG9iamVjdDogTyk6IChrZXlvZiBPKVtdIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkgYXMgKGtleW9mIE8pW107XG59XG5cbmZ1bmN0aW9uIGNvcHk8TyBleHRlbmRzIG9iamVjdD4ob2JqZWN0MTogTywgb2JqZWN0MjogTykge1xuICBmb3IgKGxldCBrZXkgb2Yga2V5cyhvYmplY3QxKSkge1xuICAgIG9iamVjdDJba2V5XSA9IG9iamVjdDFba2V5XTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgU291cmNlU2xpY2UgfSBmcm9tICcuLi8uLi9zb3VyY2Uvc2xpY2UnO1xuaW1wb3J0IHsgU291cmNlU3BhbiB9IGZyb20gJy4uLy4uL3NvdXJjZS9zcGFuJztcbmltcG9ydCB0eXBlIHsgRXhwcmVzc2lvbk5vZGUgfSBmcm9tICcuL2V4cHInO1xuaW1wb3J0IHsgbm9kZSB9IGZyb20gJy4vbm9kZSc7XG5cbi8qKlxuICogQ29ycmVzcG9uZHMgdG8gc3ludGF4ZXMgd2l0aCBwb3NpdGlvbmFsIGFuZCBuYW1lZCBhcmd1bWVudHM6XG4gKlxuICogLSBTdWJFeHByZXNzaW9uXG4gKiAtIEludm9raW5nIEFwcGVuZFxuICogLSBJbnZva2luZyBhdHRyaWJ1dGVzXG4gKiAtIEludm9rZUJsb2NrXG4gKlxuICogSWYgYEFyZ3NgIGlzIGVtcHR5LCB0aGUgYFNvdXJjZU9mZnNldHNgIGZvciB0aGlzIG5vZGUgc2hvdWxkIGJlIHRoZSBjb2xsYXBzZWQgcG9zaXRpb25cbiAqIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBwYXJlbnQgY2FsbCBub2RlJ3MgYGNhbGxlZWAuXG4gKi9cbmV4cG9ydCBjbGFzcyBBcmdzIGV4dGVuZHMgbm9kZSgpLmZpZWxkczx7XG4gIHBvc2l0aW9uYWw6IFBvc2l0aW9uYWxBcmd1bWVudHM7XG4gIG5hbWVkOiBOYW1lZEFyZ3VtZW50cztcbn0+KCkge1xuICBzdGF0aWMgZW1wdHkobG9jOiBTb3VyY2VTcGFuKTogQXJncyB7XG4gICAgcmV0dXJuIG5ldyBBcmdzKHtcbiAgICAgIGxvYyxcbiAgICAgIHBvc2l0aW9uYWw6IFBvc2l0aW9uYWxBcmd1bWVudHMuZW1wdHkobG9jKSxcbiAgICAgIG5hbWVkOiBOYW1lZEFyZ3VtZW50cy5lbXB0eShsb2MpLFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIG5hbWVkKG5hbWVkOiBOYW1lZEFyZ3VtZW50cyk6IEFyZ3Mge1xuICAgIHJldHVybiBuZXcgQXJncyh7XG4gICAgICBsb2M6IG5hbWVkLmxvYyxcbiAgICAgIHBvc2l0aW9uYWw6IFBvc2l0aW9uYWxBcmd1bWVudHMuZW1wdHkobmFtZWQubG9jLmNvbGxhcHNlKCdlbmQnKSksXG4gICAgICBuYW1lZCxcbiAgICB9KTtcbiAgfVxuXG4gIG50aChvZmZzZXQ6IG51bWJlcik6IEV4cHJlc3Npb25Ob2RlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb25hbC5udGgob2Zmc2V0KTtcbiAgfVxuXG4gIGdldChuYW1lOiBzdHJpbmcpOiBFeHByZXNzaW9uTm9kZSB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLm5hbWVkLmdldChuYW1lKTtcbiAgfVxuXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb25hbC5pc0VtcHR5KCkgJiYgdGhpcy5uYW1lZC5pc0VtcHR5KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3JyZXNwb25kcyB0byBwb3NpdGlvbmFsIGFyZ3VtZW50cy5cbiAqXG4gKiBJZiBgUG9zaXRpb25hbEFyZ3VtZW50c2AgaXMgZW1wdHksIHRoZSBgU291cmNlT2Zmc2V0c2AgZm9yIHRoaXMgbm9kZSBzaG91bGQgYmUgdGhlIGNvbGxhcHNlZFxuICogcG9zaXRpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHBhcmVudCBjYWxsIG5vZGUncyBgY2FsbGVlYC5cbiAqL1xuZXhwb3J0IGNsYXNzIFBvc2l0aW9uYWxBcmd1bWVudHMgZXh0ZW5kcyBub2RlKCkuZmllbGRzPHtcbiAgZXhwcnM6IHJlYWRvbmx5IEV4cHJlc3Npb25Ob2RlW107XG59PigpIHtcbiAgc3RhdGljIGVtcHR5KGxvYzogU291cmNlU3Bhbik6IFBvc2l0aW9uYWxBcmd1bWVudHMge1xuICAgIHJldHVybiBuZXcgUG9zaXRpb25hbEFyZ3VtZW50cyh7XG4gICAgICBsb2MsXG4gICAgICBleHByczogW10sXG4gICAgfSk7XG4gIH1cblxuICBnZXQgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmV4cHJzLmxlbmd0aDtcbiAgfVxuXG4gIG50aChvZmZzZXQ6IG51bWJlcik6IEV4cHJlc3Npb25Ob2RlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuZXhwcnNbb2Zmc2V0XSB8fCBudWxsO1xuICB9XG5cbiAgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5leHBycy5sZW5ndGggPT09IDA7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3JyZXNwb25kcyB0byBuYW1lZCBhcmd1bWVudHMuXG4gKlxuICogSWYgYFBvc2l0aW9uYWxBcmd1bWVudHNgIGFuZCBgTmFtZWRBcmd1bWVudHNgIGFyZSBlbXB0eSwgdGhlIGBTb3VyY2VPZmZzZXRzYCBmb3IgdGhpcyBub2RlIHNob3VsZFxuICogYmUgdGhlIHNhbWUgYXMgdGhlIGBBcmdzYCBub2RlIHRoYXQgY29udGFpbnMgdGhpcyBub2RlLlxuICpcbiAqIElmIGBQb3NpdGlvbmFsQXJndW1lbnRzYCBpcyBub3QgZW1wdHkgYnV0IGBOYW1lZEFyZ3VtZW50c2AgaXMgZW1wdHksIHRoZSBgU291cmNlT2Zmc2V0c2AgZm9yIHRoaXNcbiAqIG5vZGUgc2hvdWxkIGJlIHRoZSBjb2xsYXBzZWQgcG9zaXRpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGxhc3QgcG9zaXRpb25hbCBhcmd1bWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIE5hbWVkQXJndW1lbnRzIGV4dGVuZHMgbm9kZSgpLmZpZWxkczx7XG4gIGVudHJpZXM6IHJlYWRvbmx5IE5hbWVkQXJndW1lbnRbXTtcbn0+KCkge1xuICBzdGF0aWMgZW1wdHkobG9jOiBTb3VyY2VTcGFuKTogTmFtZWRBcmd1bWVudHMge1xuICAgIHJldHVybiBuZXcgTmFtZWRBcmd1bWVudHMoe1xuICAgICAgbG9jLFxuICAgICAgZW50cmllczogW10sXG4gICAgfSk7XG4gIH1cblxuICBnZXQgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMubGVuZ3RoO1xuICB9XG5cbiAgZ2V0KG5hbWU6IHN0cmluZyk6IEV4cHJlc3Npb25Ob2RlIHwgbnVsbCB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5lbnRyaWVzLmZpbHRlcigoZSkgPT4gZS5uYW1lLmNoYXJzID09PSBuYW1lKVswXTtcblxuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5LnZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcy5sZW5ndGggPT09IDA7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3JyZXNwb25kcyB0byBhIHNpbmdsZSBuYW1lZCBhcmd1bWVudC5cbiAqXG4gKiBgYGBoYnNcbiAqIHg9PGV4cHI+XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIE5hbWVkQXJndW1lbnQge1xuICByZWFkb25seSBsb2M6IFNvdXJjZVNwYW47XG4gIHJlYWRvbmx5IG5hbWU6IFNvdXJjZVNsaWNlO1xuICByZWFkb25seSB2YWx1ZTogRXhwcmVzc2lvbk5vZGU7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogeyBuYW1lOiBTb3VyY2VTbGljZTsgdmFsdWU6IEV4cHJlc3Npb25Ob2RlIH0pIHtcbiAgICB0aGlzLmxvYyA9IG9wdGlvbnMubmFtZS5sb2MuZXh0ZW5kKG9wdGlvbnMudmFsdWUubG9jKTtcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gIH1cbn1cbiIsImltcG9ydCB7IFNvdXJjZVNsaWNlIH0gZnJvbSAnLi4vLi4vc291cmNlL3NsaWNlJztcbmltcG9ydCB7IE5hbWVkQXJndW1lbnQgfSBmcm9tICcuL2FyZ3MnO1xuaW1wb3J0IHR5cGUgeyBDYWxsRmllbGRzIH0gZnJvbSAnLi9iYXNlJztcbmltcG9ydCB0eXBlIHsgRXhwcmVzc2lvbk5vZGUgfSBmcm9tICcuL2V4cHInO1xuaW1wb3J0IHsgbm9kZSB9IGZyb20gJy4vbm9kZSc7XG5cbi8qKlxuICogQXR0ciBub2RlcyBsb29rIGxpa2UgSFRNTCBhdHRyaWJ1dGVzLCBidXQgYXJlIGNsYXNzaWZpZWQgYXM6XG4gKlxuICogMS4gYEh0bWxBdHRyYCwgd2hpY2ggbWVhbnMgYSByZWd1bGFyIEhUTUwgYXR0cmlidXRlIGluIEdsaW1tZXJcbiAqIDIuIGBTcGxhdEF0dHJgLCB3aGljaCBtZWFucyBgLi4uYXR0cmlidXRlc2BcbiAqIDMuIGBDb21wb25lbnRBcmdgLCB3aGljaCBtZWFucyBhbiBhdHRyaWJ1dGUgd2hvc2UgbmFtZSBiZWdpbnMgd2l0aCBgQGAsIGFuZCBpdCBpcyB0aGVyZWZvcmUgYVxuICogICAgY29tcG9uZW50IGFyZ3VtZW50LlxuICovXG5leHBvcnQgdHlwZSBBdHRyTm9kZSA9IEh0bWxBdHRyIHwgU3BsYXRBdHRyIHwgQ29tcG9uZW50QXJnO1xuXG4vKipcbiAqIGBIdG1sQXR0cmAgYW5kIGBTcGxhdEF0dHJgIGFyZSBncm91cGVkIHRvZ2V0aGVyIGJlY2F1c2UgdGhlIG9yZGVyIG9mIHRoZSBgU3BsYXRBdHRyYCBub2RlLFxuICogcmVsYXRpdmUgdG8gb3RoZXIgYXR0cmlidXRlcywgbWF0dGVycy5cbiAqL1xuZXhwb3J0IHR5cGUgSHRtbE9yU3BsYXRBdHRyID0gSHRtbEF0dHIgfCBTcGxhdEF0dHI7XG5cbi8qKlxuICogXCJBdHRyIEJsb2NrXCIgbm9kZXMgYXJlIGFsbG93ZWQgaW5zaWRlIGFuIG9wZW4gZWxlbWVudCB0YWcgaW4gdGVtcGxhdGVzLiBUaGV5IGludGVyYWN0IHdpdGggdGhlXG4gKiBlbGVtZW50IChvciBjb21wb25lbnQpLlxuICovXG5leHBvcnQgdHlwZSBBdHRyQmxvY2tOb2RlID0gQXR0ck5vZGUgfCBFbGVtZW50TW9kaWZpZXI7XG5cbi8qKlxuICogYEh0bWxBdHRyYCBub2RlcyBhcmUgdmFsaWQgSFRNTCBhdHRyaWJ1dGVzLCB3aXRoIG9yIHdpdGhvdXQgYSB2YWx1ZS5cbiAqXG4gKiBFeGNlcHRpb25zOlxuICpcbiAqIC0gYC4uLmF0dHJpYnV0ZXNgIGlzIGBTcGxhdEF0dHJgXG4gKiAtIGBAeD08dmFsdWU+YCBpcyBgQ29tcG9uZW50QXJnYFxuICovXG5leHBvcnQgY2xhc3MgSHRtbEF0dHIgZXh0ZW5kcyBub2RlKCdIdG1sQXR0cicpLmZpZWxkczxBdHRyTm9kZU9wdGlvbnM+KCkge31cblxuZXhwb3J0IGNsYXNzIFNwbGF0QXR0ciBleHRlbmRzIG5vZGUoJ1NwbGF0QXR0cicpLmZpZWxkczx7IHN5bWJvbDogbnVtYmVyIH0+KCkge31cblxuLyoqXG4gKiBDb3JyZXNwb25kcyB0byBhbiBhcmd1bWVudCBwYXNzZWQgYnkgYSBjb21wb25lbnQgKGBAeD08dmFsdWU+YClcbiAqL1xuZXhwb3J0IGNsYXNzIENvbXBvbmVudEFyZyBleHRlbmRzIG5vZGUoKS5maWVsZHM8QXR0ck5vZGVPcHRpb25zPigpIHtcbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGNvbXBvbmVudCBhcmd1bWVudCBpbnRvIGEgbmFtZWQgYXJndW1lbnQgbm9kZVxuICAgKi9cbiAgdG9OYW1lZEFyZ3VtZW50KCk6IE5hbWVkQXJndW1lbnQge1xuICAgIHJldHVybiBuZXcgTmFtZWRBcmd1bWVudCh7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGBFbGVtZW50TW9kaWZpZXJgIGlzIGp1c3QgYSBub3JtYWwgY2FsbCBub2RlIGluIG1vZGlmaWVyIHBvc2l0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgRWxlbWVudE1vZGlmaWVyIGV4dGVuZHMgbm9kZSgnRWxlbWVudE1vZGlmaWVyJykuZmllbGRzPENhbGxGaWVsZHM+KCkge31cblxuZXhwb3J0IGludGVyZmFjZSBBdHRyTm9kZU9wdGlvbnMge1xuICBuYW1lOiBTb3VyY2VTbGljZTtcbiAgdmFsdWU6IEV4cHJlc3Npb25Ob2RlO1xuICB0cnVzdGluZzogYm9vbGVhbjtcbn1cbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCB0eXBlIHsgUHJlc2VudEFycmF5IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbmltcG9ydCB7IExvY2F0ZWRXaXRoT3B0aW9uYWxTcGFuLCBMb2NhdGVkV2l0aFNwYW4gfSBmcm9tICcuL2xvY2F0aW9uJztcbmltcG9ydCB7IFNvdXJjZU9mZnNldCwgU291cmNlU3BhbiB9IGZyb20gJy4vc3Bhbic7XG5cbmV4cG9ydCB0eXBlIEhhc1NwYW4gPSBTb3VyY2VTcGFuIHwgTG9jYXRlZFdpdGhTcGFuIHwgUHJlc2VudEFycmF5PExvY2F0ZWRXaXRoU3Bhbj47XG5leHBvcnQgdHlwZSBNYXliZUhhc1NwYW4gPSBTb3VyY2VTcGFuIHwgTG9jYXRlZFdpdGhPcHRpb25hbFNwYW4gfCBMb2NhdGVkV2l0aE9wdGlvbmFsU3BhbltdIHwgbnVsbDtcblxuZXhwb3J0IHR5cGUgVG9Tb3VyY2VPZmZzZXQgPSBudW1iZXIgfCBTb3VyY2VPZmZzZXQ7XG5cbmV4cG9ydCBjbGFzcyBTcGFuTGlzdCB7XG4gIHN0YXRpYyByYW5nZShzcGFuOiBQcmVzZW50QXJyYXk8SGFzU291cmNlU3Bhbj4pOiBTb3VyY2VTcGFuO1xuICBzdGF0aWMgcmFuZ2Uoc3BhbjogSGFzU291cmNlU3BhbltdLCBmYWxsYmFjazogU291cmNlU3Bhbik6IFNvdXJjZVNwYW47XG4gIHN0YXRpYyByYW5nZShzcGFuOiBIYXNTb3VyY2VTcGFuW10sIGZhbGxiYWNrOiBTb3VyY2VTcGFuID0gU291cmNlU3Bhbi5OT05fRVhJU1RFTlQpOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gbmV3IFNwYW5MaXN0KHNwYW4ubWFwKGxvYykpLmdldFJhbmdlT2Zmc2V0KGZhbGxiYWNrKTtcbiAgfVxuXG4gICNzcGFuOiBTb3VyY2VTcGFuW107XG5cbiAgY29uc3RydWN0b3Ioc3BhbjogU291cmNlU3BhbltdID0gW10pIHtcbiAgICB0aGlzLiNzcGFuID0gc3BhbjtcbiAgfVxuXG4gIGFkZChvZmZzZXQ6IFNvdXJjZVNwYW4pOiB2b2lkIHtcbiAgICB0aGlzLiNzcGFuLnB1c2gob2Zmc2V0KTtcbiAgfVxuXG4gIGdldFJhbmdlT2Zmc2V0KGZhbGxiYWNrOiBTb3VyY2VTcGFuKTogU291cmNlU3BhbiB7XG4gICAgaWYgKHRoaXMuI3NwYW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBmaXJzdCA9IHRoaXMuI3NwYW5bMF07XG4gICAgICBsZXQgbGFzdCA9IHRoaXMuI3NwYW5bdGhpcy4jc3Bhbi5sZW5ndGggLSAxXTtcblxuICAgICAgcmV0dXJuIGZpcnN0LmV4dGVuZChsYXN0KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgSGFzU291cmNlU3BhbiA9IHsgbG9jOiBTb3VyY2VTcGFuIH0gfCBTb3VyY2VTcGFuIHwgW0hhc1NvdXJjZVNwYW4sIC4uLkhhc1NvdXJjZVNwYW5bXV07XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2Moc3BhbjogSGFzU291cmNlU3Bhbik6IFNvdXJjZVNwYW4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShzcGFuKSkge1xuICAgIGxldCBmaXJzdCA9IHNwYW5bMF07XG4gICAgbGV0IGxhc3QgPSBzcGFuW3NwYW4ubGVuZ3RoIC0gMV07XG5cbiAgICByZXR1cm4gbG9jKGZpcnN0KS5leHRlbmQobG9jKGxhc3QpKTtcbiAgfSBlbHNlIGlmIChzcGFuIGluc3RhbmNlb2YgU291cmNlU3Bhbikge1xuICAgIHJldHVybiBzcGFuO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzcGFuLmxvYztcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBNYXliZUhhc1NvdXJjZVNwYW4gPSB7IGxvYzogU291cmNlU3BhbiB9IHwgU291cmNlU3BhbiB8IE1heWJlSGFzU291cmNlU3BhbltdO1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzU3BhbihzcGFuOiBNYXliZUhhc1NvdXJjZVNwYW4pOiBzcGFuIGlzIEhhc1NvdXJjZVNwYW4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShzcGFuKSAmJiBzcGFuLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVMb2MobG9jYXRpb246IE1heWJlSGFzU291cmNlU3BhbiwgZmFsbGJhY2s6IFNvdXJjZVNwYW4pOiBTb3VyY2VTcGFuIHtcbiAgaWYgKGhhc1NwYW4obG9jYXRpb24pKSB7XG4gICAgcmV0dXJuIGxvYyhsb2NhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG59XG4iLCJpbXBvcnQgeyBTb3VyY2VTbGljZSB9IGZyb20gJy4uLy4uL3NvdXJjZS9zbGljZSc7XG5pbXBvcnQgeyBTcGFuTGlzdCB9IGZyb20gJy4uLy4uL3NvdXJjZS9zcGFuLWxpc3QnO1xuaW1wb3J0IHsgU3ltYm9sVGFibGUgfSBmcm9tICcuLi8uLi9zeW1ib2wtdGFibGUnO1xuaW1wb3J0IHsgQXJncywgTmFtZWRBcmd1bWVudHMgfSBmcm9tICcuL2FyZ3MnO1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRBcmcsIEVsZW1lbnRNb2RpZmllciwgSHRtbE9yU3BsYXRBdHRyIH0gZnJvbSAnLi9hdHRyLWJsb2NrJztcbmltcG9ydCB0eXBlIHsgQ2FsbEZpZWxkcyB9IGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgdHlwZSB7IEV4cHJlc3Npb25Ob2RlIH0gZnJvbSAnLi9leHByJztcbmltcG9ydCB0eXBlIHsgTmFtZWRCbG9jaywgTmFtZWRCbG9ja3MgfSBmcm9tICcuL2ludGVybmFsLW5vZGUnO1xuaW1wb3J0IHsgQmFzZU5vZGVGaWVsZHMsIG5vZGUgfSBmcm9tICcuL25vZGUnO1xuXG4vKipcbiAqIENvbnRlbnQgTm9kZXMgYXJlIGFsbG93ZWQgaW4gY29udGVudCBwb3NpdGlvbnMgaW4gdGVtcGxhdGVzLiBUaGV5IGNvcnJlc3BvbmQgdG8gYmVoYXZpb3IgaW4gdGhlXG4gKiBbRGF0YV1bZGF0YV0gdG9rZW5pemF0aW9uIHN0YXRlIGluIEhUTUwuXG4gKlxuICogW2RhdGFdOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjZGF0YS1zdGF0ZVxuICovXG5leHBvcnQgdHlwZSBDb250ZW50Tm9kZSA9XG4gIHwgSHRtbFRleHRcbiAgfCBIdG1sQ29tbWVudFxuICB8IEFwcGVuZENvbnRlbnRcbiAgfCBJbnZva2VCbG9ja1xuICB8IEludm9rZUNvbXBvbmVudFxuICB8IFNpbXBsZUVsZW1lbnRcbiAgfCBHbGltbWVyQ29tbWVudDtcblxuZXhwb3J0IGNsYXNzIEdsaW1tZXJDb21tZW50IGV4dGVuZHMgbm9kZSgnR2xpbW1lckNvbW1lbnQnKS5maWVsZHM8eyB0ZXh0OiBTb3VyY2VTbGljZSB9PigpIHt9XG5leHBvcnQgY2xhc3MgSHRtbFRleHQgZXh0ZW5kcyBub2RlKCdIdG1sVGV4dCcpLmZpZWxkczx7IGNoYXJzOiBzdHJpbmcgfT4oKSB7fVxuZXhwb3J0IGNsYXNzIEh0bWxDb21tZW50IGV4dGVuZHMgbm9kZSgnSHRtbENvbW1lbnQnKS5maWVsZHM8eyB0ZXh0OiBTb3VyY2VTbGljZSB9PigpIHt9XG5cbmV4cG9ydCBjbGFzcyBBcHBlbmRDb250ZW50IGV4dGVuZHMgbm9kZSgnQXBwZW5kQ29udGVudCcpLmZpZWxkczx7XG4gIHZhbHVlOiBFeHByZXNzaW9uTm9kZTtcbiAgdHJ1c3Rpbmc6IGJvb2xlYW47XG4gIHRhYmxlOiBTeW1ib2xUYWJsZTtcbn0+KCkge1xuICBnZXQgY2FsbGVlKCk6IEV4cHJlc3Npb25Ob2RlIHtcbiAgICBpZiAodGhpcy52YWx1ZS50eXBlID09PSAnQ2FsbCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlLmNhbGxlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGFyZ3MoKTogQXJncyB7XG4gICAgaWYgKHRoaXMudmFsdWUudHlwZSA9PT0gJ0NhbGwnKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZS5hcmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQXJncy5lbXB0eSh0aGlzLnZhbHVlLmxvYy5jb2xsYXBzZSgnZW5kJykpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW52b2tlQmxvY2sgZXh0ZW5kcyBub2RlKCdJbnZva2VCbG9jaycpLmZpZWxkczxcbiAgQ2FsbEZpZWxkcyAmIHsgYmxvY2tzOiBOYW1lZEJsb2NrcyB9XG4+KCkge31cblxuaW50ZXJmYWNlIEludm9rZUNvbXBvbmVudEZpZWxkcyB7XG4gIGNhbGxlZTogRXhwcmVzc2lvbk5vZGU7XG4gIGJsb2NrczogTmFtZWRCbG9ja3M7XG4gIGF0dHJzOiByZWFkb25seSBIdG1sT3JTcGxhdEF0dHJbXTtcbiAgY29tcG9uZW50QXJnczogcmVhZG9ubHkgQ29tcG9uZW50QXJnW107XG4gIG1vZGlmaWVyczogcmVhZG9ubHkgRWxlbWVudE1vZGlmaWVyW107XG59XG5cbi8qKlxuICogQ29ycmVzcG9uZHMgdG8gYSBjb21wb25lbnQgaW52b2NhdGlvbi4gV2hlbiB0aGUgY29udGVudCBvZiBhIGNvbXBvbmVudCBpbnZvY2F0aW9uIGNvbnRhaW5zIG5vXG4gKiBuYW1lZCBibG9ja3MsIGBibG9ja3NgIGNvbnRhaW5zIGEgc2luZ2xlIG5hbWVkIGJsb2NrIG5hbWVkIGBcImRlZmF1bHRcImAuIFdoZW4gYSBjb21wb25lbnRcbiAqIGludm9jYXRpb24gaXMgc2VsZi1jbG9zaW5nLCBgYmxvY2tzYCBpcyBlbXB0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIEludm9rZUNvbXBvbmVudCBleHRlbmRzIG5vZGUoJ0ludm9rZUNvbXBvbmVudCcpLmZpZWxkczxJbnZva2VDb21wb25lbnRGaWVsZHM+KCkge1xuICBnZXQgYXJncygpOiBBcmdzIHtcbiAgICBsZXQgZW50cmllcyA9IHRoaXMuY29tcG9uZW50QXJncy5tYXAoKGEpID0+IGEudG9OYW1lZEFyZ3VtZW50KCkpO1xuXG4gICAgcmV0dXJuIEFyZ3MubmFtZWQoXG4gICAgICBuZXcgTmFtZWRBcmd1bWVudHMoe1xuICAgICAgICBsb2M6IFNwYW5MaXN0LnJhbmdlKGVudHJpZXMsIHRoaXMuY2FsbGVlLmxvYy5jb2xsYXBzZSgnZW5kJykpLFxuICAgICAgICBlbnRyaWVzLFxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5cbmludGVyZmFjZSBTaW1wbGVFbGVtZW50T3B0aW9ucyBleHRlbmRzIEJhc2VOb2RlRmllbGRzIHtcbiAgdGFnOiBTb3VyY2VTbGljZTtcbiAgYm9keTogcmVhZG9ubHkgQ29udGVudE5vZGVbXTtcbiAgYXR0cnM6IHJlYWRvbmx5IEh0bWxPclNwbGF0QXR0cltdO1xuICBjb21wb25lbnRBcmdzOiByZWFkb25seSBDb21wb25lbnRBcmdbXTtcbiAgbW9kaWZpZXJzOiByZWFkb25seSBFbGVtZW50TW9kaWZpZXJbXTtcbn1cblxuLyoqXG4gKiBDb3JyZXNwb25kcyB0byBhIHNpbXBsZSBIVE1MIGVsZW1lbnQuIFRoZSBBU1QgYWxsb3dzIGNvbXBvbmVudCBhcmd1bWVudHMgYW5kIG1vZGlmaWVycyB0byBzdXBwb3J0XG4gKiBmdXR1cmUgZXh0ZW5zaW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpbXBsZUVsZW1lbnQgZXh0ZW5kcyBub2RlKCdTaW1wbGVFbGVtZW50JykuZmllbGRzPFNpbXBsZUVsZW1lbnRPcHRpb25zPigpIHtcbiAgZ2V0IGFyZ3MoKTogQXJncyB7XG4gICAgbGV0IGVudHJpZXMgPSB0aGlzLmNvbXBvbmVudEFyZ3MubWFwKChhKSA9PiBhLnRvTmFtZWRBcmd1bWVudCgpKTtcblxuICAgIHJldHVybiBBcmdzLm5hbWVkKFxuICAgICAgbmV3IE5hbWVkQXJndW1lbnRzKHtcbiAgICAgICAgbG9jOiBTcGFuTGlzdC5yYW5nZShlbnRyaWVzLCB0aGlzLnRhZy5sb2MuY29sbGFwc2UoJ2VuZCcpKSxcbiAgICAgICAgZW50cmllcyxcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBFbGVtZW50Tm9kZSA9IE5hbWVkQmxvY2sgfCBJbnZva2VDb21wb25lbnQgfCBTaW1wbGVFbGVtZW50O1xuIiwiaW1wb3J0IHsgUHJlc2VudEFycmF5IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbmltcG9ydCB7IFNvdXJjZVNsaWNlIH0gZnJvbSAnLi4vLi4vc291cmNlL3NsaWNlJztcbmltcG9ydCB0eXBlIHsgQ2FsbEZpZWxkcyB9IGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBub2RlIH0gZnJvbSAnLi9ub2RlJztcbmltcG9ydCB0eXBlIHsgRnJlZVZhclJlZmVyZW5jZSwgVmFyaWFibGVSZWZlcmVuY2UgfSBmcm9tICcuL3JlZnMnO1xuXG4vKipcbiAqIEEgSGFuZGxlYmFycyBsaXRlcmFsLlxuICpcbiAqIHtAbGluayBodHRwczovL2hhbmRsZWJhcnNqcy5jb20vZ3VpZGUvZXhwcmVzc2lvbnMuaHRtbCNsaXRlcmFsLXNlZ21lbnRzfVxuICovXG5leHBvcnQgdHlwZSBMaXRlcmFsVmFsdWUgPSBzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcblxuZXhwb3J0IGludGVyZmFjZSBMaXRlcmFsVHlwZXMge1xuICBzdHJpbmc6IHN0cmluZztcbiAgYm9vbGVhbjogYm9vbGVhbjtcbiAgbnVtYmVyOiBudW1iZXI7XG4gIG51bGw6IG51bGw7XG4gIHVuZGVmaW5lZDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENvcnJlc3BvbmRzIHRvIGEgSGFuZGxlYmFycyBsaXRlcmFsLlxuICpcbiAqIEBzZWUge0xpdGVyYWxWYWx1ZX1cbiAqL1xuZXhwb3J0IGNsYXNzIExpdGVyYWxFeHByZXNzaW9uIGV4dGVuZHMgbm9kZSgnTGl0ZXJhbCcpLmZpZWxkczx7IHZhbHVlOiBMaXRlcmFsVmFsdWUgfT4oKSB7XG4gIHRvU2xpY2UodGhpczogU3RyaW5nTGl0ZXJhbCk6IFNvdXJjZVNsaWNlIHtcbiAgICByZXR1cm4gbmV3IFNvdXJjZVNsaWNlKHsgbG9jOiB0aGlzLmxvYywgY2hhcnM6IHRoaXMudmFsdWUgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgU3RyaW5nTGl0ZXJhbCA9IExpdGVyYWxFeHByZXNzaW9uICYgeyB2YWx1ZTogc3RyaW5nIH07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIGlucHV0IHtAc2VlIEV4cHJlc3Npb25Ob2RlfSBpcyBhIGxpdGVyYWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xpdGVyYWw8SyBleHRlbmRzIGtleW9mIExpdGVyYWxUeXBlcyA9IGtleW9mIExpdGVyYWxUeXBlcz4oXG4gIG5vZGU6IEV4cHJlc3Npb25Ob2RlLFxuICBraW5kPzogS1xuKTogbm9kZSBpcyBTdHJpbmdMaXRlcmFsIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ0xpdGVyYWwnKSB7XG4gICAgaWYgKGtpbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSAnbnVsbCcpIHtcbiAgICAgIHJldHVybiBub2RlLnZhbHVlID09PSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG5vZGUudmFsdWUgPT09IGtpbmQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIENvcnJlc3BvbmRzIHRvIGEgcGF0aCBpbiBleHByZXNzaW9uIHBvc2l0aW9uLlxuICpcbiAqIGBgYGhic1xuICogdGhpc1xuICogdGhpcy54XG4gKiBAeFxuICogQHgueVxuICogeFxuICogeC55XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFBhdGhFeHByZXNzaW9uIGV4dGVuZHMgbm9kZSgnUGF0aCcpLmZpZWxkczx7XG4gIHJlZjogVmFyaWFibGVSZWZlcmVuY2U7XG4gIHRhaWw6IHJlYWRvbmx5IFNvdXJjZVNsaWNlW107XG59PigpIHt9XG5cbi8qKlxuICogQ29ycmVzcG9uZHMgdG8gYSBwYXJlbnRoZXNpemVkIGNhbGwgZXhwcmVzc2lvbi5cbiAqXG4gKiBgYGBoYnNcbiAqICh4KVxuICogKHgueSlcbiAqICh4IHkpXG4gKiAoeC55IHopXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIENhbGxFeHByZXNzaW9uIGV4dGVuZHMgbm9kZSgnQ2FsbCcpLmZpZWxkczxDYWxsRmllbGRzPigpIHt9XG5cbi8qKlxuICogQ29ycmVzcG9uZHMgdG8gYSBwb3NzaWJsZSBkZXByZWNhdGVkIGhlbHBlciBjYWxsLiBNdXN0IGJlOlxuICpcbiAqIDEuIEEgZnJlZSB2YXJpYWJsZSAobm90IHRoaXMuZm9vLCBub3QgQGZvbywgbm90IGxvY2FsKS5cbiAqIDIuIEFyZ3VtZW50LWxlc3MuXG4gKiAzLiBJbiBhIGNvbXBvbmVudCBpbnZvY2F0aW9uJ3MgbmFtZWQgYXJndW1lbnQgcG9zaXRpb24uXG4gKiA0LiBOb3QgcGFyZW50aGVzaXplZCAobm90IEBiYXI9e3soaGVscGVyKX19KS5cbiAqIDUuIE5vdCBpbnRlcnBvbGF0ZWQgKG5vdCBAYmFyPVwie3toZWxwZXJ9fVwiKS5cbiAqXG4gKiBgYGBoYnNcbiAqIDxGb28gQGJhcj17e2hlbHBlcn19IC8+XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIERlcHJlY2F0ZWRDYWxsRXhwcmVzc2lvbiBleHRlbmRzIG5vZGUoJ0RlcHJlY2F0ZWRDYWxsJykuZmllbGRzPHtcbiAgYXJnOiBTb3VyY2VTbGljZTtcbiAgY2FsbGVlOiBGcmVlVmFyUmVmZXJlbmNlO1xufT4oKSB7fVxuXG4vKipcbiAqIENvcnJlc3BvbmRzIHRvIGFuIGludGVycG9sYXRpb24gaW4gYXR0cmlidXRlIHZhbHVlIHBvc2l0aW9uLlxuICpcbiAqIGBgYGhic1xuICogPGEgaHJlZj1cInt7dXJsfX0uaHRtbFwiXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludGVycG9sYXRlRXhwcmVzc2lvbiBleHRlbmRzIG5vZGUoJ0ludGVycG9sYXRlJykuZmllbGRzPHtcbiAgcGFydHM6IFByZXNlbnRBcnJheTxFeHByZXNzaW9uTm9kZT47XG59PigpIHt9XG5cbmV4cG9ydCB0eXBlIEV4cHJlc3Npb25Ob2RlID1cbiAgfCBMaXRlcmFsRXhwcmVzc2lvblxuICB8IFBhdGhFeHByZXNzaW9uXG4gIHwgQ2FsbEV4cHJlc3Npb25cbiAgfCBEZXByZWNhdGVkQ2FsbEV4cHJlc3Npb25cbiAgfCBJbnRlcnBvbGF0ZUV4cHJlc3Npb247XG4iLCJpbXBvcnQgeyBTb3VyY2VTbGljZSB9IGZyb20gJy4uLy4uL3NvdXJjZS9zbGljZSc7XG5pbXBvcnQgeyBub2RlIH0gZnJvbSAnLi9ub2RlJztcbmltcG9ydCB0eXBlIHsgRnJlZVZhclJlc29sdXRpb24gfSBmcm9tICcuL3Jlc29sdXRpb24nO1xuXG4vKipcbiAqIENvcnJlc3BvbmRzIHRvIGB0aGlzYCBhdCB0aGUgaGVhZCBvZiBhbiBleHByZXNzaW9uLlxuICovXG5leHBvcnQgY2xhc3MgVGhpc1JlZmVyZW5jZSBleHRlbmRzIG5vZGUoJ1RoaXMnKS5maWVsZHMoKSB7fVxuXG4vKipcbiAqIENvcnJlc3BvbmRzIHRvIGBAPGlkZW50PmAgYXQgdGhlIGJlZ2lubmluZyBvZiBhbiBleHByZXNzaW9uLlxuICovXG5leHBvcnQgY2xhc3MgQXJnUmVmZXJlbmNlIGV4dGVuZHMgbm9kZSgnQXJnJykuZmllbGRzPHsgbmFtZTogU291cmNlU2xpY2U7IHN5bWJvbDogbnVtYmVyIH0+KCkge31cblxuLyoqXG4gKiBDb3JyZXNwb25kcyB0byBgPGlkZW50PmAgYXQgdGhlIGJlZ2lubmluZyBvZiBhbiBleHByZXNzaW9uLCB3aGVuIGA8aWRlbnQ+YCBpcyBpbiB0aGUgY3VycmVudFxuICogYmxvY2sncyBzY29wZS5cbiAqL1xuZXhwb3J0IGNsYXNzIExvY2FsVmFyUmVmZXJlbmNlIGV4dGVuZHMgbm9kZSgnTG9jYWwnKS5maWVsZHM8e1xuICBuYW1lOiBzdHJpbmc7XG4gIGlzVGVtcGxhdGVMb2NhbDogYm9vbGVhbjtcbiAgc3ltYm9sOiBudW1iZXI7XG59PigpIHt9XG5cbi8qKlxuICogQ29ycmVzcG9uZHMgdG8gYDxpZGVudD5gIGF0IHRoZSBiZWdpbm5pbmcgb2YgYW4gZXhwcmVzc2lvbiwgd2hlbiBgPGlkZW50PmAgaXMgKm5vdCogaW4gdGhlXG4gKiBjdXJyZW50IGJsb2NrJ3Mgc2NvcGUuXG4gKlxuICogVGhlIGByZXNvbHV0aW9uOiBGcmVlVmFyUmVzb2x1dGlvbmAgZmllbGQgZGVzY3JpYmVzIGhvdyB0byByZXNvbHZlIHRoZSBmcmVlIHZhcmlhYmxlLlxuICpcbiAqIE5vdGU6IEluIHN0cmljdCBtb2RlLCBpdCBtdXN0IGFsd2F5cyBiZSBhIHZhcmlhYmxlIHRoYXQgaXMgaW4gYSBjb25jcmV0ZSBKYXZhU2NyaXB0IHNjb3BlIHRoYXRcbiAqIHRoZSB0ZW1wbGF0ZSB3aWxsIGJlIGluc3RhbGxlZCBpbnRvLlxuICovXG5leHBvcnQgY2xhc3MgRnJlZVZhclJlZmVyZW5jZSBleHRlbmRzIG5vZGUoJ0ZyZWUnKS5maWVsZHM8e1xuICBuYW1lOiBzdHJpbmc7XG4gIHJlc29sdXRpb246IEZyZWVWYXJSZXNvbHV0aW9uO1xuICBzeW1ib2w6IG51bWJlcjtcbn0+KCkge31cblxuZXhwb3J0IHR5cGUgVmFyaWFibGVSZWZlcmVuY2UgPSBUaGlzUmVmZXJlbmNlIHwgQXJnUmVmZXJlbmNlIHwgTG9jYWxWYXJSZWZlcmVuY2UgfCBGcmVlVmFyUmVmZXJlbmNlO1xuIiwiaW1wb3J0IHsgU291cmNlU2xpY2UgfSBmcm9tICcuLi8uLi9zb3VyY2Uvc2xpY2UnO1xuaW1wb3J0IHsgU3Bhbkxpc3QgfSBmcm9tICcuLi8uLi9zb3VyY2Uvc3Bhbi1saXN0JztcbmltcG9ydCB7IEJsb2NrU3ltYm9sVGFibGUsIFByb2dyYW1TeW1ib2xUYWJsZSB9IGZyb20gJy4uLy4uL3N5bWJvbC10YWJsZSc7XG5pbXBvcnQgeyBBcmdzLCBOYW1lZEFyZ3VtZW50cyB9IGZyb20gJy4vYXJncyc7XG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudEFyZywgRWxlbWVudE1vZGlmaWVyLCBIdG1sT3JTcGxhdEF0dHIgfSBmcm9tICcuL2F0dHItYmxvY2snO1xuaW1wb3J0IHR5cGUgeyBHbGltbWVyUGFyZW50Tm9kZU9wdGlvbnMgfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgQmFzZU5vZGVGaWVsZHMsIG5vZGUgfSBmcm9tICcuL25vZGUnO1xuXG4vKipcbiAqIENvcnJlc3BvbmRzIHRvIGFuIGVudGlyZSB0ZW1wbGF0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlIGV4dGVuZHMgbm9kZSgpLmZpZWxkczxcbiAge1xuICAgIHRhYmxlOiBQcm9ncmFtU3ltYm9sVGFibGU7XG4gIH0gJiBHbGltbWVyUGFyZW50Tm9kZU9wdGlvbnNcbj4oKSB7fVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBibG9jay4gSW4gcHJpbmNpcGxlIHRoaXMgY291bGQgYmUgbWVyZ2VkIHdpdGggYE5hbWVkQmxvY2tgLCBiZWNhdXNlIGFsbCBjYXNlc1xuICogaW52b2x2aW5nIGJsb2NrcyBoYXZlIGF0IGxlYXN0IGEgbm90aW9uYWwgbmFtZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrIGV4dGVuZHMgbm9kZSgpLmZpZWxkczxcbiAgeyBzY29wZTogQmxvY2tTeW1ib2xUYWJsZSB9ICYgR2xpbW1lclBhcmVudE5vZGVPcHRpb25zXG4+KCkge31cblxuLyoqXG4gKiBDb3JyZXNwb25kcyB0byBhIGNvbGxlY3Rpb24gb2YgbmFtZWQgYmxvY2tzLlxuICovXG5leHBvcnQgY2xhc3MgTmFtZWRCbG9ja3MgZXh0ZW5kcyBub2RlKCkuZmllbGRzPHsgYmxvY2tzOiByZWFkb25seSBOYW1lZEJsb2NrW10gfT4oKSB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGBOYW1lZEJsb2NrYCBmb3IgYSBnaXZlbiBuYW1lLlxuICAgKi9cbiAgZ2V0KG5hbWU6ICdkZWZhdWx0Jyk6IE5hbWVkQmxvY2s7XG4gIGdldChuYW1lOiBzdHJpbmcpOiBOYW1lZEJsb2NrIHwgbnVsbDtcbiAgZ2V0KG5hbWU6IHN0cmluZyk6IE5hbWVkQmxvY2sgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MuZmlsdGVyKChibG9jaykgPT4gYmxvY2submFtZS5jaGFycyA9PT0gbmFtZSlbMF0gfHwgbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hbWVkQmxvY2tGaWVsZHMgZXh0ZW5kcyBCYXNlTm9kZUZpZWxkcyB7XG4gIG5hbWU6IFNvdXJjZVNsaWNlO1xuICBibG9jazogQmxvY2s7XG5cbiAgLy8gdGhlc2UgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLCBidXQgYXJlIGhlcmUgZm9yIGZ1dHVyZSBleHBhbnNpb25cbiAgYXR0cnM6IHJlYWRvbmx5IEh0bWxPclNwbGF0QXR0cltdO1xuICBjb21wb25lbnRBcmdzOiByZWFkb25seSBDb21wb25lbnRBcmdbXTtcbiAgbW9kaWZpZXJzOiByZWFkb25seSBFbGVtZW50TW9kaWZpZXJbXTtcbn1cblxuLyoqXG4gKiBDb3JyZXNwb25kcyB0byBhIHNpbmdsZSBuYW1lZCBibG9jay4gVGhpcyBpcyB1c2VkIGZvciBhbm9ueW1vdXMgbmFtZWQgYmxvY2tzIChgZGVmYXVsdGAgYW5kXG4gKiBgZWxzZWApLlxuICovXG5leHBvcnQgY2xhc3MgTmFtZWRCbG9jayBleHRlbmRzIG5vZGUoKS5maWVsZHM8TmFtZWRCbG9ja0ZpZWxkcz4oKSB7XG4gIGdldCBhcmdzKCk6IEFyZ3Mge1xuICAgIGxldCBlbnRyaWVzID0gdGhpcy5jb21wb25lbnRBcmdzLm1hcCgoYSkgPT4gYS50b05hbWVkQXJndW1lbnQoKSk7XG5cbiAgICByZXR1cm4gQXJncy5uYW1lZChcbiAgICAgIG5ldyBOYW1lZEFyZ3VtZW50cyh7XG4gICAgICAgIGxvYzogU3Bhbkxpc3QucmFuZ2UoZW50cmllcywgdGhpcy5uYW1lLmxvYy5jb2xsYXBzZSgnZW5kJykpLFxuICAgICAgICBlbnRyaWVzLFxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBBU1R2MSBmcm9tICcuLi92MS9hcGknO1xuXG5jb25zdCBlbnVtIENoYXIge1xuICBOQlNQID0gMHhhMCxcbiAgUVVPVCA9IDB4MjIsXG4gIExUID0gMHgzYyxcbiAgR1QgPSAweDNlLFxuICBBTVAgPSAweDI2LFxufVxuXG5jb25zdCBBVFRSX1ZBTFVFX1JFR0VYX1RFU1QgPSAvW1xceEEwXCImXS87XG5jb25zdCBBVFRSX1ZBTFVFX1JFR0VYX1JFUExBQ0UgPSBuZXcgUmVnRXhwKEFUVFJfVkFMVUVfUkVHRVhfVEVTVC5zb3VyY2UsICdnJyk7XG5cbmNvbnN0IFRFWFRfUkVHRVhfVEVTVCA9IC9bXFx4QTAmPD5dLztcbmNvbnN0IFRFWFRfUkVHRVhfUkVQTEFDRSA9IG5ldyBSZWdFeHAoVEVYVF9SRUdFWF9URVNULnNvdXJjZSwgJ2cnKTtcblxuZnVuY3Rpb24gYXR0clZhbHVlUmVwbGFjZXIoY2hhcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgc3dpdGNoIChjaGFyLmNoYXJDb2RlQXQoMCkpIHtcbiAgICBjYXNlIENoYXIuTkJTUDpcbiAgICAgIHJldHVybiAnJm5ic3A7JztcbiAgICBjYXNlIENoYXIuUVVPVDpcbiAgICAgIHJldHVybiAnJnF1b3Q7JztcbiAgICBjYXNlIENoYXIuQU1QOlxuICAgICAgcmV0dXJuICcmYW1wOyc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjaGFyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRleHRSZXBsYWNlcihjaGFyOiBzdHJpbmcpOiBzdHJpbmcge1xuICBzd2l0Y2ggKGNoYXIuY2hhckNvZGVBdCgwKSkge1xuICAgIGNhc2UgQ2hhci5OQlNQOlxuICAgICAgcmV0dXJuICcmbmJzcDsnO1xuICAgIGNhc2UgQ2hhci5BTVA6XG4gICAgICByZXR1cm4gJyZhbXA7JztcbiAgICBjYXNlIENoYXIuTFQ6XG4gICAgICByZXR1cm4gJyZsdDsnO1xuICAgIGNhc2UgQ2hhci5HVDpcbiAgICAgIHJldHVybiAnJmd0Oyc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjaGFyO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVBdHRyVmFsdWUoYXR0clZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoQVRUUl9WQUxVRV9SRUdFWF9URVNULnRlc3QoYXR0clZhbHVlKSkge1xuICAgIHJldHVybiBhdHRyVmFsdWUucmVwbGFjZShBVFRSX1ZBTFVFX1JFR0VYX1JFUExBQ0UsIGF0dHJWYWx1ZVJlcGxhY2VyKTtcbiAgfVxuICByZXR1cm4gYXR0clZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlVGV4dCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoVEVYVF9SRUdFWF9URVNULnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKFRFWFRfUkVHRVhfUkVQTEFDRSwgdGV4dFJlcGxhY2VyKTtcbiAgfVxuICByZXR1cm4gdGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRCeUxvYyhhOiBBU1R2MS5Ob2RlLCBiOiBBU1R2MS5Ob2RlKTogLTEgfCAwIHwgMSB7XG4gIC8vIElmIGVpdGhlciBpcyBpbnZpc2libGUsIGRvbid0IHRyeSB0byBvcmRlciB0aGVtXG4gIGlmIChhLmxvYy5pc0ludmlzaWJsZSB8fCBiLmxvYy5pc0ludmlzaWJsZSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGEubG9jLnN0YXJ0UG9zaXRpb24ubGluZSA8IGIubG9jLnN0YXJ0UG9zaXRpb24ubGluZSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChcbiAgICBhLmxvYy5zdGFydFBvc2l0aW9uLmxpbmUgPT09IGIubG9jLnN0YXJ0UG9zaXRpb24ubGluZSAmJlxuICAgIGEubG9jLnN0YXJ0UG9zaXRpb24uY29sdW1uIDwgYi5sb2Muc3RhcnRQb3NpdGlvbi5jb2x1bW5cbiAgKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKFxuICAgIGEubG9jLnN0YXJ0UG9zaXRpb24ubGluZSA9PT0gYi5sb2Muc3RhcnRQb3NpdGlvbi5saW5lICYmXG4gICAgYS5sb2Muc3RhcnRQb3NpdGlvbi5jb2x1bW4gPT09IGIubG9jLnN0YXJ0UG9zaXRpb24uY29sdW1uXG4gICkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIDE7XG59XG4iLCJpbXBvcnQgKiBhcyBBU1R2MSBmcm9tICcuLi92MS9hcGknO1xuaW1wb3J0IHsgZXNjYXBlQXR0clZhbHVlLCBlc2NhcGVUZXh0LCBzb3J0QnlMb2MgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgY29uc3Qgdm9pZE1hcDoge1xuICBbdGFnTmFtZTogc3RyaW5nXTogYm9vbGVhbjtcbn0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5sZXQgdm9pZFRhZ05hbWVzID1cbiAgJ2FyZWEgYmFzZSBiciBjb2wgY29tbWFuZCBlbWJlZCBociBpbWcgaW5wdXQga2V5Z2VuIGxpbmsgbWV0YSBwYXJhbSBzb3VyY2UgdHJhY2sgd2JyJztcbnZvaWRUYWdOYW1lcy5zcGxpdCgnICcpLmZvckVhY2goKHRhZ05hbWUpID0+IHtcbiAgdm9pZE1hcFt0YWdOYW1lXSA9IHRydWU7XG59KTtcblxuY29uc3QgTk9OX1dISVRFU1BBQ0UgPSAvXFxTLztcblxuZXhwb3J0IGludGVyZmFjZSBQcmludGVyT3B0aW9ucyB7XG4gIGVudGl0eUVuY29kaW5nOiAndHJhbnNmb3JtZWQnIHwgJ3Jhdyc7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gb3ZlcnJpZGUgdGhlIG1lY2hhbmlzbSBvZiBwcmludGluZyBhIGdpdmVuIEFTVC5Ob2RlLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgZ2VuZXJhbGx5IG9ubHkgYmUgdXNlZnVsIHRvIHNvdXJjZSAtPiBzb3VyY2UgY29kZW1vZHNcbiAgICogd2hlcmUgeW91IHdvdWxkIGxpa2UgdG8gc3BlY2lhbGl6ZS9vdmVycmlkZSB0aGUgd2F5IGEgZ2l2ZW4gbm9kZSBpc1xuICAgKiBwcmludGVkIChlLmcuIHlvdSB3b3VsZCBsaWtlIHRvIHByZXNlcnZlIGFzIG11Y2ggb2YgdGhlIG9yaWdpbmFsXG4gICAqIGZvcm1hdHRpbmcgYXMgcG9zc2libGUpLlxuICAgKlxuICAgKiBXaGVuIHRoZSBwcm92aWRlZCBvdmVycmlkZSByZXR1cm5zIHVuZGVmaW5lZCwgdGhlIGRlZmF1bHQgYnVpbHQgaW4gcHJpbnRpbmdcbiAgICogd2lsbCBiZSBkb25lIGZvciB0aGUgQVNULk5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhc3QgdGhlIGFzdCBub2RlIHRvIGJlIHByaW50ZWRcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgc3BlY2lmaWVkIGR1cmluZyB0aGUgcHJpbnQoKSBpbnZvY2F0aW9uXG4gICAqL1xuICBvdmVycmlkZT8oYXN0OiBBU1R2MS5Ob2RlLCBvcHRpb25zOiBQcmludGVyT3B0aW9ucyk6IHZvaWQgfCBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByaW50ZXIge1xuICBwcml2YXRlIGJ1ZmZlciA9ICcnO1xuICBwcml2YXRlIG9wdGlvbnM6IFByaW50ZXJPcHRpb25zO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFByaW50ZXJPcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qXG4gICAgVGhpcyBpcyB1c2VkIGJ5IF9hbGxfIG1ldGhvZHMgb24gdGhpcyBQcmludGVyIGNsYXNzIHRoYXQgYWRkIHRvIGB0aGlzLmJ1ZmZlcmAsXG4gICAgaXQgYWxsb3dzIGNvbnN1bWVycyBvZiB0aGUgcHJpbnRlciB0byB1c2UgYWx0ZXJuYXRlIHN0cmluZyByZXByZXNlbnRhdGlvbnMgZm9yXG4gICAgYSBnaXZlbiBub2RlLlxuXG4gICAgVGhlIHByaW1hcnkgdXNlIGNhc2UgZm9yIHRoaXMgYXJlIHRoaW5ncyBsaWtlIHNvdXJjZSAtPiBzb3VyY2UgY29kZW1vZCB1dGlsaXRpZXMuXG4gICAgRm9yIGV4YW1wbGUsIGVtYmVyLXRlbXBsYXRlLXJlY2FzdCBhdHRlbXB0cyB0byBhbHdheXMgcHJlc2VydmUgdGhlIG9yaWdpbmFsIHN0cmluZ1xuICAgIGZvcm1hdHRpbmcgaW4gZWFjaCBBU1Qgbm9kZSBpZiBubyBtb2RpZmljYXRpb25zIGFyZSBtYWRlIHRvIGl0LlxuICAqL1xuICBoYW5kbGVkQnlPdmVycmlkZShub2RlOiBBU1R2MS5Ob2RlLCBlbnN1cmVMZWFkaW5nV2hpdGVzcGFjZSA9IGZhbHNlKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vdmVycmlkZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5vcHRpb25zLm92ZXJyaWRlKG5vZGUsIHRoaXMub3B0aW9ucyk7XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGVuc3VyZUxlYWRpbmdXaGl0ZXNwYWNlICYmIHJlc3VsdCAhPT0gJycgJiYgTk9OX1dISVRFU1BBQ0UudGVzdChyZXN1bHRbMF0pKSB7XG4gICAgICAgICAgcmVzdWx0ID0gYCAke3Jlc3VsdH1gO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWZmZXIgKz0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBOb2RlKG5vZGU6IEFTVHYxLk5vZGUpOiB2b2lkIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSAnTXVzdGFjaGVTdGF0ZW1lbnQnOlxuICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuICAgICAgY2FzZSAnUGFydGlhbFN0YXRlbWVudCc6XG4gICAgICBjYXNlICdNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQnOlxuICAgICAgY2FzZSAnQ29tbWVudFN0YXRlbWVudCc6XG4gICAgICBjYXNlICdUZXh0Tm9kZSc6XG4gICAgICBjYXNlICdFbGVtZW50Tm9kZSc6XG4gICAgICBjYXNlICdBdHRyTm9kZSc6XG4gICAgICBjYXNlICdCbG9jayc6XG4gICAgICBjYXNlICdUZW1wbGF0ZSc6XG4gICAgICAgIHJldHVybiB0aGlzLlRvcExldmVsU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSAnU3RyaW5nTGl0ZXJhbCc6XG4gICAgICBjYXNlICdCb29sZWFuTGl0ZXJhbCc6XG4gICAgICBjYXNlICdOdW1iZXJMaXRlcmFsJzpcbiAgICAgIGNhc2UgJ1VuZGVmaW5lZExpdGVyYWwnOlxuICAgICAgY2FzZSAnTnVsbExpdGVyYWwnOlxuICAgICAgY2FzZSAnUGF0aEV4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnU3ViRXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiB0aGlzLkV4cHJlc3Npb24obm9kZSk7XG4gICAgICBjYXNlICdQcm9ncmFtJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuQmxvY2sobm9kZSk7XG4gICAgICBjYXNlICdDb25jYXRTdGF0ZW1lbnQnOlxuICAgICAgICAvLyBzaG91bGQgaGF2ZSBhbiBBdHRyTm9kZSBwYXJlbnRcbiAgICAgICAgcmV0dXJuIHRoaXMuQ29uY2F0U3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSAnSGFzaCc6XG4gICAgICAgIHJldHVybiB0aGlzLkhhc2gobm9kZSk7XG4gICAgICBjYXNlICdIYXNoUGFpcic6XG4gICAgICAgIHJldHVybiB0aGlzLkhhc2hQYWlyKG5vZGUpO1xuICAgICAgY2FzZSAnRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50KG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIEV4cHJlc3Npb24oZXhwcmVzc2lvbjogQVNUdjEuRXhwcmVzc2lvbik6IHZvaWQge1xuICAgIHN3aXRjaCAoZXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzpcbiAgICAgIGNhc2UgJ0Jvb2xlYW5MaXRlcmFsJzpcbiAgICAgIGNhc2UgJ051bWJlckxpdGVyYWwnOlxuICAgICAgY2FzZSAnVW5kZWZpbmVkTGl0ZXJhbCc6XG4gICAgICBjYXNlICdOdWxsTGl0ZXJhbCc6XG4gICAgICAgIHJldHVybiB0aGlzLkxpdGVyYWwoZXhwcmVzc2lvbik7XG4gICAgICBjYXNlICdQYXRoRXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiB0aGlzLlBhdGhFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgICAgY2FzZSAnU3ViRXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiB0aGlzLlN1YkV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gICAgfVxuICB9XG5cbiAgTGl0ZXJhbChsaXRlcmFsOiBBU1R2MS5MaXRlcmFsKTogdm9pZCB7XG4gICAgc3dpdGNoIChsaXRlcmFsLnR5cGUpIHtcbiAgICAgIGNhc2UgJ1N0cmluZ0xpdGVyYWwnOlxuICAgICAgICByZXR1cm4gdGhpcy5TdHJpbmdMaXRlcmFsKGxpdGVyYWwpO1xuICAgICAgY2FzZSAnQm9vbGVhbkxpdGVyYWwnOlxuICAgICAgICByZXR1cm4gdGhpcy5Cb29sZWFuTGl0ZXJhbChsaXRlcmFsKTtcbiAgICAgIGNhc2UgJ051bWJlckxpdGVyYWwnOlxuICAgICAgICByZXR1cm4gdGhpcy5OdW1iZXJMaXRlcmFsKGxpdGVyYWwpO1xuICAgICAgY2FzZSAnVW5kZWZpbmVkTGl0ZXJhbCc6XG4gICAgICAgIHJldHVybiB0aGlzLlVuZGVmaW5lZExpdGVyYWwobGl0ZXJhbCk7XG4gICAgICBjYXNlICdOdWxsTGl0ZXJhbCc6XG4gICAgICAgIHJldHVybiB0aGlzLk51bGxMaXRlcmFsKGxpdGVyYWwpO1xuICAgIH1cbiAgfVxuXG4gIFRvcExldmVsU3RhdGVtZW50KHN0YXRlbWVudDogQVNUdjEuVG9wTGV2ZWxTdGF0ZW1lbnQgfCBBU1R2MS5UZW1wbGF0ZSB8IEFTVHYxLkF0dHJOb2RlKTogdm9pZCB7XG4gICAgc3dpdGNoIChzdGF0ZW1lbnQudHlwZSkge1xuICAgICAgY2FzZSAnTXVzdGFjaGVTdGF0ZW1lbnQnOlxuICAgICAgICByZXR1cm4gdGhpcy5NdXN0YWNoZVN0YXRlbWVudChzdGF0ZW1lbnQpO1xuICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuICAgICAgICByZXR1cm4gdGhpcy5CbG9ja1N0YXRlbWVudChzdGF0ZW1lbnQpO1xuICAgICAgY2FzZSAnUGFydGlhbFN0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLlBhcnRpYWxTdGF0ZW1lbnQoc3RhdGVtZW50KTtcbiAgICAgIGNhc2UgJ011c3RhY2hlQ29tbWVudFN0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudChzdGF0ZW1lbnQpO1xuICAgICAgY2FzZSAnQ29tbWVudFN0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLkNvbW1lbnRTdGF0ZW1lbnQoc3RhdGVtZW50KTtcbiAgICAgIGNhc2UgJ1RleHROb2RlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuVGV4dE5vZGUoc3RhdGVtZW50KTtcbiAgICAgIGNhc2UgJ0VsZW1lbnROb2RlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuRWxlbWVudE5vZGUoc3RhdGVtZW50KTtcbiAgICAgIGNhc2UgJ0Jsb2NrJzpcbiAgICAgIGNhc2UgJ1RlbXBsYXRlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuQmxvY2soc3RhdGVtZW50KTtcbiAgICAgIGNhc2UgJ0F0dHJOb2RlJzpcbiAgICAgICAgLy8gc2hvdWxkIGhhdmUgZWxlbWVudFxuICAgICAgICByZXR1cm4gdGhpcy5BdHRyTm9kZShzdGF0ZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIEJsb2NrKGJsb2NrOiBBU1R2MS5CbG9jayB8IEFTVHYxLlByb2dyYW0gfCBBU1R2MS5UZW1wbGF0ZSk6IHZvaWQge1xuICAgIC8qXG4gICAgICBXaGVuIHByb2Nlc3NpbmcgYSB0ZW1wbGF0ZSBsaWtlOlxuXG4gICAgICBgYGBoYnNcbiAgICAgIHt7I2lmIHdoYXRldmVyfX1cbiAgICAgICAgd2hhdGV2ZXJcbiAgICAgIHt7ZWxzZSBpZiBzb21ldGhpbmdFbHNlfX1cbiAgICAgICAgc29tZXRoaW5nIGVsc2VcbiAgICAgIHt7ZWxzZX19XG4gICAgICAgIGZhbGxiYWNrXG4gICAgICB7ey9pZn19XG4gICAgICBgYGBcblxuICAgICAgVGhlIEFTVCBzdGlsbCBfZWZmZWN0aXZlbHlfIGxvb2tzIGxpa2U6XG5cbiAgICAgIGBgYGhic1xuICAgICAge3sjaWYgd2hhdGV2ZXJ9fVxuICAgICAgICB3aGF0ZXZlclxuICAgICAge3tlbHNlfX17eyNpZiBzb21ldGhpbmdFbHNlfX1cbiAgICAgICAgc29tZXRoaW5nIGVsc2VcbiAgICAgIHt7ZWxzZX19XG4gICAgICAgIGZhbGxiYWNrXG4gICAgICB7ey9pZn19e3svaWZ9fVxuICAgICAgYGBgXG5cbiAgICAgIFRoZSBvbmx5IHdheSB3ZSBjYW4gdGVsbCBpZiB0aGF0IGlzIHRoZSBjYXNlIGlzIGJ5IGNoZWNraW5nIGZvclxuICAgICAgYGJsb2NrLmNoYWluZWRgLCBidXQgdW5mb3J0dW5hdGVseSB3aGVuIHRoZSBhY3R1YWwgc3RhdGVtZW50cyBhcmVcbiAgICAgIHByb2Nlc3NlZCB0aGUgYGJsb2NrLmJvZHlbMF1gIG5vZGUgKHdoaWNoIHdpbGwgYWx3YXlzIGJlIGFcbiAgICAgIGBCbG9ja1N0YXRlbWVudGApIGhhcyBubyBjbHVlIHRoYXQgaXRzIGFuY2VzdG9yIGBCbG9ja2Agbm9kZSB3YXNcbiAgICAgIGNoYWluZWQuXG5cbiAgICAgIFRoaXMgXCJmb3J3YXJkc1wiIHRoZSBgY2hhaW5lZGAgc2V0dGluZyBzbyB0aGF0IHdlIGNhbiBjaGVja1xuICAgICAgaXQgbGF0ZXIgd2hlbiBwcm9jZXNzaW5nIHRoZSBgQmxvY2tTdGF0ZW1lbnRgLlxuICAgICovXG4gICAgaWYgKGJsb2NrLmNoYWluZWQpIHtcbiAgICAgIGxldCBmaXJzdENoaWxkID0gYmxvY2suYm9keVswXSBhcyBBU1R2MS5CbG9ja1N0YXRlbWVudDtcbiAgICAgIGZpcnN0Q2hpbGQuY2hhaW5lZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUoYmxvY2spKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5Ub3BMZXZlbFN0YXRlbWVudHMoYmxvY2suYm9keSk7XG4gIH1cblxuICBUb3BMZXZlbFN0YXRlbWVudHMoc3RhdGVtZW50czogQVNUdjEuVG9wTGV2ZWxTdGF0ZW1lbnRbXSk6IHZvaWQge1xuICAgIHN0YXRlbWVudHMuZm9yRWFjaCgoc3RhdGVtZW50KSA9PiB0aGlzLlRvcExldmVsU3RhdGVtZW50KHN0YXRlbWVudCkpO1xuICB9XG5cbiAgRWxlbWVudE5vZGUoZWw6IEFTVHYxLkVsZW1lbnROb2RlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUoZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5PcGVuRWxlbWVudE5vZGUoZWwpO1xuICAgIHRoaXMuVG9wTGV2ZWxTdGF0ZW1lbnRzKGVsLmNoaWxkcmVuKTtcbiAgICB0aGlzLkNsb3NlRWxlbWVudE5vZGUoZWwpO1xuICB9XG5cbiAgT3BlbkVsZW1lbnROb2RlKGVsOiBBU1R2MS5FbGVtZW50Tm9kZSk6IHZvaWQge1xuICAgIHRoaXMuYnVmZmVyICs9IGA8JHtlbC50YWd9YDtcbiAgICBjb25zdCBwYXJ0cyA9IFsuLi5lbC5hdHRyaWJ1dGVzLCAuLi5lbC5tb2RpZmllcnMsIC4uLmVsLmNvbW1lbnRzXS5zb3J0KHNvcnRCeUxvYyk7XG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIHRoaXMuYnVmZmVyICs9ICcgJztcbiAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0F0dHJOb2RlJzpcbiAgICAgICAgICB0aGlzLkF0dHJOb2RlKHBhcnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnQnOlxuICAgICAgICAgIHRoaXMuRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50KHBhcnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQnOlxuICAgICAgICAgIHRoaXMuTXVzdGFjaGVDb21tZW50U3RhdGVtZW50KHBhcnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWwuYmxvY2tQYXJhbXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLkJsb2NrUGFyYW1zKGVsLmJsb2NrUGFyYW1zKTtcbiAgICB9XG4gICAgaWYgKGVsLnNlbGZDbG9zaW5nKSB7XG4gICAgICB0aGlzLmJ1ZmZlciArPSAnIC8nO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlciArPSAnPic7XG4gIH1cblxuICBDbG9zZUVsZW1lbnROb2RlKGVsOiBBU1R2MS5FbGVtZW50Tm9kZSk6IHZvaWQge1xuICAgIGlmIChlbC5zZWxmQ2xvc2luZyB8fCB2b2lkTWFwW2VsLnRhZy50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlciArPSBgPC8ke2VsLnRhZ30+YDtcbiAgfVxuXG4gIEF0dHJOb2RlKGF0dHI6IEFTVHYxLkF0dHJOb2RlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUoYXR0cikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgeyBuYW1lLCB2YWx1ZSB9ID0gYXR0cjtcblxuICAgIHRoaXMuYnVmZmVyICs9IG5hbWU7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09ICdUZXh0Tm9kZScgfHwgdmFsdWUuY2hhcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5idWZmZXIgKz0gJz0nO1xuICAgICAgdGhpcy5BdHRyTm9kZVZhbHVlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBBdHRyTm9kZVZhbHVlKHZhbHVlOiBBU1R2MS5BdHRyTm9kZVsndmFsdWUnXSk6IHZvaWQge1xuICAgIGlmICh2YWx1ZS50eXBlID09PSAnVGV4dE5vZGUnKSB7XG4gICAgICB0aGlzLmJ1ZmZlciArPSAnXCInO1xuICAgICAgdGhpcy5UZXh0Tm9kZSh2YWx1ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmJ1ZmZlciArPSAnXCInO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLk5vZGUodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIFRleHROb2RlKHRleHQ6IEFTVHYxLlRleHROb2RlLCBpc0F0dHI/OiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUodGV4dCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmVudGl0eUVuY29kaW5nID09PSAncmF3Jykge1xuICAgICAgdGhpcy5idWZmZXIgKz0gdGV4dC5jaGFycztcbiAgICB9IGVsc2UgaWYgKGlzQXR0cikge1xuICAgICAgdGhpcy5idWZmZXIgKz0gZXNjYXBlQXR0clZhbHVlKHRleHQuY2hhcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlciArPSBlc2NhcGVUZXh0KHRleHQuY2hhcnMpO1xuICAgIH1cbiAgfVxuXG4gIE11c3RhY2hlU3RhdGVtZW50KG11c3RhY2hlOiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKG11c3RhY2hlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyICs9IG11c3RhY2hlLmVzY2FwZWQgPyAne3snIDogJ3t7eyc7XG5cbiAgICBpZiAobXVzdGFjaGUuc3RyaXAub3Blbikge1xuICAgICAgdGhpcy5idWZmZXIgKz0gJ34nO1xuICAgIH1cblxuICAgIHRoaXMuRXhwcmVzc2lvbihtdXN0YWNoZS5wYXRoKTtcbiAgICB0aGlzLlBhcmFtcyhtdXN0YWNoZS5wYXJhbXMpO1xuICAgIHRoaXMuSGFzaChtdXN0YWNoZS5oYXNoKTtcblxuICAgIGlmIChtdXN0YWNoZS5zdHJpcC5jbG9zZSkge1xuICAgICAgdGhpcy5idWZmZXIgKz0gJ34nO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyICs9IG11c3RhY2hlLmVzY2FwZWQgPyAnfX0nIDogJ319fSc7XG4gIH1cblxuICBCbG9ja1N0YXRlbWVudChibG9jazogQVNUdjEuQmxvY2tTdGF0ZW1lbnQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5oYW5kbGVkQnlPdmVycmlkZShibG9jaykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYmxvY2suY2hhaW5lZCkge1xuICAgICAgdGhpcy5idWZmZXIgKz0gYmxvY2suaW52ZXJzZVN0cmlwLm9wZW4gPyAne3t+JyA6ICd7eyc7XG4gICAgICB0aGlzLmJ1ZmZlciArPSAnZWxzZSAnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlciArPSBibG9jay5vcGVuU3RyaXAub3BlbiA/ICd7e34jJyA6ICd7eyMnO1xuICAgIH1cblxuICAgIHRoaXMuRXhwcmVzc2lvbihibG9jay5wYXRoKTtcbiAgICB0aGlzLlBhcmFtcyhibG9jay5wYXJhbXMpO1xuICAgIHRoaXMuSGFzaChibG9jay5oYXNoKTtcbiAgICBpZiAoYmxvY2sucHJvZ3JhbS5ibG9ja1BhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuQmxvY2tQYXJhbXMoYmxvY2sucHJvZ3JhbS5ibG9ja1BhcmFtcyk7XG4gICAgfVxuXG4gICAgaWYgKGJsb2NrLmNoYWluZWQpIHtcbiAgICAgIHRoaXMuYnVmZmVyICs9IGJsb2NrLmludmVyc2VTdHJpcC5jbG9zZSA/ICd+fX0nIDogJ319JztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5idWZmZXIgKz0gYmxvY2sub3BlblN0cmlwLmNsb3NlID8gJ359fScgOiAnfX0nO1xuICAgIH1cblxuICAgIHRoaXMuQmxvY2soYmxvY2sucHJvZ3JhbSk7XG5cbiAgICBpZiAoYmxvY2suaW52ZXJzZSkge1xuICAgICAgaWYgKCFibG9jay5pbnZlcnNlLmNoYWluZWQpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gYmxvY2suaW52ZXJzZVN0cmlwLm9wZW4gPyAne3t+JyA6ICd7eyc7XG4gICAgICAgIHRoaXMuYnVmZmVyICs9ICdlbHNlJztcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gYmxvY2suaW52ZXJzZVN0cmlwLmNsb3NlID8gJ359fScgOiAnfX0nO1xuICAgICAgfVxuXG4gICAgICB0aGlzLkJsb2NrKGJsb2NrLmludmVyc2UpO1xuICAgIH1cblxuICAgIGlmICghYmxvY2suY2hhaW5lZCkge1xuICAgICAgdGhpcy5idWZmZXIgKz0gYmxvY2suY2xvc2VTdHJpcC5vcGVuID8gJ3t7fi8nIDogJ3t7Lyc7XG4gICAgICB0aGlzLkV4cHJlc3Npb24oYmxvY2sucGF0aCk7XG4gICAgICB0aGlzLmJ1ZmZlciArPSBibG9jay5jbG9zZVN0cmlwLmNsb3NlID8gJ359fScgOiAnfX0nO1xuICAgIH1cbiAgfVxuXG4gIEJsb2NrUGFyYW1zKGJsb2NrUGFyYW1zOiBzdHJpbmdbXSk6IHZvaWQge1xuICAgIHRoaXMuYnVmZmVyICs9IGAgYXMgfCR7YmxvY2tQYXJhbXMuam9pbignICcpfXxgO1xuICB9XG5cbiAgUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsOiBBU1R2MS5QYXJ0aWFsU3RhdGVtZW50KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUocGFydGlhbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciArPSAne3s+JztcbiAgICB0aGlzLkV4cHJlc3Npb24ocGFydGlhbC5uYW1lKTtcbiAgICB0aGlzLlBhcmFtcyhwYXJ0aWFsLnBhcmFtcyk7XG4gICAgdGhpcy5IYXNoKHBhcnRpYWwuaGFzaCk7XG4gICAgdGhpcy5idWZmZXIgKz0gJ319JztcbiAgfVxuXG4gIENvbmNhdFN0YXRlbWVudChjb25jYXQ6IEFTVHYxLkNvbmNhdFN0YXRlbWVudCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKGNvbmNhdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciArPSAnXCInO1xuICAgIGNvbmNhdC5wYXJ0cy5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICBpZiAocGFydC50eXBlID09PSAnVGV4dE5vZGUnKSB7XG4gICAgICAgIHRoaXMuVGV4dE5vZGUocGFydCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLk5vZGUocGFydCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5idWZmZXIgKz0gJ1wiJztcbiAgfVxuXG4gIE11c3RhY2hlQ29tbWVudFN0YXRlbWVudChjb21tZW50OiBBU1R2MS5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5oYW5kbGVkQnlPdmVycmlkZShjb21tZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyICs9IGB7eyEtLSR7Y29tbWVudC52YWx1ZX0tLX19YDtcbiAgfVxuXG4gIEVsZW1lbnRNb2RpZmllclN0YXRlbWVudChtb2Q6IEFTVHYxLkVsZW1lbnRNb2RpZmllclN0YXRlbWVudCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKG1vZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciArPSAne3snO1xuICAgIHRoaXMuRXhwcmVzc2lvbihtb2QucGF0aCk7XG4gICAgdGhpcy5QYXJhbXMobW9kLnBhcmFtcyk7XG4gICAgdGhpcy5IYXNoKG1vZC5oYXNoKTtcbiAgICB0aGlzLmJ1ZmZlciArPSAnfX0nO1xuICB9XG5cbiAgQ29tbWVudFN0YXRlbWVudChjb21tZW50OiBBU1R2MS5Db21tZW50U3RhdGVtZW50KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUoY29tbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciArPSBgPCEtLSR7Y29tbWVudC52YWx1ZX0tLT5gO1xuICB9XG5cbiAgUGF0aEV4cHJlc3Npb24ocGF0aDogQVNUdjEuUGF0aEV4cHJlc3Npb24pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5oYW5kbGVkQnlPdmVycmlkZShwYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyICs9IHBhdGgub3JpZ2luYWw7XG4gIH1cblxuICBTdWJFeHByZXNzaW9uKHNleHA6IEFTVHYxLlN1YkV4cHJlc3Npb24pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5oYW5kbGVkQnlPdmVycmlkZShzZXhwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyICs9ICcoJztcbiAgICB0aGlzLkV4cHJlc3Npb24oc2V4cC5wYXRoKTtcbiAgICB0aGlzLlBhcmFtcyhzZXhwLnBhcmFtcyk7XG4gICAgdGhpcy5IYXNoKHNleHAuaGFzaCk7XG4gICAgdGhpcy5idWZmZXIgKz0gJyknO1xuICB9XG5cbiAgUGFyYW1zKHBhcmFtczogQVNUdjEuRXhwcmVzc2lvbltdKTogdm9pZCB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGEgdG9wIGxldmVsIFBhcmFtcyBBU1Qgbm9kZSAoanVzdCBsaWtlIHRoZSBIYXNoIG9iamVjdClcbiAgICAvLyBzbyB0aGF0IHRoaXMgY2FuIGFsc28gYmUgb3ZlcnJpZGRlblxuICAgIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgICBwYXJhbXMuZm9yRWFjaCgocGFyYW0pID0+IHtcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gJyAnO1xuICAgICAgICB0aGlzLkV4cHJlc3Npb24ocGFyYW0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgSGFzaChoYXNoOiBBU1R2MS5IYXNoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUoaGFzaCwgdHJ1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYXNoLnBhaXJzLmZvckVhY2goKHBhaXIpID0+IHtcbiAgICAgIHRoaXMuYnVmZmVyICs9ICcgJztcbiAgICAgIHRoaXMuSGFzaFBhaXIocGFpcik7XG4gICAgfSk7XG4gIH1cblxuICBIYXNoUGFpcihwYWlyOiBBU1R2MS5IYXNoUGFpcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKHBhaXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgKz0gcGFpci5rZXk7XG4gICAgdGhpcy5idWZmZXIgKz0gJz0nO1xuICAgIHRoaXMuTm9kZShwYWlyLnZhbHVlKTtcbiAgfVxuXG4gIFN0cmluZ0xpdGVyYWwoc3RyOiBBU1R2MS5TdHJpbmdMaXRlcmFsKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUoc3RyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyICs9IEpTT04uc3RyaW5naWZ5KHN0ci52YWx1ZSk7XG4gIH1cblxuICBCb29sZWFuTGl0ZXJhbChib29sOiBBU1R2MS5Cb29sZWFuTGl0ZXJhbCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKGJvb2wpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgKz0gYm9vbC52YWx1ZTtcbiAgfVxuXG4gIE51bWJlckxpdGVyYWwobnVtYmVyOiBBU1R2MS5OdW1iZXJMaXRlcmFsKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUobnVtYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyICs9IG51bWJlci52YWx1ZTtcbiAgfVxuXG4gIFVuZGVmaW5lZExpdGVyYWwobm9kZTogQVNUdjEuVW5kZWZpbmVkTGl0ZXJhbCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKG5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgKz0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBOdWxsTGl0ZXJhbChub2RlOiBBU1R2MS5OdWxsTGl0ZXJhbCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKG5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgKz0gJ251bGwnO1xuICB9XG5cbiAgcHJpbnQobm9kZTogQVNUdjEuTm9kZSk6IHN0cmluZyB7XG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gdGhpcztcblxuICAgIGlmIChvcHRpb25zLm92ZXJyaWRlKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gb3B0aW9ucy5vdmVycmlkZShub2RlLCBvcHRpb25zKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICB0aGlzLk5vZGUobm9kZSk7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBBU1R2MSBmcm9tICcuLi92MS9hcGknO1xuaW1wb3J0IFByaW50ZXIsIHsgUHJpbnRlck9wdGlvbnMgfSBmcm9tICcuL3ByaW50ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZChcbiAgYXN0OiBBU1R2MS5Ob2RlLFxuICBvcHRpb25zOiBQcmludGVyT3B0aW9ucyA9IHsgZW50aXR5RW5jb2Rpbmc6ICd0cmFuc2Zvcm1lZCcgfVxuKTogc3RyaW5nIHtcbiAgaWYgKCFhc3QpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBsZXQgcHJpbnRlciA9IG5ldyBQcmludGVyKG9wdGlvbnMpO1xuICByZXR1cm4gcHJpbnRlci5wcmludChhc3QpO1xufVxuIiwiaW1wb3J0IHsgU291cmNlU3BhbiB9IGZyb20gJy4vc291cmNlL3NwYW4nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdsaW1tZXJTeW50YXhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgbG9jYXRpb246IFNvdXJjZVNwYW4gfCBudWxsO1xuICBjb2RlOiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTeW50YXhFcnJvcihtZXNzYWdlOiBzdHJpbmcsIGxvY2F0aW9uOiBTb3VyY2VTcGFuKTogR2xpbW1lclN5bnRheEVycm9yIHtcbiAgbGV0IHsgbW9kdWxlLCBsb2MgfSA9IGxvY2F0aW9uO1xuICBsZXQgeyBsaW5lLCBjb2x1bW4gfSA9IGxvYy5zdGFydDtcblxuICBsZXQgY29kZSA9IGxvY2F0aW9uLmFzU3RyaW5nKCk7XG4gIGxldCBxdW90ZWRDb2RlID0gY29kZSA/IGBcXG5cXG58XFxufCAgJHtjb2RlLnNwbGl0KCdcXG4nKS5qb2luKCdcXG58ICAnKX1cXG58XFxuXFxuYCA6ICcnO1xuXG4gIGxldCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICBgJHttZXNzYWdlfTogJHtxdW90ZWRDb2RlfShlcnJvciBvY2N1cnJlZCBpbiAnJHttb2R1bGV9JyBAIGxpbmUgJHtsaW5lfSA6IGNvbHVtbiAke2NvbHVtbn0pYFxuICApIGFzIEdsaW1tZXJTeW50YXhFcnJvcjtcblxuICBlcnJvci5uYW1lID0gJ1N5bnRheEVycm9yJztcbiAgZXJyb3IubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgZXJyb3IuY29kZSA9IGNvZGU7XG5cbiAgcmV0dXJuIGVycm9yO1xufVxuIiwiaW1wb3J0IHsgdHVwbGUgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcblxuaW1wb3J0ICogYXMgQVNUdjEgZnJvbSAnLi9hcGknO1xuXG4vLyBlbnN1cmUgc3RheXMgaW4gc3luYyB3aXRoIHR5cGluZ1xuLy8gUGFyZW50Tm9kZSBhbmQgQ2hpbGRLZXkgdHlwZXMgYXJlIGRlcml2ZWQgZnJvbSBWaXNpdG9yS2V5c01hcFxuY29uc3QgdmlzaXRvcktleXMgPSB7XG4gIFByb2dyYW06IHR1cGxlKCdib2R5JyksXG4gIFRlbXBsYXRlOiB0dXBsZSgnYm9keScpLFxuICBCbG9jazogdHVwbGUoJ2JvZHknKSxcblxuICBNdXN0YWNoZVN0YXRlbWVudDogdHVwbGUoJ3BhdGgnLCAncGFyYW1zJywgJ2hhc2gnKSxcbiAgQmxvY2tTdGF0ZW1lbnQ6IHR1cGxlKCdwYXRoJywgJ3BhcmFtcycsICdoYXNoJywgJ3Byb2dyYW0nLCAnaW52ZXJzZScpLFxuICBFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnQ6IHR1cGxlKCdwYXRoJywgJ3BhcmFtcycsICdoYXNoJyksXG4gIFBhcnRpYWxTdGF0ZW1lbnQ6IHR1cGxlKCduYW1lJywgJ3BhcmFtcycsICdoYXNoJyksXG4gIENvbW1lbnRTdGF0ZW1lbnQ6IHR1cGxlKCksXG4gIE11c3RhY2hlQ29tbWVudFN0YXRlbWVudDogdHVwbGUoKSxcbiAgRWxlbWVudE5vZGU6IHR1cGxlKCdhdHRyaWJ1dGVzJywgJ21vZGlmaWVycycsICdjaGlsZHJlbicsICdjb21tZW50cycpLFxuICBBdHRyTm9kZTogdHVwbGUoJ3ZhbHVlJyksXG4gIFRleHROb2RlOiB0dXBsZSgpLFxuXG4gIENvbmNhdFN0YXRlbWVudDogdHVwbGUoJ3BhcnRzJyksXG4gIFN1YkV4cHJlc3Npb246IHR1cGxlKCdwYXRoJywgJ3BhcmFtcycsICdoYXNoJyksXG4gIFBhdGhFeHByZXNzaW9uOiB0dXBsZSgpLFxuICBQYXRoSGVhZDogdHVwbGUoKSxcblxuICBTdHJpbmdMaXRlcmFsOiB0dXBsZSgpLFxuICBCb29sZWFuTGl0ZXJhbDogdHVwbGUoKSxcbiAgTnVtYmVyTGl0ZXJhbDogdHVwbGUoKSxcbiAgTnVsbExpdGVyYWw6IHR1cGxlKCksXG4gIFVuZGVmaW5lZExpdGVyYWw6IHR1cGxlKCksXG5cbiAgSGFzaDogdHVwbGUoJ3BhaXJzJyksXG4gIEhhc2hQYWlyOiB0dXBsZSgndmFsdWUnKSxcblxuICAvLyB2MiBuZXcgbm9kZXNcbiAgTmFtZWRCbG9jazogdHVwbGUoJ2F0dHJpYnV0ZXMnLCAnbW9kaWZpZXJzJywgJ2NoaWxkcmVuJywgJ2NvbW1lbnRzJyksXG4gIFNpbXBsZUVsZW1lbnQ6IHR1cGxlKCdhdHRyaWJ1dGVzJywgJ21vZGlmaWVycycsICdjaGlsZHJlbicsICdjb21tZW50cycpLFxuICBDb21wb25lbnQ6IHR1cGxlKCdoZWFkJywgJ2F0dHJpYnV0ZXMnLCAnbW9kaWZpZXJzJywgJ2NoaWxkcmVuJywgJ2NvbW1lbnRzJyksXG59O1xuXG50eXBlIFZpc2l0b3JLZXlzTWFwID0gdHlwZW9mIHZpc2l0b3JLZXlzO1xuXG5leHBvcnQgdHlwZSBWaXNpdG9yS2V5cyA9IHsgW1AgaW4ga2V5b2YgVmlzaXRvcktleXNNYXBdOiBWaXNpdG9yS2V5c01hcFtQXVtudW1iZXJdIH07XG5leHBvcnQgdHlwZSBWaXNpdG9yS2V5PE4gZXh0ZW5kcyBBU1R2MS5Ob2RlPiA9IFZpc2l0b3JLZXlzW05bJ3R5cGUnXV0gJiBrZXlvZiBOO1xuXG5leHBvcnQgZGVmYXVsdCB2aXNpdG9yS2V5cztcbiIsImltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuXG5pbXBvcnQgKiBhcyBBU1R2MSBmcm9tICcuLi92MS9hcGknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYXZlcnNhbEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcjogVHJhdmVyc2FsRXJyb3JDb25zdHJ1Y3RvcjtcbiAga2V5OiBzdHJpbmc7XG4gIG5vZGU6IEFTVHYxLk5vZGU7XG4gIHBhcmVudDogT3B0aW9uPEFTVHYxLk5vZGU+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYXZlcnNhbEVycm9yQ29uc3RydWN0b3Ige1xuICBuZXcgKG1lc3NhZ2U6IHN0cmluZywgbm9kZTogQVNUdjEuTm9kZSwgcGFyZW50OiBPcHRpb248QVNUdjEuTm9kZT4sIGtleTogc3RyaW5nKTogVHJhdmVyc2FsRXJyb3I7XG4gIHJlYWRvbmx5IHByb3RvdHlwZTogVHJhdmVyc2FsRXJyb3I7XG59XG5cbmNvbnN0IFRyYXZlcnNhbEVycm9yOiBUcmF2ZXJzYWxFcnJvckNvbnN0cnVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgVHJhdmVyc2FsRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBUcmF2ZXJzYWxFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmF2ZXJzYWxFcnJvcjtcblxuICBmdW5jdGlvbiBUcmF2ZXJzYWxFcnJvcihcbiAgICB0aGlzOiBUcmF2ZXJzYWxFcnJvcixcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgbm9kZTogQVNUdjEuTm9kZSxcbiAgICBwYXJlbnQ6IE9wdGlvbjxBU1R2MS5Ob2RlPixcbiAgICBrZXk6IHN0cmluZ1xuICApIHtcbiAgICBsZXQgZXJyb3IgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgfVxuXG4gIHJldHVybiAoVHJhdmVyc2FsRXJyb3IgYXMgdW5rbm93bikgYXMgVHJhdmVyc2FsRXJyb3JDb25zdHJ1Y3Rvcjtcbn0pKCk7XG5cbmV4cG9ydCBkZWZhdWx0IFRyYXZlcnNhbEVycm9yO1xuXG5leHBvcnQgZnVuY3Rpb24gY2Fubm90UmVtb3ZlTm9kZShcbiAgbm9kZTogQVNUdjEuTm9kZSxcbiAgcGFyZW50OiBBU1R2MS5Ob2RlLFxuICBrZXk6IHN0cmluZ1xuKTogVHJhdmVyc2FsRXJyb3Ige1xuICByZXR1cm4gbmV3IFRyYXZlcnNhbEVycm9yKFxuICAgICdDYW5ub3QgcmVtb3ZlIGEgbm9kZSB1bmxlc3MgaXQgaXMgcGFydCBvZiBhbiBhcnJheScsXG4gICAgbm9kZSxcbiAgICBwYXJlbnQsXG4gICAga2V5XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW5ub3RSZXBsYWNlTm9kZShcbiAgbm9kZTogQVNUdjEuTm9kZSxcbiAgcGFyZW50OiBBU1R2MS5Ob2RlLFxuICBrZXk6IHN0cmluZ1xuKTogVHJhdmVyc2FsRXJyb3Ige1xuICByZXR1cm4gbmV3IFRyYXZlcnNhbEVycm9yKFxuICAgICdDYW5ub3QgcmVwbGFjZSBhIG5vZGUgd2l0aCBtdWx0aXBsZSBub2RlcyB1bmxlc3MgaXQgaXMgcGFydCBvZiBhbiBhcnJheScsXG4gICAgbm9kZSxcbiAgICBwYXJlbnQsXG4gICAga2V5XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW5ub3RSZXBsYWNlT3JSZW1vdmVJbktleUhhbmRsZXJZZXQoXG4gIG5vZGU6IEFTVHYxLk5vZGUsXG4gIGtleTogc3RyaW5nXG4pOiBUcmF2ZXJzYWxFcnJvciB7XG4gIHJldHVybiBuZXcgVHJhdmVyc2FsRXJyb3IoXG4gICAgJ1JlcGxhY2luZyBhbmQgcmVtb3ZpbmcgaW4ga2V5IGhhbmRsZXJzIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLicsXG4gICAgbm9kZSxcbiAgICBudWxsLFxuICAgIGtleVxuICApO1xufVxuIiwiaW1wb3J0ICogYXMgQVNUdjEgZnJvbSAnLi4vdjEvYXBpJztcblxuZnVuY3Rpb24gZ2V0TG9jYWxOYW1lKG5vZGU6IEFTVHYxLk5vZGUpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgJ0VsZW1lbnROb2RlJzpcbiAgICAgIC8vIHVuZm9ydHVuYXRlbHkgdGhlIEVsZW1lbnROb2RlIHN0b3JlcyBgdGFnYCBhcyBhIHN0cmluZ1xuICAgICAgLy8gaWYgdGhhdCBjaGFuZ2VzIGluIGdsaW1tZXItdm0gdGhpcyB3aWxsIG5lZWQgdG8gYmUgdXBkYXRlZFxuICAgICAgcmV0dXJuIG5vZGUudGFnLnNwbGl0KCcuJylbMF07XG5cbiAgICBjYXNlICdTdWJFeHByZXNzaW9uJzpcbiAgICBjYXNlICdNdXN0YWNoZVN0YXRlbWVudCc6XG4gICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuICAgICAgcmV0dXJuIGdldExvY2FsTmFtZShub2RlLnBhdGgpO1xuXG4gICAgY2FzZSAnVW5kZWZpbmVkTGl0ZXJhbCc6XG4gICAgY2FzZSAnTnVsbExpdGVyYWwnOlxuICAgIGNhc2UgJ0Jvb2xlYW5MaXRlcmFsJzpcbiAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzpcbiAgICBjYXNlICdOdW1iZXJMaXRlcmFsJzpcbiAgICBjYXNlICdUZXh0Tm9kZSc6XG4gICAgY2FzZSAnVGVtcGxhdGUnOlxuICAgIGNhc2UgJ0Jsb2NrJzpcbiAgICBjYXNlICdDb21tZW50U3RhdGVtZW50JzpcbiAgICBjYXNlICdNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQnOlxuICAgIGNhc2UgJ1BhcnRpYWxTdGF0ZW1lbnQnOlxuICAgIGNhc2UgJ0VsZW1lbnRNb2RpZmllclN0YXRlbWVudCc6XG4gICAgY2FzZSAnQXR0ck5vZGUnOlxuICAgIGNhc2UgJ0NvbmNhdFN0YXRlbWVudCc6XG4gICAgY2FzZSAnUHJvZ3JhbSc6XG4gICAgY2FzZSAnSGFzaCc6XG4gICAgY2FzZSAnSGFzaFBhaXInOlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjYXNlICdQYXRoRXhwcmVzc2lvbic6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBub2RlLnBhcnRzLmxlbmd0aCA/IG5vZGUucGFydHNbMF0gOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TG9jYWxzKG5vZGU6IEFTVHYxLk5vZGUpOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSAnRWxlbWVudE5vZGUnOlxuICAgIGNhc2UgJ1Byb2dyYW0nOlxuICAgIGNhc2UgJ0Jsb2NrJzpcbiAgICBjYXNlICdUZW1wbGF0ZSc6XG4gICAgICByZXR1cm4gbm9kZS5ibG9ja1BhcmFtcztcblxuICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgIHJldHVybiBub2RlLnByb2dyYW0uYmxvY2tQYXJhbXM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVHJhbnNmb3JtU2NvcGUge1xuICBoYXNQYXJ0aWFsID0gZmFsc2U7XG4gIHVzZWRMb2NhbHM6IHsgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9ID0ge307XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGxvY2Fsczogc3RyaW5nW10pIHtcbiAgICBmb3IgKGNvbnN0IGxvY2FsIG9mIGxvY2Fscykge1xuICAgICAgdGhpcy51c2VkTG9jYWxzW2xvY2FsXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNoaWxkKG5vZGU6IEFTVHYxLk5vZGUpOiBUcmFuc2Zvcm1TY29wZSB7XG4gICAgbGV0IGxvY2FscyA9IGdldExvY2Fscyhub2RlKTtcblxuICAgIHJldHVybiBsb2NhbHMgPyBuZXcgQ2hpbGRUcmFuc2Zvcm1TY29wZShsb2NhbHMsIHRoaXMpIDogdGhpcztcbiAgfVxuXG4gIHVzZVBhcnRpYWwoKTogdm9pZCB7XG4gICAgdGhpcy5oYXNQYXJ0aWFsID0gdHJ1ZTtcbiAgfVxuXG4gIGFic3RyYWN0IGlzTG9jYWwobmFtZTogc3RyaW5nKTogYm9vbGVhbjtcbiAgYWJzdHJhY3QgdXNlTG9jYWwobm9kZTogQVNUdjEuTm9kZSk6IHZvaWQ7XG4gIGFic3RyYWN0IGN1cnJlbnRVbnVzZWRMb2NhbHMoKTogc3RyaW5nW10gfCBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm9vdFRyYW5zZm9ybVNjb3BlIGV4dGVuZHMgVHJhbnNmb3JtU2NvcGUge1xuICBjb25zdHJ1Y3Rvcihub2RlOiBBU1R2MS5Ob2RlKSB7XG4gICAgbGV0IGxvY2FscyA9IGdldExvY2Fscyhub2RlKSA/PyBbXTtcblxuICAgIHN1cGVyKGxvY2Fscyk7XG4gIH1cblxuICB1c2VMb2NhbChub2RlOiBBU1R2MS5Ob2RlKTogdm9pZCB7XG4gICAgbGV0IG5hbWUgPSBnZXRMb2NhbE5hbWUobm9kZSk7XG5cbiAgICBpZiAobmFtZSAmJiBuYW1lIGluIHRoaXMudXNlZExvY2Fscykge1xuICAgICAgdGhpcy51c2VkTG9jYWxzW25hbWVdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpc0xvY2FsKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmxvY2Fscy5pbmRleE9mKG5hbWUpICE9PSAtMTtcbiAgfVxuXG4gIGN1cnJlbnRVbnVzZWRMb2NhbHMoKTogc3RyaW5nW10gfCBmYWxzZSB7XG4gICAgaWYgKCF0aGlzLmhhc1BhcnRpYWwgJiYgdGhpcy5sb2NhbHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMubG9jYWxzLmZpbHRlcigobG9jYWwpID0+ICF0aGlzLnVzZWRMb2NhbHNbbG9jYWxdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuY2xhc3MgQ2hpbGRUcmFuc2Zvcm1TY29wZSBleHRlbmRzIFRyYW5zZm9ybVNjb3BlIHtcbiAgY29uc3RydWN0b3IobG9jYWxzOiBzdHJpbmdbXSwgcHJpdmF0ZSBwYXJlbnQ6IFRyYW5zZm9ybVNjb3BlKSB7XG4gICAgc3VwZXIobG9jYWxzKTtcbiAgfVxuXG4gIHVzZUxvY2FsKG5vZGU6IEFTVHYxLk5vZGUpOiB2b2lkIHtcbiAgICBsZXQgbmFtZSA9IGdldExvY2FsTmFtZShub2RlKTtcblxuICAgIGlmIChuYW1lICYmIG5hbWUgaW4gdGhpcy51c2VkTG9jYWxzKSB7XG4gICAgICB0aGlzLnVzZWRMb2NhbHNbbmFtZV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcmVudC51c2VMb2NhbChub2RlKTtcbiAgICB9XG4gIH1cblxuICBpc0xvY2FsKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmxvY2Fscy5pbmRleE9mKG5hbWUpICE9PSAtMSB8fCB0aGlzLnBhcmVudC5pc0xvY2FsKG5hbWUpO1xuICB9XG5cbiAgY3VycmVudFVudXNlZExvY2FscygpOiBzdHJpbmdbXSB8IGZhbHNlIHtcbiAgICBpZiAoIXRoaXMuaGFzUGFydGlhbCAmJiB0aGlzLmxvY2Fscy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBXZSBvbmx5IGNhcmUgYWJvdXQgdGhlIGxhc3QgbG9jYWwsIGJlY2F1c2UgaWYgaXQgaXMgdXNlZCB0aGVuIGl0IGltcGxpZXNcbiAgICAgIC8vIHVzYWdlIG9mIHRoZSBvdGhlcnMgKHNwZWNpZmljYWxseSB3aGVuIGluIGEgY2hpbGQgYmxvY2ssIHxmb28gYmFyfClcbiAgICAgIGlmICghdGhpcy51c2VkTG9jYWxzW3RoaXMubG9jYWxzW3RoaXMubG9jYWxzLmxlbmd0aCAtIDFdXSkge1xuICAgICAgICByZXR1cm4gW3RoaXMubG9jYWxzW3RoaXMubG9jYWxzLmxlbmd0aCAtIDFdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIEFTVHYxIGZyb20gJy4uL3YxL2FwaSc7XG5pbXBvcnQgUm9vdFRyYW5zZm9ybVNjb3BlLCB7IFRyYW5zZm9ybVNjb3BlIH0gZnJvbSAnLi9zY29wZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhbGtlclBhdGg8TiBleHRlbmRzIEFTVHYxLk5vZGU+IHtcbiAgbm9kZTogTjtcbiAgcGFyZW50OiBXYWxrZXJQYXRoPEFTVHYxLk5vZGU+IHwgbnVsbDtcbiAgcGFyZW50S2V5OiBzdHJpbmcgfCBudWxsO1xuICBzY29wZTogVHJhbnNmb3JtU2NvcGU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbm9kZTogTixcbiAgICBwYXJlbnQ6IFdhbGtlclBhdGg8QVNUdjEuTm9kZT4gfCBudWxsID0gbnVsbCxcbiAgICBwYXJlbnRLZXk6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICkge1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5wYXJlbnRLZXkgPSBwYXJlbnRLZXk7XG4gICAgdGhpcy5zY29wZSA9IHBhcmVudCA/IHBhcmVudC5zY29wZS5jaGlsZChub2RlKSA6IG5ldyBSb290VHJhbnNmb3JtU2NvcGUobm9kZSk7XG5cbiAgICAvLyBDb25zdW1lIGluIHNjb3BlIHZhbHVlc1xuICAgIGlmIChub2RlLnR5cGUgPT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICAgIHRoaXMuc2NvcGUudXNlTG9jYWwobm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0VsZW1lbnROb2RlJykge1xuICAgICAgdGhpcy5zY29wZS51c2VMb2NhbChub2RlKTtcblxuICAgICAgKG5vZGUgYXMgQVNUdjEuRWxlbWVudE5vZGUpLmNoaWxkcmVuLmZvckVhY2goKG5vZGU6IEFTVHYxLlN0YXRlbWVudCkgPT5cbiAgICAgICAgdGhpcy5zY29wZS51c2VMb2NhbChub2RlKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBnZXQgcGFyZW50Tm9kZSgpOiBBU1R2MS5Ob2RlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQubm9kZSA6IG51bGw7XG4gIH1cblxuICBwYXJlbnRzKCk6IEl0ZXJhYmxlPFdhbGtlclBhdGg8QVNUdjEuTm9kZT4gfCBudWxsPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aFBhcmVudHNJdGVyYXRvcih0aGlzKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuXG5jbGFzcyBQYXRoUGFyZW50c0l0ZXJhdG9yIGltcGxlbWVudHMgSXRlcmF0b3I8V2Fsa2VyUGF0aDxBU1R2MS5Ob2RlPiB8IG51bGw+IHtcbiAgcGF0aDogV2Fsa2VyUGF0aDxBU1R2MS5Ob2RlPjtcblxuICBjb25zdHJ1Y3RvcihwYXRoOiBXYWxrZXJQYXRoPEFTVHYxLk5vZGU+KSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxuXG4gIG5leHQoKSB7XG4gICAgaWYgKHRoaXMucGF0aC5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGF0aCA9IHRoaXMucGF0aC5wYXJlbnQ7XG4gICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMucGF0aCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbnVsbCB9O1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgTE9DQUxfREVCVUcgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBkZXByZWNhdGUgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcblxuaW1wb3J0ICogYXMgQVNUdjEgZnJvbSAnLi4vdjEvYXBpJztcbmltcG9ydCB2aXNpdG9yS2V5cywgeyBWaXNpdG9yS2V5LCBWaXNpdG9yS2V5cyB9IGZyb20gJy4uL3YxL3Zpc2l0b3Ita2V5cyc7XG5pbXBvcnQge1xuICBjYW5ub3RSZW1vdmVOb2RlLFxuICBjYW5ub3RSZXBsYWNlTm9kZSxcbiAgY2Fubm90UmVwbGFjZU9yUmVtb3ZlSW5LZXlIYW5kbGVyWWV0LFxufSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgV2Fsa2VyUGF0aCBmcm9tICcuL3BhdGgnO1xuaW1wb3J0IHsgS2V5SGFuZGxlciwgS2V5VHJhdmVyc2FsLCBOb2RlSGFuZGxlciwgTm9kZVRyYXZlcnNhbCwgTm9kZVZpc2l0b3IgfSBmcm9tICcuL3Zpc2l0b3InO1xuXG5mdW5jdGlvbiBnZXRFbnRlckZ1bmN0aW9uPE4gZXh0ZW5kcyBBU1R2MS5Ob2RlPihcbiAgaGFuZGxlcjogTm9kZVRyYXZlcnNhbDxOPlxuKTogTm9kZUhhbmRsZXI8Tj4gfCB1bmRlZmluZWQ7XG5mdW5jdGlvbiBnZXRFbnRlckZ1bmN0aW9uPE4gZXh0ZW5kcyBBU1R2MS5Ob2RlLCBLIGV4dGVuZHMgVmlzaXRvcktleTxOPj4oXG4gIGhhbmRsZXI6IEtleVRyYXZlcnNhbDxOLCBLPlxuKTogS2V5SGFuZGxlcjxOLCBLPiB8IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGdldEVudGVyRnVuY3Rpb248TiBleHRlbmRzIEFTVHYxLk5vZGUsIEsgZXh0ZW5kcyBWaXNpdG9yS2V5PE4+PihcbiAgaGFuZGxlcjogTm9kZVRyYXZlcnNhbDxOPiB8IEtleVRyYXZlcnNhbDxOLCBLPlxuKTogTm9kZUhhbmRsZXI8Tj4gfCBLZXlIYW5kbGVyPE4sIEs+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhhbmRsZXIuZW50ZXIgYXMgTm9kZUhhbmRsZXI8Tj4gfCBLZXlIYW5kbGVyPE4sIEs+O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEV4aXRGdW5jdGlvbjxOIGV4dGVuZHMgQVNUdjEuTm9kZT4oXG4gIGhhbmRsZXI6IE5vZGVUcmF2ZXJzYWw8Tj5cbik6IE5vZGVIYW5kbGVyPE4+IHwgdW5kZWZpbmVkO1xuZnVuY3Rpb24gZ2V0RXhpdEZ1bmN0aW9uPE4gZXh0ZW5kcyBBU1R2MS5Ob2RlLCBLIGV4dGVuZHMgVmlzaXRvcktleTxOPj4oXG4gIGhhbmRsZXI6IEtleVRyYXZlcnNhbDxOLCBLPlxuKTogS2V5SGFuZGxlcjxOLCBLPiB8IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGdldEV4aXRGdW5jdGlvbjxOIGV4dGVuZHMgQVNUdjEuTm9kZSwgSyBleHRlbmRzIFZpc2l0b3JLZXk8Tj4+KFxuICBoYW5kbGVyOiBOb2RlVHJhdmVyc2FsPE4+IHwgS2V5VHJhdmVyc2FsPE4sIEs+XG4pOiBOb2RlSGFuZGxlcjxOPiB8IEtleUhhbmRsZXI8TiwgSz4gfCB1bmRlZmluZWQge1xuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYW5kbGVyLmV4aXQgYXMgTm9kZUhhbmRsZXI8Tj4gfCBLZXlIYW5kbGVyPE4sIEs+O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEtleUhhbmRsZXI8TiBleHRlbmRzIEFTVHYxLk5vZGUsIEsgZXh0ZW5kcyBWaXNpdG9yS2V5PE4+PihcbiAgaGFuZGxlcjogTm9kZVRyYXZlcnNhbDxOPixcbiAga2V5OiBLXG4pOiBLZXlUcmF2ZXJzYWw8TiwgSz4gfCBLZXlUcmF2ZXJzYWw8TiwgVmlzaXRvcktleTxOPj4gfCB1bmRlZmluZWQge1xuICBsZXQga2V5VmlzaXRvciA9IHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nID8gaGFuZGxlci5rZXlzIDogdW5kZWZpbmVkO1xuICBpZiAoa2V5VmlzaXRvciA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgbGV0IGtleUhhbmRsZXIgPSBrZXlWaXNpdG9yW2tleV07XG4gIGlmIChrZXlIYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ga2V5SGFuZGxlciBhcyBLZXlUcmF2ZXJzYWw8TiwgSz47XG4gIH1cbiAgcmV0dXJuIGtleVZpc2l0b3IuQWxsO1xufVxuXG5mdW5jdGlvbiBnZXROb2RlSGFuZGxlcjxOIGV4dGVuZHMgQVNUdjEuTm9kZT4oXG4gIHZpc2l0b3I6IE5vZGVWaXNpdG9yLFxuICBub2RlVHlwZTogTlsndHlwZSddXG4pOiBOb2RlVHJhdmVyc2FsPE4+O1xuZnVuY3Rpb24gZ2V0Tm9kZUhhbmRsZXIodmlzaXRvcjogTm9kZVZpc2l0b3IsIG5vZGVUeXBlOiAnQWxsJyk6IE5vZGVUcmF2ZXJzYWw8QVNUdjEuTm9kZT47XG5mdW5jdGlvbiBnZXROb2RlSGFuZGxlcjxOIGV4dGVuZHMgQVNUdjEuTm9kZT4oXG4gIHZpc2l0b3I6IE5vZGVWaXNpdG9yLFxuICBub2RlVHlwZTogTlsndHlwZSddXG4pOiBOb2RlVHJhdmVyc2FsPEFTVHYxLk5vZGU+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG5vZGVUeXBlID09PSAnVGVtcGxhdGUnIHx8IG5vZGVUeXBlID09PSAnQmxvY2snKSB7XG4gICAgaWYgKHZpc2l0b3IuUHJvZ3JhbSkge1xuICAgICAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgICAgIGRlcHJlY2F0ZShcbiAgICAgICAgICBgVGhlICdQcm9ncmFtJyB2aXNpdG9yIG5vZGUgaXMgZGVwcmVjYXRlZC4gVXNlICdUZW1wbGF0ZScgb3IgJ0Jsb2NrJyBpbnN0ZWFkIChub2RlIHdhcyAnJHtub2RlVHlwZX0nKSBgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aXNpdG9yLlByb2dyYW0gYXMgTm9kZVRyYXZlcnNhbDxBU1R2MS5Ob2RlPjtcbiAgICB9XG4gIH1cblxuICBsZXQgaGFuZGxlciA9IHZpc2l0b3Jbbm9kZVR5cGVdO1xuICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIChoYW5kbGVyIGFzIHVua25vd24pIGFzIE5vZGVUcmF2ZXJzYWw8QVNUdjEuTm9kZT47XG4gIH1cbiAgcmV0dXJuIHZpc2l0b3IuQWxsO1xufVxuXG5mdW5jdGlvbiB2aXNpdE5vZGU8TiBleHRlbmRzIEFTVHYxLk5vZGU+KFxuICB2aXNpdG9yOiBOb2RlVmlzaXRvcixcbiAgcGF0aDogV2Fsa2VyUGF0aDxOPlxuKTogQVNUdjEuTm9kZSB8IEFTVHYxLk5vZGVbXSB8IHVuZGVmaW5lZCB8IG51bGwgfCB2b2lkIHtcbiAgbGV0IHsgbm9kZSwgcGFyZW50LCBwYXJlbnRLZXkgfSA9IHBhdGg7XG5cbiAgbGV0IGhhbmRsZXI6IE5vZGVUcmF2ZXJzYWw8Tj4gPSBnZXROb2RlSGFuZGxlcih2aXNpdG9yLCBub2RlLnR5cGUpO1xuICBsZXQgZW50ZXI7XG4gIGxldCBleGl0O1xuXG4gIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbnRlciA9IGdldEVudGVyRnVuY3Rpb24oaGFuZGxlcik7XG4gICAgZXhpdCA9IGdldEV4aXRGdW5jdGlvbihoYW5kbGVyKTtcbiAgfVxuXG4gIGxldCByZXN1bHQ6IEFTVHYxLk5vZGUgfCBBU1R2MS5Ob2RlW10gfCB1bmRlZmluZWQgfCBudWxsIHwgdm9pZDtcbiAgaWYgKGVudGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXN1bHQgPSBlbnRlcihub2RlLCBwYXRoKTtcbiAgfVxuXG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkobm9kZSkgPT09IEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgdmlzaXRBcnJheSh2aXNpdG9yLCByZXN1bHQsIHBhcmVudCwgcGFyZW50S2V5KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXRoID0gbmV3IFdhbGtlclBhdGgocmVzdWx0LCBwYXJlbnQsIHBhcmVudEtleSk7XG4gICAgICByZXR1cm4gdmlzaXROb2RlKHZpc2l0b3IsIHBhdGgpIHx8IHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICBsZXQga2V5cyA9IHZpc2l0b3JLZXlzW25vZGUudHlwZV07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBrZXlzW2ldIGFzIFZpc2l0b3JLZXlzW05bJ3R5cGUnXV0gJiBrZXlvZiBOO1xuICAgICAgLy8gd2Uga25vdyBpZiBpdCBoYXMgY2hpbGQga2V5cyB3ZSBjYW4gd2lkZW4gdG8gYSBQYXJlbnROb2RlXG4gICAgICB2aXNpdEtleSh2aXNpdG9yLCBoYW5kbGVyLCBwYXRoLCBrZXkpO1xuICAgIH1cblxuICAgIGlmIChleGl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdCA9IGV4aXQobm9kZSwgcGF0aCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0PE4gZXh0ZW5kcyBBU1R2MS5Ob2RlPihcbiAgbm9kZTogTixcbiAga2V5OiBWaXNpdG9yS2V5c1tOWyd0eXBlJ11dICYga2V5b2YgTlxuKTogQVNUdjEuTm9kZSB8IEFTVHYxLk5vZGVbXSB7XG4gIHJldHVybiAobm9kZVtrZXldIGFzIHVua25vd24pIGFzIEFTVHYxLk5vZGUgfCBBU1R2MS5Ob2RlW107XG59XG5cbmZ1bmN0aW9uIHNldDxOIGV4dGVuZHMgQVNUdjEuTm9kZSwgSyBleHRlbmRzIGtleW9mIE4+KG5vZGU6IE4sIGtleTogSywgdmFsdWU6IE5bS10pOiB2b2lkIHtcbiAgbm9kZVtrZXldID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHZpc2l0S2V5PE4gZXh0ZW5kcyBBU1R2MS5Ob2RlPihcbiAgdmlzaXRvcjogTm9kZVZpc2l0b3IsXG4gIGhhbmRsZXI6IE5vZGVUcmF2ZXJzYWw8Tj4sXG4gIHBhdGg6IFdhbGtlclBhdGg8Tj4sXG4gIGtleTogVmlzaXRvcktleXNbTlsndHlwZSddXSAmIGtleW9mIE5cbikge1xuICBsZXQgeyBub2RlIH0gPSBwYXRoO1xuXG4gIGxldCB2YWx1ZSA9IGdldChub2RlLCBrZXkpO1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGtleUVudGVyO1xuICBsZXQga2V5RXhpdDtcblxuICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGtleUhhbmRsZXIgPSBnZXRLZXlIYW5kbGVyKGhhbmRsZXIsIGtleSk7XG4gICAgaWYgKGtleUhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5RW50ZXIgPSBnZXRFbnRlckZ1bmN0aW9uKGtleUhhbmRsZXIpO1xuICAgICAga2V5RXhpdCA9IGdldEV4aXRGdW5jdGlvbihrZXlIYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICBpZiAoa2V5RW50ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChrZXlFbnRlcihub2RlLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IGNhbm5vdFJlcGxhY2VPclJlbW92ZUluS2V5SGFuZGxlcllldChub2RlLCBrZXkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZpc2l0QXJyYXkodmlzaXRvciwgdmFsdWUsIHBhdGgsIGtleSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGtleVBhdGggPSBuZXcgV2Fsa2VyUGF0aCh2YWx1ZSwgcGF0aCwga2V5KTtcbiAgICBsZXQgcmVzdWx0ID0gdmlzaXROb2RlKHZpc2l0b3IsIGtleVBhdGgpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVE9ETzogZHluYW1pY2FsbHkgY2hlY2sgdGhlIHJlc3VsdHMgYnkgaGF2aW5nIGEgdGFibGUgb2ZcbiAgICAgIC8vIGV4cGVjdGVkIG5vZGUgdHlwZXMgaW4gdmFsdWUgc3BhY2UsIG5vdCBqdXN0IHR5cGUgc3BhY2VcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICBhc3NpZ25LZXkobm9kZSwga2V5LCB2YWx1ZSwgcmVzdWx0IGFzIGFueSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtleUV4aXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChrZXlFeGl0KG5vZGUsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgY2Fubm90UmVwbGFjZU9yUmVtb3ZlSW5LZXlIYW5kbGVyWWV0KG5vZGUsIGtleSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZpc2l0QXJyYXkoXG4gIHZpc2l0b3I6IE5vZGVWaXNpdG9yLFxuICBhcnJheTogQVNUdjEuTm9kZVtdLFxuICBwYXJlbnQ6IFdhbGtlclBhdGg8QVNUdjEuTm9kZT4gfCBudWxsLFxuICBwYXJlbnRLZXk6IHN0cmluZyB8IG51bGxcbikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IG5vZGUgPSBhcnJheVtpXTtcbiAgICBsZXQgcGF0aCA9IG5ldyBXYWxrZXJQYXRoKG5vZGUsIHBhcmVudCwgcGFyZW50S2V5KTtcbiAgICBsZXQgcmVzdWx0ID0gdmlzaXROb2RlKHZpc2l0b3IsIHBhdGgpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaSArPSBzcGxpY2VBcnJheShhcnJheSwgaSwgcmVzdWx0KSAtIDE7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbktleTxOIGV4dGVuZHMgQVNUdjEuTm9kZSwgSyBleHRlbmRzIFZpc2l0b3JLZXk8Tj4+KFxuICBub2RlOiBOLFxuICBrZXk6IEssXG4gIHZhbHVlOiBBU1R2MS5Ob2RlLFxuICByZXN1bHQ6IE5bS10gfCBbTltLXV0gfCBudWxsXG4pIHtcbiAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgIHRocm93IGNhbm5vdFJlbW92ZU5vZGUodmFsdWUsIG5vZGUsIGtleSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHNldChub2RlLCBrZXksIHJlc3VsdFswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IGNhbm5vdFJlbW92ZU5vZGUodmFsdWUsIG5vZGUsIGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBjYW5ub3RSZXBsYWNlTm9kZSh2YWx1ZSwgbm9kZSwga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2V0KG5vZGUsIGtleSwgcmVzdWx0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGxpY2VBcnJheShhcnJheTogQVNUdjEuTm9kZVtdLCBpbmRleDogbnVtYmVyLCByZXN1bHQ6IEFTVHYxLk5vZGUgfCBBU1R2MS5Ob2RlW10gfCBudWxsKSB7XG4gIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgIGFycmF5LnNwbGljZShpbmRleCwgMSwgLi4ucmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEsIHJlc3VsdCk7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhdmVyc2Uobm9kZTogQVNUdjEuTm9kZSwgdmlzaXRvcjogTm9kZVZpc2l0b3IpOiB2b2lkIHtcbiAgbGV0IHBhdGggPSBuZXcgV2Fsa2VyUGF0aChub2RlKTtcbiAgdmlzaXROb2RlKHZpc2l0b3IsIHBhdGgpO1xufVxuIiwiaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbmltcG9ydCAqIGFzIEFTVHYxIGZyb20gJy4uL3YxL2FwaSc7XG5cbmV4cG9ydCB0eXBlIE5vZGVDYWxsYmFjazxOIGV4dGVuZHMgQVNUdjEuTm9kZT4gPSAobm9kZTogTiwgd2Fsa2VyOiBXYWxrZXIpID0+IHZvaWQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhbGtlciB7XG4gIHB1YmxpYyBzdGFjazogdW5rbm93bltdID0gW107XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBvcmRlcj86IHVua25vd24pIHt9XG5cbiAgdmlzaXQ8TiBleHRlbmRzIEFTVHYxLk5vZGU+KG5vZGU6IE9wdGlvbjxOPiwgY2FsbGJhY2s6IE5vZGVDYWxsYmFjazxOPik6IHZvaWQge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RhY2sucHVzaChub2RlKTtcblxuICAgIGlmICh0aGlzLm9yZGVyID09PSAncG9zdCcpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4obm9kZSwgY2FsbGJhY2spO1xuICAgICAgY2FsbGJhY2sobm9kZSwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKG5vZGUsIHRoaXMpO1xuICAgICAgdGhpcy5jaGlsZHJlbihub2RlLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgfVxuXG4gIGNoaWxkcmVuPE4gZXh0ZW5kcyBBU1R2MS5Ob2RlPihcbiAgICBub2RlOiBOICYgQVNUdjEuTm9kZSxcbiAgICBjYWxsYmFjazogTm9kZUNhbGxiYWNrPE4gJiBBU1R2MS5Ob2RlPlxuICApOiB2b2lkIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSAnQmxvY2snOlxuICAgICAgY2FzZSAnVGVtcGxhdGUnOlxuICAgICAgICByZXR1cm4gdmlzaXRvcnMuUHJvZ3JhbSh0aGlzLCAobm9kZSBhcyB1bmtub3duKSBhcyBBU1R2MS5Qcm9ncmFtLCBjYWxsYmFjayk7XG4gICAgICBjYXNlICdFbGVtZW50Tm9kZSc6XG4gICAgICAgIHJldHVybiB2aXNpdG9ycy5FbGVtZW50Tm9kZSh0aGlzLCBub2RlLCBjYWxsYmFjayk7XG4gICAgICBjYXNlICdCbG9ja1N0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB2aXNpdG9ycy5CbG9ja1N0YXRlbWVudCh0aGlzLCBub2RlLCBjYWxsYmFjayk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHZpc2l0b3JzID0ge1xuICBQcm9ncmFtKHdhbGtlcjogV2Fsa2VyLCBub2RlOiBBU1R2MS5Qcm9ncmFtLCBjYWxsYmFjazogTm9kZUNhbGxiYWNrPEFTVHYxLk5vZGU+KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdhbGtlci52aXNpdChub2RlLmJvZHlbaV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgVGVtcGxhdGUod2Fsa2VyOiBXYWxrZXIsIG5vZGU6IEFTVHYxLlRlbXBsYXRlLCBjYWxsYmFjazogTm9kZUNhbGxiYWNrPEFTVHYxLk5vZGU+KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdhbGtlci52aXNpdChub2RlLmJvZHlbaV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgQmxvY2sod2Fsa2VyOiBXYWxrZXIsIG5vZGU6IEFTVHYxLkJsb2NrLCBjYWxsYmFjazogTm9kZUNhbGxiYWNrPEFTVHYxLk5vZGU+KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdhbGtlci52aXNpdChub2RlLmJvZHlbaV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgRWxlbWVudE5vZGUod2Fsa2VyOiBXYWxrZXIsIG5vZGU6IEFTVHYxLkVsZW1lbnROb2RlLCBjYWxsYmFjazogTm9kZUNhbGxiYWNrPEFTVHYxLk5vZGU+KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3YWxrZXIudmlzaXQobm9kZS5jaGlsZHJlbltpXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICBCbG9ja1N0YXRlbWVudCh3YWxrZXI6IFdhbGtlciwgbm9kZTogQVNUdjEuQmxvY2tTdGF0ZW1lbnQsIGNhbGxiYWNrOiBOb2RlQ2FsbGJhY2s8QVNUdjEuQmxvY2s+KSB7XG4gICAgd2Fsa2VyLnZpc2l0KG5vZGUucHJvZ3JhbSwgY2FsbGJhY2spO1xuICAgIHdhbGtlci52aXNpdChub2RlLmludmVyc2UgfHwgbnVsbCwgY2FsbGJhY2spO1xuICB9LFxufSBhcyBjb25zdDtcbiIsImltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmltcG9ydCB7IGdlbmVyYXRlU3ludGF4RXJyb3IgfSBmcm9tICcuL3N5bnRheC1lcnJvcic7XG5pbXBvcnQgKiBhcyBBU1R2MSBmcm9tICcuL3YxL2FwaSc7XG5pbXBvcnQgKiBhcyBIQlMgZnJvbSAnLi92MS9oYW5kbGViYXJzLWFzdCc7XG5cbi8vIFJlZ2V4IHRvIHZhbGlkYXRlIHRoZSBpZGVudGlmaWVyIGZvciBibG9jayBwYXJhbWV0ZXJzLlxuLy8gQmFzZWQgb24gdGhlIElEIHZhbGlkYXRpb24gcmVnZXggaW4gSGFuZGxlYmFycy5cblxubGV0IElEX0lOVkVSU0VfUEFUVEVSTiA9IC9bIVwiIyUtLFxcLlxcLzstPkBcXFstXFxeYFxcey1+XS87XG5cbi8vIENoZWNrcyB0aGUgZWxlbWVudCdzIGF0dHJpYnV0ZXMgdG8gc2VlIGlmIGl0IHVzZXMgYmxvY2sgcGFyYW1zLlxuLy8gSWYgaXQgZG9lcywgcmVnaXN0ZXJzIHRoZSBibG9jayBwYXJhbXMgd2l0aCB0aGUgcHJvZ3JhbSBhbmRcbi8vIHJlbW92ZXMgdGhlIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlcyBmcm9tIHRoZSBlbGVtZW50LlxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFbGVtZW50QmxvY2tQYXJhbXMoZWxlbWVudDogQVNUdjEuRWxlbWVudE5vZGUpOiB2b2lkIHtcbiAgbGV0IHBhcmFtcyA9IHBhcnNlQmxvY2tQYXJhbXMoZWxlbWVudCk7XG4gIGlmIChwYXJhbXMpIGVsZW1lbnQuYmxvY2tQYXJhbXMgPSBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQmxvY2tQYXJhbXMoZWxlbWVudDogQVNUdjEuRWxlbWVudE5vZGUpOiBPcHRpb248c3RyaW5nW10+IHtcbiAgbGV0IGwgPSBlbGVtZW50LmF0dHJpYnV0ZXMubGVuZ3RoO1xuICBsZXQgYXR0ck5hbWVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBhdHRyTmFtZXMucHVzaChlbGVtZW50LmF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gIH1cblxuICBsZXQgYXNJbmRleCA9IGF0dHJOYW1lcy5pbmRleE9mKCdhcycpO1xuXG4gIGlmIChhc0luZGV4ID09PSAtMSAmJiBhdHRyTmFtZXMubGVuZ3RoID4gMCAmJiBhdHRyTmFtZXNbYXR0ck5hbWVzLmxlbmd0aCAtIDFdLmNoYXJBdCgwKSA9PT0gJ3wnKSB7XG4gICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICdCbG9jayBwYXJhbWV0ZXJzIG11c3QgYmUgcHJlY2VkZWQgYnkgdGhlIGBhc2Aga2V5d29yZCwgZGV0ZWN0ZWQgYmxvY2sgcGFyYW1ldGVycyB3aXRob3V0IGBhc2AnLFxuICAgICAgZWxlbWVudC5sb2NcbiAgICApO1xuICB9XG5cbiAgaWYgKGFzSW5kZXggIT09IC0xICYmIGwgPiBhc0luZGV4ICYmIGF0dHJOYW1lc1thc0luZGV4ICsgMV0uY2hhckF0KDApID09PSAnfCcpIHtcbiAgICAvLyBTb21lIGJhc2ljIHZhbGlkYXRpb24sIHNpbmNlIHdlJ3JlIGRvaW5nIHRoZSBwYXJzaW5nIG91cnNlbHZlc1xuICAgIGxldCBwYXJhbXNTdHJpbmcgPSBhdHRyTmFtZXMuc2xpY2UoYXNJbmRleCkuam9pbignICcpO1xuICAgIGlmIChcbiAgICAgIHBhcmFtc1N0cmluZy5jaGFyQXQocGFyYW1zU3RyaW5nLmxlbmd0aCAtIDEpICE9PSAnfCcgfHxcbiAgICAgIGV4cGVjdChwYXJhbXNTdHJpbmcubWF0Y2goL1xcfC9nKSwgYGJsb2NrIHBhcmFtcyBtdXN0IGV4aXN0IGhlcmVgKS5sZW5ndGggIT09IDJcbiAgICApIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBibG9jayBwYXJhbWV0ZXJzIHN5bnRheCwgJ1wiICsgcGFyYW1zU3RyaW5nICsgXCInXCIsXG4gICAgICAgIGVsZW1lbnQubG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBwYXJhbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gYXNJbmRleCArIDE7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxldCBwYXJhbSA9IGF0dHJOYW1lc1tpXS5yZXBsYWNlKC9cXHwvZywgJycpO1xuICAgICAgaWYgKHBhcmFtICE9PSAnJykge1xuICAgICAgICBpZiAoSURfSU5WRVJTRV9QQVRURVJOLnRlc3QocGFyYW0pKSB7XG4gICAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCBpZGVudGlmaWVyIGZvciBibG9jayBwYXJhbWV0ZXJzLCAnXCIgKyBwYXJhbSArIFwiJ1wiLFxuICAgICAgICAgICAgZWxlbWVudC5sb2NcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcignQ2Fubm90IHVzZSB6ZXJvIGJsb2NrIHBhcmFtZXRlcnMnLCBlbGVtZW50LmxvYyk7XG4gICAgfVxuXG4gICAgZWxlbWVudC5hdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzLnNsaWNlKDAsIGFzSW5kZXgpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkcmVuRm9yKFxuICBub2RlOiBBU1R2MS5CbG9jayB8IEFTVHYxLlRlbXBsYXRlIHwgQVNUdjEuRWxlbWVudE5vZGVcbik6IEFTVHYxLlRvcExldmVsU3RhdGVtZW50W10ge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgJ0Jsb2NrJzpcbiAgICBjYXNlICdUZW1wbGF0ZSc6XG4gICAgICByZXR1cm4gbm9kZS5ib2R5O1xuICAgIGNhc2UgJ0VsZW1lbnROb2RlJzpcbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDaGlsZChcbiAgcGFyZW50OiBBU1R2MS5CbG9jayB8IEFTVHYxLlRlbXBsYXRlIHwgQVNUdjEuRWxlbWVudE5vZGUsXG4gIG5vZGU6IEFTVHYxLlN0YXRlbWVudFxuKTogdm9pZCB7XG4gIGNoaWxkcmVuRm9yKHBhcmVudCkucHVzaChub2RlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSEJTTGl0ZXJhbChwYXRoOiBIQlMuRXhwcmVzc2lvbik6IHBhdGggaXMgSEJTLkxpdGVyYWw7XG5leHBvcnQgZnVuY3Rpb24gaXNIQlNMaXRlcmFsKHBhdGg6IEFTVHYxLkV4cHJlc3Npb24pOiBwYXRoIGlzIEFTVHYxLkxpdGVyYWw7XG5leHBvcnQgZnVuY3Rpb24gaXNIQlNMaXRlcmFsKFxuICBwYXRoOiBIQlMuRXhwcmVzc2lvbiB8IEFTVHYxLkV4cHJlc3Npb25cbik6IHBhdGggaXMgSEJTLkxpdGVyYWwgfCBBU1R2MS5MaXRlcmFsIHtcbiAgcmV0dXJuIChcbiAgICBwYXRoLnR5cGUgPT09ICdTdHJpbmdMaXRlcmFsJyB8fFxuICAgIHBhdGgudHlwZSA9PT0gJ0Jvb2xlYW5MaXRlcmFsJyB8fFxuICAgIHBhdGgudHlwZSA9PT0gJ051bWJlckxpdGVyYWwnIHx8XG4gICAgcGF0aC50eXBlID09PSAnTnVsbExpdGVyYWwnIHx8XG4gICAgcGF0aC50eXBlID09PSAnVW5kZWZpbmVkTGl0ZXJhbCdcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW50TGl0ZXJhbChsaXRlcmFsOiBBU1R2MS5MaXRlcmFsKTogc3RyaW5nIHtcbiAgaWYgKGxpdGVyYWwudHlwZSA9PT0gJ1VuZGVmaW5lZExpdGVyYWwnKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShsaXRlcmFsLnZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNVcHBlckNhc2UodGFnOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRhZ1swXSA9PT0gdGFnWzBdLnRvVXBwZXJDYXNlKCkgJiYgdGFnWzBdICE9PSB0YWdbMF0udG9Mb3dlckNhc2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTG93ZXJDYXNlKHRhZzogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiB0YWdbMF0gPT09IHRhZ1swXS50b0xvd2VyQ2FzZSgpICYmIHRhZ1swXSAhPT0gdGFnWzBdLnRvVXBwZXJDYXNlKCk7XG59XG4iLCJpbXBvcnQgeyBEaWN0LCBPcHRpb24sIFByZXNlbnRBcnJheSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmltcG9ydCB7IFBhcnNlck5vZGVCdWlsZGVyIH0gZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7IFNvdXJjZUxvY2F0aW9uIH0gZnJvbSAnLi4vc291cmNlL2xvY2F0aW9uJztcbmltcG9ydCB7IFNvdXJjZU9mZnNldCwgU291cmNlU3BhbiB9IGZyb20gJy4uL3NvdXJjZS9zcGFuJztcbmltcG9ydCAqIGFzIEFTVHYxIGZyb20gJy4vYXBpJztcbmltcG9ydCB7IFBhdGhFeHByZXNzaW9uSW1wbFYxIH0gZnJvbSAnLi9sZWdhY3ktaW50ZXJvcCc7XG5cbmNvbnN0IERFRkFVTFRfU1RSSVAgPSB7XG4gIGNsb3NlOiBmYWxzZSxcbiAgb3BlbjogZmFsc2UsXG59O1xuXG4vKipcbiAqIFRoZSBQYXJzZXIgQnVpbGRlciBkaWZmZXJlbnRpYXRlcyBmcm9tIHRoZSBwdWJsaWMgYnVpbGRlciBBUEkgYnk6XG4gKlxuICogMS4gT2ZmZXJpbmcgZmV3ZXIgZGlmZmVyZW50IHdheXMgdG8gaW5zdGFudGlhdGUgbm9kZXNcbiAqIDIuIE1hbmRhdGluZyBzb3VyY2UgbG9jYXRpb25zXG4gKi9cbmNsYXNzIEJ1aWxkZXJzIHtcbiAgcG9zKGxpbmU6IG51bWJlciwgY29sdW1uOiBudW1iZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZSxcbiAgICAgIGNvbHVtbixcbiAgICB9O1xuICB9XG5cbiAgYmxvY2tJdHNlbGYoe1xuICAgIGJvZHksXG4gICAgYmxvY2tQYXJhbXMsXG4gICAgY2hhaW5lZCA9IGZhbHNlLFxuICAgIGxvYyxcbiAgfToge1xuICAgIGJvZHk/OiBBU1R2MS5TdGF0ZW1lbnRbXTtcbiAgICBibG9ja1BhcmFtcz86IHN0cmluZ1tdO1xuICAgIGNoYWluZWQ/OiBib29sZWFuO1xuICAgIGxvYzogU291cmNlU3BhbjtcbiAgfSk6IEFTVHYxLkJsb2NrIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0Jsb2NrJyxcbiAgICAgIGJvZHk6IGJvZHkgfHwgW10sXG4gICAgICBibG9ja1BhcmFtczogYmxvY2tQYXJhbXMgfHwgW10sXG4gICAgICBjaGFpbmVkLFxuICAgICAgbG9jLFxuICAgIH07XG4gIH1cblxuICB0ZW1wbGF0ZSh7XG4gICAgYm9keSxcbiAgICBibG9ja1BhcmFtcyxcbiAgICBsb2MsXG4gIH06IHtcbiAgICBib2R5PzogQVNUdjEuU3RhdGVtZW50W107XG4gICAgYmxvY2tQYXJhbXM/OiBzdHJpbmdbXTtcbiAgICBsb2M6IFNvdXJjZVNwYW47XG4gIH0pOiBBU1R2MS5UZW1wbGF0ZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdUZW1wbGF0ZScsXG4gICAgICBib2R5OiBib2R5IHx8IFtdLFxuICAgICAgYmxvY2tQYXJhbXM6IGJsb2NrUGFyYW1zIHx8IFtdLFxuICAgICAgbG9jLFxuICAgIH07XG4gIH1cblxuICBtdXN0YWNoZSh7XG4gICAgcGF0aCxcbiAgICBwYXJhbXMsXG4gICAgaGFzaCxcbiAgICB0cnVzdGluZyxcbiAgICBsb2MsXG4gICAgc3RyaXAgPSBERUZBVUxUX1NUUklQLFxuICB9OiB7XG4gICAgcGF0aDogQVNUdjEuRXhwcmVzc2lvbjtcbiAgICBwYXJhbXM6IEFTVHYxLkV4cHJlc3Npb25bXTtcbiAgICBoYXNoOiBBU1R2MS5IYXNoO1xuICAgIHRydXN0aW5nOiBib29sZWFuO1xuICAgIGxvYzogU291cmNlU3BhbjtcbiAgICBzdHJpcDogQVNUdjEuU3RyaXBGbGFncztcbiAgfSk6IEFTVHYxLk11c3RhY2hlU3RhdGVtZW50IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ011c3RhY2hlU3RhdGVtZW50JyxcbiAgICAgIHBhdGgsXG4gICAgICBwYXJhbXMsXG4gICAgICBoYXNoLFxuICAgICAgZXNjYXBlZDogIXRydXN0aW5nLFxuICAgICAgdHJ1c3RpbmcsXG4gICAgICBsb2MsXG4gICAgICBzdHJpcDogc3RyaXAgfHwgeyBvcGVuOiBmYWxzZSwgY2xvc2U6IGZhbHNlIH0sXG4gICAgfTtcbiAgfVxuXG4gIGJsb2NrKHtcbiAgICBwYXRoLFxuICAgIHBhcmFtcyxcbiAgICBoYXNoLFxuICAgIGRlZmF1bHRCbG9jayxcbiAgICBlbHNlQmxvY2sgPSBudWxsLFxuICAgIGxvYyxcbiAgICBvcGVuU3RyaXAgPSBERUZBVUxUX1NUUklQLFxuICAgIGludmVyc2VTdHJpcCA9IERFRkFVTFRfU1RSSVAsXG4gICAgY2xvc2VTdHJpcCA9IERFRkFVTFRfU1RSSVAsXG4gIH06IHtcbiAgICBwYXRoOiBBU1R2MS5QYXRoRXhwcmVzc2lvbiB8IEFTVHYxLlN1YkV4cHJlc3Npb247XG4gICAgcGFyYW1zOiBBU1R2MS5FeHByZXNzaW9uW107XG4gICAgaGFzaDogQVNUdjEuSGFzaDtcbiAgICBkZWZhdWx0QmxvY2s6IEFTVHYxLkJsb2NrO1xuICAgIGVsc2VCbG9jaz86IE9wdGlvbjxBU1R2MS5CbG9jaz47XG4gICAgbG9jOiBTb3VyY2VTcGFuO1xuICAgIG9wZW5TdHJpcDogQVNUdjEuU3RyaXBGbGFncztcbiAgICBpbnZlcnNlU3RyaXA6IEFTVHYxLlN0cmlwRmxhZ3M7XG4gICAgY2xvc2VTdHJpcDogQVNUdjEuU3RyaXBGbGFncztcbiAgfSk6IEFTVHYxLkJsb2NrU3RhdGVtZW50IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBwYXJhbXMsXG4gICAgICBoYXNoLFxuICAgICAgcHJvZ3JhbTogZGVmYXVsdEJsb2NrLFxuICAgICAgaW52ZXJzZTogZWxzZUJsb2NrLFxuICAgICAgbG9jOiBsb2MsXG4gICAgICBvcGVuU3RyaXA6IG9wZW5TdHJpcCxcbiAgICAgIGludmVyc2VTdHJpcDogaW52ZXJzZVN0cmlwLFxuICAgICAgY2xvc2VTdHJpcDogY2xvc2VTdHJpcCxcbiAgICB9O1xuICB9XG5cbiAgY29tbWVudCh2YWx1ZTogc3RyaW5nLCBsb2M6IFNvdXJjZU9mZnNldCk6IFBhcnNlck5vZGVCdWlsZGVyPEFTVHYxLkNvbW1lbnRTdGF0ZW1lbnQ+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0NvbW1lbnRTdGF0ZW1lbnQnLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgbG9jLFxuICAgIH07XG4gIH1cblxuICBtdXN0YWNoZUNvbW1lbnQodmFsdWU6IHN0cmluZywgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjEuTXVzdGFjaGVDb21tZW50U3RhdGVtZW50IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ011c3RhY2hlQ29tbWVudFN0YXRlbWVudCcsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBsb2MsXG4gICAgfTtcbiAgfVxuXG4gIGNvbmNhdChcbiAgICBwYXJ0czogUHJlc2VudEFycmF5PEFTVHYxLlRleHROb2RlIHwgQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQ+LFxuICAgIGxvYzogU291cmNlU3BhblxuICApOiBBU1R2MS5Db25jYXRTdGF0ZW1lbnQge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnQ29uY2F0U3RhdGVtZW50JyxcbiAgICAgIHBhcnRzLFxuICAgICAgbG9jLFxuICAgIH07XG4gIH1cblxuICBlbGVtZW50KHtcbiAgICB0YWcsXG4gICAgc2VsZkNsb3NpbmcsXG4gICAgYXR0cnMsXG4gICAgYmxvY2tQYXJhbXMsXG4gICAgbW9kaWZpZXJzLFxuICAgIGNvbW1lbnRzLFxuICAgIGNoaWxkcmVuLFxuICAgIGxvYyxcbiAgfTogQnVpbGRFbGVtZW50T3B0aW9ucyk6IEFTVHYxLkVsZW1lbnROb2RlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0VsZW1lbnROb2RlJyxcbiAgICAgIHRhZyxcbiAgICAgIHNlbGZDbG9zaW5nOiBzZWxmQ2xvc2luZyxcbiAgICAgIGF0dHJpYnV0ZXM6IGF0dHJzIHx8IFtdLFxuICAgICAgYmxvY2tQYXJhbXM6IGJsb2NrUGFyYW1zIHx8IFtdLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMgfHwgW10sXG4gICAgICBjb21tZW50czogKGNvbW1lbnRzIGFzIEFTVHYxLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudFtdKSB8fCBbXSxcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbiB8fCBbXSxcbiAgICAgIGxvYyxcbiAgICB9O1xuICB9XG5cbiAgZWxlbWVudE1vZGlmaWVyKHtcbiAgICBwYXRoLFxuICAgIHBhcmFtcyxcbiAgICBoYXNoLFxuICAgIGxvYyxcbiAgfToge1xuICAgIHBhdGg6IEFTVHYxLlBhdGhFeHByZXNzaW9uIHwgQVNUdjEuU3ViRXhwcmVzc2lvbjtcbiAgICBwYXJhbXM6IEFTVHYxLkV4cHJlc3Npb25bXTtcbiAgICBoYXNoOiBBU1R2MS5IYXNoO1xuICAgIGxvYzogU291cmNlU3BhbjtcbiAgfSk6IEFTVHYxLkVsZW1lbnRNb2RpZmllclN0YXRlbWVudCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnQnLFxuICAgICAgcGF0aCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIGhhc2gsXG4gICAgICBsb2MsXG4gICAgfTtcbiAgfVxuXG4gIGF0dHIoe1xuICAgIG5hbWUsXG4gICAgdmFsdWUsXG4gICAgbG9jLFxuICB9OiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHZhbHVlOiBBU1R2MS5BdHRyTm9kZVsndmFsdWUnXTtcbiAgICBsb2M6IFNvdXJjZVNwYW47XG4gIH0pOiBBU1R2MS5BdHRyTm9kZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdBdHRyTm9kZScsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgbG9jLFxuICAgIH07XG4gIH1cblxuICB0ZXh0KHsgY2hhcnMsIGxvYyB9OiB7IGNoYXJzOiBzdHJpbmc7IGxvYzogU291cmNlU3BhbiB9KTogQVNUdjEuVGV4dE5vZGUge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnVGV4dE5vZGUnLFxuICAgICAgY2hhcnMsXG4gICAgICBsb2MsXG4gICAgfTtcbiAgfVxuXG4gIHNleHByKHtcbiAgICBwYXRoLFxuICAgIHBhcmFtcyxcbiAgICBoYXNoLFxuICAgIGxvYyxcbiAgfToge1xuICAgIHBhdGg6IEFTVHYxLlBhdGhFeHByZXNzaW9uIHwgQVNUdjEuU3ViRXhwcmVzc2lvbjtcbiAgICBwYXJhbXM6IEFTVHYxLkV4cHJlc3Npb25bXTtcbiAgICBoYXNoOiBBU1R2MS5IYXNoO1xuICAgIGxvYzogU291cmNlU3BhbjtcbiAgfSk6IEFTVHYxLlN1YkV4cHJlc3Npb24ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnU3ViRXhwcmVzc2lvbicsXG4gICAgICBwYXRoLFxuICAgICAgcGFyYW1zLFxuICAgICAgaGFzaCxcbiAgICAgIGxvYyxcbiAgICB9O1xuICB9XG5cbiAgcGF0aCh7XG4gICAgaGVhZCxcbiAgICB0YWlsLFxuICAgIGxvYyxcbiAgfToge1xuICAgIGhlYWQ6IEFTVHYxLlBhdGhIZWFkO1xuICAgIHRhaWw6IHN0cmluZ1tdO1xuICAgIGxvYzogU291cmNlU3BhbjtcbiAgfSk6IEFTVHYxLlBhdGhFeHByZXNzaW9uIHtcbiAgICBsZXQgeyBvcmlnaW5hbDogb3JpZ2luYWxIZWFkIH0gPSBoZWFkVG9TdHJpbmcoaGVhZCk7XG4gICAgbGV0IG9yaWdpbmFsID0gWy4uLm9yaWdpbmFsSGVhZCwgLi4udGFpbF0uam9pbignLicpO1xuXG4gICAgcmV0dXJuIG5ldyBQYXRoRXhwcmVzc2lvbkltcGxWMShvcmlnaW5hbCwgaGVhZCwgdGFpbCwgbG9jKTtcbiAgfVxuXG4gIGhlYWQoaGVhZDogc3RyaW5nLCBsb2M6IFNvdXJjZVNwYW4pOiBBU1R2MS5QYXRoSGVhZCB7XG4gICAgaWYgKGhlYWRbMF0gPT09ICdAJykge1xuICAgICAgcmV0dXJuIHRoaXMuYXROYW1lKGhlYWQsIGxvYyk7XG4gICAgfSBlbHNlIGlmIChoZWFkID09PSAndGhpcycpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoaXMobG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudmFyKGhlYWQsIGxvYyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcyhsb2M6IFNvdXJjZVNwYW4pOiBBU1R2MS5QYXRoSGVhZCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdUaGlzSGVhZCcsXG4gICAgICBsb2MsXG4gICAgfTtcbiAgfVxuXG4gIGF0TmFtZShuYW1lOiBzdHJpbmcsIGxvYzogU291cmNlU3Bhbik6IEFTVHYxLlBhdGhIZWFkIHtcbiAgICAvLyB0aGUgYEBgIHNob3VsZCBiZSBpbmNsdWRlZCBzbyB3ZSBoYXZlIGEgY29tcGxldGUgc291cmNlIHJhbmdlXG4gICAgYXNzZXJ0KG5hbWVbMF0gPT09ICdAJywgYGNhbGwgYnVpbGRlcnMuYXQoKSB3aXRoIGEgc3RyaW5nIHRoYXQgc3RhcnRzIHdpdGggJ0AnYCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0F0SGVhZCcsXG4gICAgICBuYW1lLFxuICAgICAgbG9jLFxuICAgIH07XG4gIH1cblxuICB2YXIobmFtZTogc3RyaW5nLCBsb2M6IFNvdXJjZVNwYW4pOiBBU1R2MS5QYXRoSGVhZCB7XG4gICAgYXNzZXJ0KG5hbWUgIT09ICd0aGlzJywgYFlvdSBjYWxsZWQgYnVpbGRlcnMudmFyKCkgd2l0aCAndGhpcycuIENhbGwgYnVpbGRlcnMudGhpcyBpbnN0ZWFkYCk7XG4gICAgYXNzZXJ0KFxuICAgICAgbmFtZVswXSAhPT0gJ0AnLFxuICAgICAgYFlvdSBjYWxsZWQgYnVpbGRlcnMudmFyKCkgd2l0aCAnJHtuYW1lfScuIENhbGwgYnVpbGRlcnMuYXQoJyR7bmFtZX0nKSBpbnN0ZWFkYFxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1ZhckhlYWQnLFxuICAgICAgbmFtZSxcbiAgICAgIGxvYyxcbiAgICB9O1xuICB9XG5cbiAgaGFzaChwYWlyczogQVNUdjEuSGFzaFBhaXJbXSwgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjEuSGFzaCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdIYXNoJyxcbiAgICAgIHBhaXJzOiBwYWlycyB8fCBbXSxcbiAgICAgIGxvYyxcbiAgICB9O1xuICB9XG5cbiAgcGFpcih7XG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIGxvYyxcbiAgfToge1xuICAgIGtleTogc3RyaW5nO1xuICAgIHZhbHVlOiBBU1R2MS5FeHByZXNzaW9uO1xuICAgIGxvYzogU291cmNlU3BhbjtcbiAgfSk6IEFTVHYxLkhhc2hQYWlyIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0hhc2hQYWlyJyxcbiAgICAgIGtleToga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBsb2MsXG4gICAgfTtcbiAgfVxuXG4gIGxpdGVyYWw8VCBleHRlbmRzIEFTVHYxLkxpdGVyYWw+KHtcbiAgICB0eXBlLFxuICAgIHZhbHVlLFxuICAgIGxvYyxcbiAgfToge1xuICAgIHR5cGU6IFRbJ3R5cGUnXTtcbiAgICB2YWx1ZTogVFsndmFsdWUnXTtcbiAgICBsb2M/OiBTb3VyY2VMb2NhdGlvbjtcbiAgfSk6IFQge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbDogdmFsdWUsXG4gICAgICBsb2MsXG4gICAgfSBhcyBUO1xuICB9XG5cbiAgdW5kZWZpbmVkKCk6IEFTVHYxLlVuZGVmaW5lZExpdGVyYWwge1xuICAgIHJldHVybiB0aGlzLmxpdGVyYWwoeyB0eXBlOiAnVW5kZWZpbmVkTGl0ZXJhbCcsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gIH1cblxuICBudWxsKCk6IEFTVHYxLk51bGxMaXRlcmFsIHtcbiAgICByZXR1cm4gdGhpcy5saXRlcmFsKHsgdHlwZTogJ051bGxMaXRlcmFsJywgdmFsdWU6IG51bGwgfSk7XG4gIH1cblxuICBzdHJpbmcodmFsdWU6IHN0cmluZywgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjEuU3RyaW5nTGl0ZXJhbCB7XG4gICAgcmV0dXJuIHRoaXMubGl0ZXJhbCh7IHR5cGU6ICdTdHJpbmdMaXRlcmFsJywgdmFsdWUsIGxvYyB9KTtcbiAgfVxuXG4gIGJvb2xlYW4odmFsdWU6IGJvb2xlYW4sIGxvYzogU291cmNlU3Bhbik6IEFTVHYxLkJvb2xlYW5MaXRlcmFsIHtcbiAgICByZXR1cm4gdGhpcy5saXRlcmFsKHsgdHlwZTogJ0Jvb2xlYW5MaXRlcmFsJywgdmFsdWUsIGxvYyB9KTtcbiAgfVxuXG4gIG51bWJlcih2YWx1ZTogbnVtYmVyLCBsb2M6IFNvdXJjZVNwYW4pOiBBU1R2MS5OdW1iZXJMaXRlcmFsIHtcbiAgICByZXR1cm4gdGhpcy5saXRlcmFsKHsgdHlwZTogJ051bWJlckxpdGVyYWwnLCB2YWx1ZSwgbG9jIH0pO1xuICB9XG59XG5cbi8vIE5vZGVzXG5cbmV4cG9ydCB0eXBlIEVsZW1lbnRQYXJ0cyA9XG4gIHwgWydhdHRycycsIC4uLkF0dHJTZXhwW11dXG4gIHwgWydtb2RpZmllcnMnLCAuLi5Nb2RpZmllclNleHBbXV1cbiAgfCBbJ2JvZHknLCAuLi5BU1R2MS5TdGF0ZW1lbnRbXV1cbiAgfCBbJ2NvbW1lbnRzJywgLi4uRWxlbWVudENvbW1lbnRbXV1cbiAgfCBbJ2FzJywgLi4uc3RyaW5nW11dXG4gIHwgWydsb2MnLCBTb3VyY2VMb2NhdGlvbl07XG5cbmV4cG9ydCB0eXBlIFBhdGhTZXhwID0gc3RyaW5nIHwgWydwYXRoJywgc3RyaW5nLCBMb2NTZXhwP107XG5cbmV4cG9ydCB0eXBlIE1vZGlmaWVyU2V4cCA9XG4gIHwgc3RyaW5nXG4gIHwgW1BhdGhTZXhwLCBMb2NTZXhwP11cbiAgfCBbUGF0aFNleHAsIEFTVHYxLkV4cHJlc3Npb25bXSwgTG9jU2V4cD9dXG4gIHwgW1BhdGhTZXhwLCBBU1R2MS5FeHByZXNzaW9uW10sIERpY3Q8QVNUdjEuRXhwcmVzc2lvbj4sIExvY1NleHA/XTtcblxuZXhwb3J0IHR5cGUgQXR0clNleHAgPSBbc3RyaW5nLCBBU1R2MS5BdHRyTm9kZVsndmFsdWUnXSB8IHN0cmluZywgTG9jU2V4cD9dO1xuXG5leHBvcnQgdHlwZSBMb2NTZXhwID0gWydsb2MnLCBTb3VyY2VMb2NhdGlvbl07XG5cbmV4cG9ydCB0eXBlIEVsZW1lbnRDb21tZW50ID0gQVNUdjEuTXVzdGFjaGVDb21tZW50U3RhdGVtZW50IHwgU291cmNlTG9jYXRpb24gfCBzdHJpbmc7XG5cbmV4cG9ydCB0eXBlIFNleHBWYWx1ZSA9XG4gIHwgc3RyaW5nXG4gIHwgQVNUdjEuRXhwcmVzc2lvbltdXG4gIHwgRGljdDxBU1R2MS5FeHByZXNzaW9uPlxuICB8IExvY1NleHBcbiAgfCBQYXRoU2V4cFxuICB8IHVuZGVmaW5lZDtcblxuZXhwb3J0IGludGVyZmFjZSBCdWlsZEVsZW1lbnRPcHRpb25zIHtcbiAgdGFnOiBzdHJpbmc7XG4gIHNlbGZDbG9zaW5nOiBib29sZWFuO1xuICBhdHRyczogQVNUdjEuQXR0ck5vZGVbXTtcbiAgbW9kaWZpZXJzOiBBU1R2MS5FbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnRbXTtcbiAgY2hpbGRyZW46IEFTVHYxLlN0YXRlbWVudFtdO1xuICBjb21tZW50czogRWxlbWVudENvbW1lbnRbXTtcbiAgYmxvY2tQYXJhbXM6IHN0cmluZ1tdO1xuICBsb2M6IFNvdXJjZVNwYW47XG59XG5cbi8vIEV4cHJlc3Npb25zXG5cbmZ1bmN0aW9uIGhlYWRUb1N0cmluZyhoZWFkOiBBU1R2MS5QYXRoSGVhZCk6IHsgb3JpZ2luYWw6IHN0cmluZzsgcGFydHM6IHN0cmluZ1tdIH0ge1xuICBzd2l0Y2ggKGhlYWQudHlwZSkge1xuICAgIGNhc2UgJ0F0SGVhZCc6XG4gICAgICByZXR1cm4geyBvcmlnaW5hbDogaGVhZC5uYW1lLCBwYXJ0czogW2hlYWQubmFtZV0gfTtcbiAgICBjYXNlICdUaGlzSGVhZCc6XG4gICAgICByZXR1cm4geyBvcmlnaW5hbDogYHRoaXNgLCBwYXJ0czogW10gfTtcbiAgICBjYXNlICdWYXJIZWFkJzpcbiAgICAgIHJldHVybiB7IG9yaWdpbmFsOiBoZWFkLm5hbWUsIHBhcnRzOiBbaGVhZC5uYW1lXSB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBCdWlsZGVycygpO1xuIiwiaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2lnbiwgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQge1xuICBFbnRpdHlQYXJzZXIsXG4gIEV2ZW50ZWRUb2tlbml6ZXIsXG4gIEhUTUw1TmFtZWRDaGFyUmVmcyBhcyBuYW1lZENoYXJSZWZzLFxufSBmcm9tICdzaW1wbGUtaHRtbC10b2tlbml6ZXInO1xuXG5pbXBvcnQgeyBTb3VyY2VQb3NpdGlvbiB9IGZyb20gJy4vc291cmNlL2xvY2F0aW9uJztcbmltcG9ydCB7IFNvdXJjZSB9IGZyb20gJy4vc291cmNlL3NvdXJjZSc7XG5pbXBvcnQgeyBTb3VyY2VPZmZzZXQsIFNvdXJjZVNwYW4gfSBmcm9tICcuL3NvdXJjZS9zcGFuJztcbmltcG9ydCAqIGFzIEFTVHYxIGZyb20gJy4vdjEvYXBpJztcbmltcG9ydCAqIGFzIEhCUyBmcm9tICcuL3YxL2hhbmRsZWJhcnMtYXN0JztcblxuZXhwb3J0IHR5cGUgUGFyc2VyTm9kZUJ1aWxkZXI8TiBleHRlbmRzIHsgbG9jOiBTb3VyY2VTcGFuIH0+ID0gT21pdDxOLCAnbG9jJz4gJiB7XG4gIGxvYzogU291cmNlT2Zmc2V0O1xufTtcblxuZXhwb3J0IHR5cGUgRWxlbWVudCA9IEFTVHYxLlRlbXBsYXRlIHwgQVNUdjEuQmxvY2sgfCBBU1R2MS5FbGVtZW50Tm9kZTtcblxuZXhwb3J0IGludGVyZmFjZSBUYWc8VCBleHRlbmRzICdTdGFydFRhZycgfCAnRW5kVGFnJz4ge1xuICByZWFkb25seSB0eXBlOiBUO1xuICBuYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGF0dHJpYnV0ZXM6IEFTVHYxLkF0dHJOb2RlW107XG4gIHJlYWRvbmx5IG1vZGlmaWVyczogQVNUdjEuRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50W107XG4gIHJlYWRvbmx5IGNvbW1lbnRzOiBBU1R2MS5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnRbXTtcbiAgc2VsZkNsb3Npbmc6IGJvb2xlYW47XG4gIHJlYWRvbmx5IGxvYzogU291cmNlU3Bhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIGN1cnJlbnRQYXJ0OiBBU1R2MS5UZXh0Tm9kZSB8IG51bGw7XG4gIHBhcnRzOiAoQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1R2MS5UZXh0Tm9kZSlbXTtcbiAgaXNRdW90ZWQ6IGJvb2xlYW47XG4gIGlzRHluYW1pYzogYm9vbGVhbjtcbiAgc3RhcnQ6IFNvdXJjZU9mZnNldDtcbiAgdmFsdWVTcGFuOiBTb3VyY2VTcGFuO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUGFyc2VyIHtcbiAgcHJvdGVjdGVkIGVsZW1lbnRTdGFjazogRWxlbWVudFtdID0gW107XG4gIHByaXZhdGUgbGluZXM6IHN0cmluZ1tdO1xuICByZWFkb25seSBzb3VyY2U6IFNvdXJjZTtcbiAgcHVibGljIGN1cnJlbnRBdHRyaWJ1dGU6IE9wdGlvbjxBdHRyaWJ1dGU+ID0gbnVsbDtcbiAgcHVibGljIGN1cnJlbnROb2RlOiBPcHRpb248XG4gICAgUmVhZG9ubHk8XG4gICAgICB8IFBhcnNlck5vZGVCdWlsZGVyPEFTVHYxLkNvbW1lbnRTdGF0ZW1lbnQ+XG4gICAgICB8IEFTVHYxLlRleHROb2RlXG4gICAgICB8IFBhcnNlck5vZGVCdWlsZGVyPFRhZzwnU3RhcnRUYWcnPj5cbiAgICAgIHwgUGFyc2VyTm9kZUJ1aWxkZXI8VGFnPCdFbmRUYWcnPj5cbiAgICA+XG4gID4gPSBudWxsO1xuICBwdWJsaWMgdG9rZW5pemVyOiBFdmVudGVkVG9rZW5pemVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHNvdXJjZTogU291cmNlLFxuICAgIGVudGl0eVBhcnNlciA9IG5ldyBFbnRpdHlQYXJzZXIobmFtZWRDaGFyUmVmcyksXG4gICAgbW9kZTogJ3ByZWNvbXBpbGUnIHwgJ2NvZGVtb2QnID0gJ3ByZWNvbXBpbGUnXG4gICkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMubGluZXMgPSBzb3VyY2Uuc291cmNlLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgdGhpcy50b2tlbml6ZXIgPSBuZXcgRXZlbnRlZFRva2VuaXplcih0aGlzLCBlbnRpdHlQYXJzZXIsIG1vZGUpO1xuICB9XG5cbiAgb2Zmc2V0KCk6IFNvdXJjZU9mZnNldCB7XG4gICAgbGV0IHsgbGluZSwgY29sdW1uIH0gPSB0aGlzLnRva2VuaXplcjtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2Uub2Zmc2V0Rm9yKGxpbmUsIGNvbHVtbik7XG4gIH1cblxuICBwb3MoeyBsaW5lLCBjb2x1bW4gfTogU291cmNlUG9zaXRpb24pOiBTb3VyY2VPZmZzZXQge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5vZmZzZXRGb3IobGluZSwgY29sdW1uKTtcbiAgfVxuXG4gIGZpbmlzaDxUIGV4dGVuZHMgeyBsb2M6IFNvdXJjZVNwYW4gfT4obm9kZTogUGFyc2VyTm9kZUJ1aWxkZXI8VD4pOiBUIHtcbiAgICByZXR1cm4gKGFzc2lnbih7fSwgbm9kZSwge1xuICAgICAgbG9jOiBub2RlLmxvYy51bnRpbCh0aGlzLm9mZnNldCgpKSxcbiAgICB9IGFzIGNvbnN0KSBhcyB1bmtub3duKSBhcyBUO1xuXG4gICAgLy8gbm9kZS5sb2MgPSBub2RlLmxvYy53aXRoRW5kKGVuZCk7XG4gIH1cblxuICBhYnN0cmFjdCBQcm9ncmFtKG5vZGU6IEhCUy5Qcm9ncmFtKTogSEJTLk91dHB1dDwnUHJvZ3JhbSc+O1xuICBhYnN0cmFjdCBNdXN0YWNoZVN0YXRlbWVudChub2RlOiBIQlMuTXVzdGFjaGVTdGF0ZW1lbnQpOiBIQlMuT3V0cHV0PCdNdXN0YWNoZVN0YXRlbWVudCc+O1xuICBhYnN0cmFjdCBEZWNvcmF0b3Iobm9kZTogSEJTLkRlY29yYXRvcik6IEhCUy5PdXRwdXQ8J0RlY29yYXRvcic+O1xuICBhYnN0cmFjdCBCbG9ja1N0YXRlbWVudChub2RlOiBIQlMuQmxvY2tTdGF0ZW1lbnQpOiBIQlMuT3V0cHV0PCdCbG9ja1N0YXRlbWVudCc+O1xuICBhYnN0cmFjdCBEZWNvcmF0b3JCbG9jayhub2RlOiBIQlMuRGVjb3JhdG9yQmxvY2spOiBIQlMuT3V0cHV0PCdEZWNvcmF0b3JCbG9jayc+O1xuICBhYnN0cmFjdCBQYXJ0aWFsU3RhdGVtZW50KG5vZGU6IEhCUy5QYXJ0aWFsU3RhdGVtZW50KTogSEJTLk91dHB1dDwnUGFydGlhbFN0YXRlbWVudCc+O1xuICBhYnN0cmFjdCBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQoXG4gICAgbm9kZTogSEJTLlBhcnRpYWxCbG9ja1N0YXRlbWVudFxuICApOiBIQlMuT3V0cHV0PCdQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQnPjtcbiAgYWJzdHJhY3QgQ29udGVudFN0YXRlbWVudChub2RlOiBIQlMuQ29udGVudFN0YXRlbWVudCk6IEhCUy5PdXRwdXQ8J0NvbnRlbnRTdGF0ZW1lbnQnPjtcbiAgYWJzdHJhY3QgQ29tbWVudFN0YXRlbWVudChub2RlOiBIQlMuQ29tbWVudFN0YXRlbWVudCk6IEhCUy5PdXRwdXQ8J0NvbW1lbnRTdGF0ZW1lbnQnPjtcbiAgYWJzdHJhY3QgU3ViRXhwcmVzc2lvbihub2RlOiBIQlMuU3ViRXhwcmVzc2lvbik6IEhCUy5PdXRwdXQ8J1N1YkV4cHJlc3Npb24nPjtcbiAgYWJzdHJhY3QgUGF0aEV4cHJlc3Npb24obm9kZTogSEJTLlBhdGhFeHByZXNzaW9uKTogSEJTLk91dHB1dDwnUGF0aEV4cHJlc3Npb24nPjtcbiAgYWJzdHJhY3QgU3RyaW5nTGl0ZXJhbChub2RlOiBIQlMuU3RyaW5nTGl0ZXJhbCk6IEhCUy5PdXRwdXQ8J1N0cmluZ0xpdGVyYWwnPjtcbiAgYWJzdHJhY3QgQm9vbGVhbkxpdGVyYWwobm9kZTogSEJTLkJvb2xlYW5MaXRlcmFsKTogSEJTLk91dHB1dDwnQm9vbGVhbkxpdGVyYWwnPjtcbiAgYWJzdHJhY3QgTnVtYmVyTGl0ZXJhbChub2RlOiBIQlMuTnVtYmVyTGl0ZXJhbCk6IEhCUy5PdXRwdXQ8J051bWJlckxpdGVyYWwnPjtcbiAgYWJzdHJhY3QgVW5kZWZpbmVkTGl0ZXJhbChub2RlOiBIQlMuVW5kZWZpbmVkTGl0ZXJhbCk6IEhCUy5PdXRwdXQ8J1VuZGVmaW5lZExpdGVyYWwnPjtcbiAgYWJzdHJhY3QgTnVsbExpdGVyYWwobm9kZTogSEJTLk51bGxMaXRlcmFsKTogSEJTLk91dHB1dDwnTnVsbExpdGVyYWwnPjtcblxuICBhYnN0cmFjdCByZXNldCgpOiB2b2lkO1xuICBhYnN0cmFjdCBmaW5pc2hEYXRhKCk6IHZvaWQ7XG4gIGFic3RyYWN0IHRhZ09wZW4oKTogdm9pZDtcbiAgYWJzdHJhY3QgYmVnaW5EYXRhKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGFwcGVuZFRvRGF0YShjaGFyOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpblN0YXJ0VGFnKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGFwcGVuZFRvVGFnTmFtZShjaGFyOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpbkF0dHJpYnV0ZSgpOiB2b2lkO1xuICBhYnN0cmFjdCBhcHBlbmRUb0F0dHJpYnV0ZU5hbWUoY2hhcjogc3RyaW5nKTogdm9pZDtcbiAgYWJzdHJhY3QgYmVnaW5BdHRyaWJ1dGVWYWx1ZShxdW90ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICBhYnN0cmFjdCBhcHBlbmRUb0F0dHJpYnV0ZVZhbHVlKGNoYXI6IHN0cmluZyk6IHZvaWQ7XG4gIGFic3RyYWN0IGZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk6IHZvaWQ7XG4gIGFic3RyYWN0IG1hcmtUYWdBc1NlbGZDbG9zaW5nKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGJlZ2luRW5kVGFnKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGZpbmlzaFRhZygpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpbkNvbW1lbnQoKTogdm9pZDtcbiAgYWJzdHJhY3QgYXBwZW5kVG9Db21tZW50RGF0YShjaGFyOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBmaW5pc2hDb21tZW50KCk6IHZvaWQ7XG4gIGFic3RyYWN0IHJlcG9ydFN5bnRheEVycm9yKGVycm9yOiBzdHJpbmcpOiB2b2lkO1xuXG4gIGdldCBjdXJyZW50QXR0cigpOiBBdHRyaWJ1dGUge1xuICAgIHJldHVybiBleHBlY3QodGhpcy5jdXJyZW50QXR0cmlidXRlLCAnZXhwZWN0ZWQgYXR0cmlidXRlJyk7XG4gIH1cblxuICBnZXQgY3VycmVudFRhZygpOiBQYXJzZXJOb2RlQnVpbGRlcjxUYWc8J1N0YXJ0VGFnJyB8ICdFbmRUYWcnPj4ge1xuICAgIGxldCBub2RlID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICBhc3NlcnQobm9kZSAmJiAobm9kZS50eXBlID09PSAnU3RhcnRUYWcnIHx8IG5vZGUudHlwZSA9PT0gJ0VuZFRhZycpLCAnZXhwZWN0ZWQgdGFnJyk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBnZXQgY3VycmVudFN0YXJ0VGFnKCk6IFBhcnNlck5vZGVCdWlsZGVyPFRhZzwnU3RhcnRUYWcnPj4ge1xuICAgIGxldCBub2RlID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICBhc3NlcnQobm9kZSAmJiBub2RlLnR5cGUgPT09ICdTdGFydFRhZycsICdleHBlY3RlZCBzdGFydCB0YWcnKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGdldCBjdXJyZW50RW5kVGFnKCk6IFBhcnNlck5vZGVCdWlsZGVyPFRhZzwnRW5kVGFnJz4+IHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgYXNzZXJ0KG5vZGUgJiYgbm9kZS50eXBlID09PSAnRW5kVGFnJywgJ2V4cGVjdGVkIGVuZCB0YWcnKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGdldCBjdXJyZW50Q29tbWVudCgpOiBQYXJzZXJOb2RlQnVpbGRlcjxBU1R2MS5Db21tZW50U3RhdGVtZW50PiB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIGFzc2VydChub2RlICYmIG5vZGUudHlwZSA9PT0gJ0NvbW1lbnRTdGF0ZW1lbnQnLCAnZXhwZWN0ZWQgYSBjb21tZW50Jyk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBnZXQgY3VycmVudERhdGEoKTogQVNUdjEuVGV4dE5vZGUge1xuICAgIGxldCBub2RlID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICBhc3NlcnQobm9kZSAmJiBub2RlLnR5cGUgPT09ICdUZXh0Tm9kZScsICdleHBlY3RlZCBhIHRleHQgbm9kZScpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgYWNjZXB0VGVtcGxhdGUobm9kZTogSEJTLlByb2dyYW0pOiBBU1R2MS5UZW1wbGF0ZSB7XG4gICAgcmV0dXJuIHRoaXNbbm9kZS50eXBlIGFzICdQcm9ncmFtJ10obm9kZSkgYXMgQVNUdjEuVGVtcGxhdGU7XG4gIH1cblxuICBhY2NlcHROb2RlKG5vZGU6IEhCUy5Qcm9ncmFtKTogQVNUdjEuQmxvY2sgfCBBU1R2MS5UZW1wbGF0ZTtcbiAgYWNjZXB0Tm9kZTxVIGV4dGVuZHMgSEJTLk5vZGUgfCBBU1R2MS5Ob2RlPihub2RlOiBIQlMuTm9kZSk6IFU7XG4gIGFjY2VwdE5vZGU8VCBleHRlbmRzIEhCUy5Ob2RlVHlwZT4obm9kZTogSEJTLk5vZGU8VD4pOiBIQlMuT3V0cHV0PFQ+IHtcbiAgICByZXR1cm4gKHRoaXNbbm9kZS50eXBlIGFzIFRdIGFzIChub2RlOiBIQlMuTm9kZTxUPikgPT4gSEJTLk91dHB1dDxUPikobm9kZSk7XG4gIH1cblxuICBjdXJyZW50RWxlbWVudCgpOiBFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50U3RhY2tbdGhpcy5lbGVtZW50U3RhY2subGVuZ3RoIC0gMV07XG4gIH1cblxuICBzb3VyY2VGb3JOb2RlKG5vZGU6IEhCUy5Ob2RlLCBlbmROb2RlPzogeyBsb2M6IEhCUy5Tb3VyY2VMb2NhdGlvbiB9KTogc3RyaW5nIHtcbiAgICBsZXQgZmlyc3RMaW5lID0gbm9kZS5sb2Muc3RhcnQubGluZSAtIDE7XG4gICAgbGV0IGN1cnJlbnRMaW5lID0gZmlyc3RMaW5lIC0gMTtcbiAgICBsZXQgZmlyc3RDb2x1bW4gPSBub2RlLmxvYy5zdGFydC5jb2x1bW47XG4gICAgbGV0IHN0cmluZyA9IFtdO1xuICAgIGxldCBsaW5lO1xuXG4gICAgbGV0IGxhc3RMaW5lOiBudW1iZXI7XG4gICAgbGV0IGxhc3RDb2x1bW46IG51bWJlcjtcblxuICAgIGlmIChlbmROb2RlKSB7XG4gICAgICBsYXN0TGluZSA9IGVuZE5vZGUubG9jLmVuZC5saW5lIC0gMTtcbiAgICAgIGxhc3RDb2x1bW4gPSBlbmROb2RlLmxvYy5lbmQuY29sdW1uO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0TGluZSA9IG5vZGUubG9jLmVuZC5saW5lIC0gMTtcbiAgICAgIGxhc3RDb2x1bW4gPSBub2RlLmxvYy5lbmQuY29sdW1uO1xuICAgIH1cblxuICAgIHdoaWxlIChjdXJyZW50TGluZSA8IGxhc3RMaW5lKSB7XG4gICAgICBjdXJyZW50TGluZSsrO1xuICAgICAgbGluZSA9IHRoaXMubGluZXNbY3VycmVudExpbmVdO1xuXG4gICAgICBpZiAoY3VycmVudExpbmUgPT09IGZpcnN0TGluZSkge1xuICAgICAgICBpZiAoZmlyc3RMaW5lID09PSBsYXN0TGluZSkge1xuICAgICAgICAgIHN0cmluZy5wdXNoKGxpbmUuc2xpY2UoZmlyc3RDb2x1bW4sIGxhc3RDb2x1bW4pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJpbmcucHVzaChsaW5lLnNsaWNlKGZpcnN0Q29sdW1uKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudExpbmUgPT09IGxhc3RMaW5lKSB7XG4gICAgICAgIHN0cmluZy5wdXNoKGxpbmUuc2xpY2UoMCwgbGFzdENvbHVtbikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyaW5nLnB1c2gobGluZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZy5qb2luKCdcXG4nKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgT3B0aW9uLCBSZWNhc3QgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFRva2VuaXplclN0YXRlIH0gZnJvbSAnc2ltcGxlLWh0bWwtdG9rZW5pemVyJztcblxuaW1wb3J0IHsgUGFyc2VyLCBQYXJzZXJOb2RlQnVpbGRlciwgVGFnIH0gZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7IE5PTl9FWElTVEVOVF9MT0NBVElPTiB9IGZyb20gJy4uL3NvdXJjZS9sb2NhdGlvbic7XG5pbXBvcnQgeyBnZW5lcmF0ZVN5bnRheEVycm9yIH0gZnJvbSAnLi4vc3ludGF4LWVycm9yJztcbmltcG9ydCB7IGFwcGVuZENoaWxkLCBpc0hCU0xpdGVyYWwsIHByaW50TGl0ZXJhbCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIEFTVHYxIGZyb20gJy4uL3YxL2FwaSc7XG5pbXBvcnQgKiBhcyBIQlMgZnJvbSAnLi4vdjEvaGFuZGxlYmFycy1hc3QnO1xuaW1wb3J0IHsgUGF0aEV4cHJlc3Npb25JbXBsVjEgfSBmcm9tICcuLi92MS9sZWdhY3ktaW50ZXJvcCc7XG5pbXBvcnQgYiBmcm9tICcuLi92MS9wYXJzZXItYnVpbGRlcnMnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSGFuZGxlYmFyc05vZGVWaXNpdG9ycyBleHRlbmRzIFBhcnNlciB7XG4gIGFic3RyYWN0IGFwcGVuZFRvQ29tbWVudERhdGEoczogc3RyaW5nKTogdm9pZDtcbiAgYWJzdHJhY3QgYmVnaW5BdHRyaWJ1dGVWYWx1ZShxdW90ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICBhYnN0cmFjdCBmaW5pc2hBdHRyaWJ1dGVWYWx1ZSgpOiB2b2lkO1xuXG4gIHByaXZhdGUgZ2V0IGlzVG9wTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YWNrLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIFByb2dyYW0ocHJvZ3JhbTogSEJTLlByb2dyYW0pOiBBU1R2MS5CbG9jaztcbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVHYxLlRlbXBsYXRlO1xuICBQcm9ncmFtKHByb2dyYW06IEhCUy5Qcm9ncmFtKTogQVNUdjEuVGVtcGxhdGUgfCBBU1R2MS5CbG9jaztcbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVHYxLkJsb2NrIHwgQVNUdjEuVGVtcGxhdGUge1xuICAgIGxldCBib2R5OiBBU1R2MS5TdGF0ZW1lbnRbXSA9IFtdO1xuICAgIGxldCBub2RlO1xuXG4gICAgaWYgKHRoaXMuaXNUb3BMZXZlbCkge1xuICAgICAgbm9kZSA9IGIudGVtcGxhdGUoe1xuICAgICAgICBib2R5LFxuICAgICAgICBibG9ja1BhcmFtczogcHJvZ3JhbS5ibG9ja1BhcmFtcyxcbiAgICAgICAgbG9jOiB0aGlzLnNvdXJjZS5zcGFuRm9yKHByb2dyYW0ubG9jKSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gYi5ibG9ja0l0c2VsZih7XG4gICAgICAgIGJvZHksXG4gICAgICAgIGJsb2NrUGFyYW1zOiBwcm9ncmFtLmJsb2NrUGFyYW1zLFxuICAgICAgICBjaGFpbmVkOiBwcm9ncmFtLmNoYWluZWQsXG4gICAgICAgIGxvYzogdGhpcy5zb3VyY2Uuc3BhbkZvcihwcm9ncmFtLmxvYyksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgaSxcbiAgICAgIGwgPSBwcm9ncmFtLmJvZHkubGVuZ3RoO1xuXG4gICAgdGhpcy5lbGVtZW50U3RhY2sucHVzaChub2RlKTtcblxuICAgIGlmIChsID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50U3RhY2sucG9wKCkgYXMgQVNUdjEuQmxvY2sgfCBBU1R2MS5UZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLmFjY2VwdE5vZGUocHJvZ3JhbS5ib2R5W2ldKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGF0IHRoZSBlbGVtZW50IHN0YWNrIGlzIGJhbGFuY2VkIHByb3Blcmx5LlxuICAgIGxldCBwb3BwZWROb2RlID0gdGhpcy5lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgaWYgKHBvcHBlZE5vZGUgIT09IG5vZGUpIHtcbiAgICAgIGxldCBlbGVtZW50Tm9kZSA9IHBvcHBlZE5vZGUgYXMgQVNUdjEuRWxlbWVudE5vZGU7XG5cbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoYFVuY2xvc2VkIGVsZW1lbnQgXFxgJHtlbGVtZW50Tm9kZS50YWd9XFxgYCwgZWxlbWVudE5vZGUubG9jKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIEJsb2NrU3RhdGVtZW50KGJsb2NrOiBIQlMuQmxvY2tTdGF0ZW1lbnQpOiBBU1R2MS5CbG9ja1N0YXRlbWVudCB8IHZvaWQge1xuICAgIGlmICh0aGlzLnRva2VuaXplci5zdGF0ZSA9PT0gVG9rZW5pemVyU3RhdGUuY29tbWVudCkge1xuICAgICAgdGhpcy5hcHBlbmRUb0NvbW1lbnREYXRhKHRoaXMuc291cmNlRm9yTm9kZShibG9jaykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMudG9rZW5pemVyLnN0YXRlICE9PSBUb2tlbml6ZXJTdGF0ZS5kYXRhICYmXG4gICAgICB0aGlzLnRva2VuaXplci5zdGF0ZSAhPT0gVG9rZW5pemVyU3RhdGUuYmVmb3JlRGF0YVxuICAgICkge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgJ0EgYmxvY2sgbWF5IG9ubHkgYmUgdXNlZCBpbnNpZGUgYW4gSFRNTCBlbGVtZW50IG9yIGFub3RoZXIgYmxvY2suJyxcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3BhbkZvcihibG9jay5sb2MpXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIGJsb2NrKTtcblxuICAgIC8vIFRoZXNlIGFyZSBidWdzIGluIEhhbmRsZWJhcnMgdXBzdHJlYW1cbiAgICBpZiAoIWJsb2NrLnByb2dyYW0ubG9jKSB7XG4gICAgICBibG9jay5wcm9ncmFtLmxvYyA9IE5PTl9FWElTVEVOVF9MT0NBVElPTjtcbiAgICB9XG5cbiAgICBpZiAoYmxvY2suaW52ZXJzZSAmJiAhYmxvY2suaW52ZXJzZS5sb2MpIHtcbiAgICAgIGJsb2NrLmludmVyc2UubG9jID0gTk9OX0VYSVNURU5UX0xPQ0FUSU9OO1xuICAgIH1cblxuICAgIGxldCBwcm9ncmFtID0gdGhpcy5Qcm9ncmFtKGJsb2NrLnByb2dyYW0pO1xuICAgIGxldCBpbnZlcnNlID0gYmxvY2suaW52ZXJzZSA/IHRoaXMuUHJvZ3JhbShibG9jay5pbnZlcnNlKSA6IG51bGw7XG5cbiAgICBsZXQgbm9kZSA9IGIuYmxvY2soe1xuICAgICAgcGF0aCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIGhhc2gsXG4gICAgICBkZWZhdWx0QmxvY2s6IHByb2dyYW0sXG4gICAgICBlbHNlQmxvY2s6IGludmVyc2UsXG4gICAgICBsb2M6IHRoaXMuc291cmNlLnNwYW5Gb3IoYmxvY2subG9jKSxcbiAgICAgIG9wZW5TdHJpcDogYmxvY2sub3BlblN0cmlwLFxuICAgICAgaW52ZXJzZVN0cmlwOiBibG9jay5pbnZlcnNlU3RyaXAsXG4gICAgICBjbG9zZVN0cmlwOiBibG9jay5jbG9zZVN0cmlwLFxuICAgIH0pO1xuXG4gICAgbGV0IHBhcmVudFByb2dyYW0gPSB0aGlzLmN1cnJlbnRFbGVtZW50KCk7XG5cbiAgICBhcHBlbmRDaGlsZChwYXJlbnRQcm9ncmFtLCBub2RlKTtcbiAgfVxuXG4gIE11c3RhY2hlU3RhdGVtZW50KHJhd011c3RhY2hlOiBIQlMuTXVzdGFjaGVTdGF0ZW1lbnQpOiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCB8IHZvaWQge1xuICAgIGxldCB7IHRva2VuaXplciB9ID0gdGhpcztcblxuICAgIGlmICh0b2tlbml6ZXIuc3RhdGUgPT09ICdjb21tZW50Jykge1xuICAgICAgdGhpcy5hcHBlbmRUb0NvbW1lbnREYXRhKHRoaXMuc291cmNlRm9yTm9kZShyYXdNdXN0YWNoZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBtdXN0YWNoZTogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQ7XG4gICAgbGV0IHsgZXNjYXBlZCwgbG9jLCBzdHJpcCB9ID0gcmF3TXVzdGFjaGU7XG5cbiAgICBpZiAoaXNIQlNMaXRlcmFsKHJhd011c3RhY2hlLnBhdGgpKSB7XG4gICAgICBtdXN0YWNoZSA9IGIubXVzdGFjaGUoe1xuICAgICAgICBwYXRoOiB0aGlzLmFjY2VwdE5vZGU8QVNUdjEuTGl0ZXJhbD4ocmF3TXVzdGFjaGUucGF0aCksXG4gICAgICAgIHBhcmFtczogW10sXG4gICAgICAgIGhhc2g6IGIuaGFzaChbXSwgdGhpcy5zb3VyY2Uuc3BhbkZvcihyYXdNdXN0YWNoZS5wYXRoLmxvYykuY29sbGFwc2UoJ2VuZCcpKSxcbiAgICAgICAgdHJ1c3Rpbmc6ICFlc2NhcGVkLFxuICAgICAgICBsb2M6IHRoaXMuc291cmNlLnNwYW5Gb3IobG9jKSxcbiAgICAgICAgc3RyaXAsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHsgcGF0aCwgcGFyYW1zLCBoYXNoIH0gPSBhY2NlcHRDYWxsTm9kZXMoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHJhd011c3RhY2hlIGFzIEhCUy5NdXN0YWNoZVN0YXRlbWVudCAmIHtcbiAgICAgICAgICBwYXRoOiBIQlMuUGF0aEV4cHJlc3Npb24gfCBIQlMuU3ViRXhwcmVzc2lvbjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIG11c3RhY2hlID0gYi5tdXN0YWNoZSh7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgaGFzaCxcbiAgICAgICAgdHJ1c3Rpbmc6ICFlc2NhcGVkLFxuICAgICAgICBsb2M6IHRoaXMuc291cmNlLnNwYW5Gb3IobG9jKSxcbiAgICAgICAgc3RyaXAsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuaXplci5zdGF0ZSkge1xuICAgICAgLy8gVGFnIGhlbHBlcnNcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUudGFnT3BlbjpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUudGFnTmFtZTpcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihgQ2Fubm90IHVzZSBtdXN0YWNoZXMgaW4gYW4gZWxlbWVudHMgdGFnbmFtZWAsIG11c3RhY2hlLmxvYyk7XG5cbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZTpcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVOYW1lOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hZnRlckF0dHJpYnV0ZU5hbWU6XG4gICAgICAgIHRoaXMuYmVnaW5BdHRyaWJ1dGVWYWx1ZShmYWxzZSk7XG4gICAgICAgIHRoaXMuZmluaXNoQXR0cmlidXRlVmFsdWUoKTtcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIHRva2VuaXplci50cmFuc2l0aW9uVG8oVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hZnRlckF0dHJpYnV0ZVZhbHVlUXVvdGVkOlxuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnRyYW5zaXRpb25UbyhUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIEF0dHJpYnV0ZSB2YWx1ZXNcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlVmFsdWU6XG4gICAgICAgIHRoaXMuYmVnaW5BdHRyaWJ1dGVWYWx1ZShmYWxzZSk7XG4gICAgICAgIHRoaXMuYXBwZW5kRHluYW1pY0F0dHJpYnV0ZVZhbHVlUGFydChtdXN0YWNoZSk7XG4gICAgICAgIHRva2VuaXplci50cmFuc2l0aW9uVG8oVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVVbnF1b3RlZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZURvdWJsZVF1b3RlZDpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVTaW5nbGVRdW90ZWQ6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlVW5xdW90ZWQ6XG4gICAgICAgIHRoaXMuYXBwZW5kRHluYW1pY0F0dHJpYnV0ZVZhbHVlUGFydChtdXN0YWNoZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBUT0RPOiBPbmx5IGFwcGVuZCBjaGlsZCB3aGVuIHRoZSB0b2tlbml6ZXIgc3RhdGUgbWFrZXNcbiAgICAgIC8vIHNlbnNlIHRvIGRvIHNvLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRFbGVtZW50KCksIG11c3RhY2hlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbXVzdGFjaGU7XG4gIH1cblxuICBhcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KHBhcnQ6IEFTVHYxLk11c3RhY2hlU3RhdGVtZW50KTogdm9pZCB7XG4gICAgdGhpcy5maW5hbGl6ZVRleHRQYXJ0KCk7XG4gICAgbGV0IGF0dHIgPSB0aGlzLmN1cnJlbnRBdHRyO1xuICAgIGF0dHIuaXNEeW5hbWljID0gdHJ1ZTtcbiAgICBhdHRyLnBhcnRzLnB1c2gocGFydCk7XG4gIH1cblxuICBmaW5hbGl6ZVRleHRQYXJ0KCk6IHZvaWQge1xuICAgIGxldCBhdHRyID0gdGhpcy5jdXJyZW50QXR0cjtcbiAgICBsZXQgdGV4dCA9IGF0dHIuY3VycmVudFBhcnQ7XG4gICAgaWYgKHRleHQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuY3VycmVudEF0dHIucGFydHMucHVzaCh0ZXh0KTtcbiAgICAgIHRoaXMuc3RhcnRUZXh0UGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXJ0VGV4dFBhcnQoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50QXR0ci5jdXJyZW50UGFydCA9IG51bGw7XG4gIH1cblxuICBDb250ZW50U3RhdGVtZW50KGNvbnRlbnQ6IEhCUy5Db250ZW50U3RhdGVtZW50KTogdm9pZCB7XG4gICAgdXBkYXRlVG9rZW5pemVyTG9jYXRpb24odGhpcy50b2tlbml6ZXIsIGNvbnRlbnQpO1xuXG4gICAgdGhpcy50b2tlbml6ZXIudG9rZW5pemVQYXJ0KGNvbnRlbnQudmFsdWUpO1xuICAgIHRoaXMudG9rZW5pemVyLmZsdXNoRGF0YSgpO1xuICB9XG5cbiAgQ29tbWVudFN0YXRlbWVudChyYXdDb21tZW50OiBIQlMuQ29tbWVudFN0YXRlbWVudCk6IE9wdGlvbjxBU1R2MS5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQ+IHtcbiAgICBsZXQgeyB0b2tlbml6ZXIgfSA9IHRoaXM7XG5cbiAgICBpZiAodG9rZW5pemVyLnN0YXRlID09PSBUb2tlbml6ZXJTdGF0ZS5jb21tZW50KSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKHJhd0NvbW1lbnQpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCB7IHZhbHVlLCBsb2MgfSA9IHJhd0NvbW1lbnQ7XG4gICAgbGV0IGNvbW1lbnQgPSBiLm11c3RhY2hlQ29tbWVudCh2YWx1ZSwgdGhpcy5zb3VyY2Uuc3BhbkZvcihsb2MpKTtcblxuICAgIHN3aXRjaCAodG9rZW5pemVyLnN0YXRlKSB7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWU6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmFmdGVyQXR0cmlidXRlTmFtZTpcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhcnRUYWcuY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlRGF0YTpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuZGF0YTpcbiAgICAgICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCBjb21tZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgYFVzaW5nIGEgSGFuZGxlYmFycyBjb21tZW50IHdoZW4gaW4gdGhlIFxcYCR7dG9rZW5pemVyWydzdGF0ZSddfVxcYCBzdGF0ZSBpcyBub3Qgc3VwcG9ydGVkYCxcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHJhd0NvbW1lbnQubG9jKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tZW50O1xuICB9XG5cbiAgUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsOiBIQlMuUGFydGlhbFN0YXRlbWVudCk6IG5ldmVyIHtcbiAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgcGFydGlhbHMgYXJlIG5vdCBzdXBwb3J0ZWRgLFxuICAgICAgdGhpcy5zb3VyY2Uuc3BhbkZvcihwYXJ0aWFsLmxvYylcbiAgICApO1xuICB9XG5cbiAgUGFydGlhbEJsb2NrU3RhdGVtZW50KHBhcnRpYWxCbG9jazogSEJTLlBhcnRpYWxCbG9ja1N0YXRlbWVudCk6IG5ldmVyIHtcbiAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgcGFydGlhbCBibG9ja3MgYXJlIG5vdCBzdXBwb3J0ZWRgLFxuICAgICAgdGhpcy5zb3VyY2Uuc3BhbkZvcihwYXJ0aWFsQmxvY2subG9jKVxuICAgICk7XG4gIH1cblxuICBEZWNvcmF0b3IoZGVjb3JhdG9yOiBIQlMuRGVjb3JhdG9yKTogbmV2ZXIge1xuICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBkZWNvcmF0b3JzIGFyZSBub3Qgc3VwcG9ydGVkYCxcbiAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IoZGVjb3JhdG9yLmxvYylcbiAgICApO1xuICB9XG5cbiAgRGVjb3JhdG9yQmxvY2soZGVjb3JhdG9yQmxvY2s6IEhCUy5EZWNvcmF0b3JCbG9jayk6IG5ldmVyIHtcbiAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgZGVjb3JhdG9yIGJsb2NrcyBhcmUgbm90IHN1cHBvcnRlZGAsXG4gICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKGRlY29yYXRvckJsb2NrLmxvYylcbiAgICApO1xuICB9XG5cbiAgU3ViRXhwcmVzc2lvbihzZXhwcjogSEJTLlN1YkV4cHJlc3Npb24pOiBBU1R2MS5TdWJFeHByZXNzaW9uIHtcbiAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2Rlcyh0aGlzLCBzZXhwcik7XG4gICAgcmV0dXJuIGIuc2V4cHIoeyBwYXRoLCBwYXJhbXMsIGhhc2gsIGxvYzogdGhpcy5zb3VyY2Uuc3BhbkZvcihzZXhwci5sb2MpIH0pO1xuICB9XG5cbiAgUGF0aEV4cHJlc3Npb24ocGF0aDogSEJTLlBhdGhFeHByZXNzaW9uKTogQVNUdjEuUGF0aEV4cHJlc3Npb24ge1xuICAgIGxldCB7IG9yaWdpbmFsIH0gPSBwYXRoO1xuICAgIGxldCBwYXJ0czogc3RyaW5nW107XG5cbiAgICBpZiAob3JpZ2luYWwuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgaWYgKG9yaWdpbmFsLnNsaWNlKDAsIDIpID09PSAnLi8nKSB7XG4gICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgYFVzaW5nIFwiLi9cIiBpcyBub3Qgc3VwcG9ydGVkIGluIEdsaW1tZXIgYW5kIHVubmVjZXNzYXJ5YCxcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhdGgubG9jKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLnNsaWNlKDAsIDMpID09PSAnLi4vJykge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBDaGFuZ2luZyBjb250ZXh0IHVzaW5nIFwiLi4vXCIgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyYCxcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhdGgubG9jKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgTWl4aW5nICcuJyBhbmQgJy8nIGluIHBhdGhzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2xpbW1lcjsgdXNlIG9ubHkgJy4nIHRvIHNlcGFyYXRlIHByb3BlcnR5IHBhdGhzYCxcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhdGgubG9jKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcGFydHMgPSBbcGF0aC5wYXJ0cy5qb2luKCcvJyldO1xuICAgIH0gZWxzZSBpZiAob3JpZ2luYWwgPT09ICcuJykge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYCcuJyBpcyBub3QgYSBzdXBwb3J0ZWQgcGF0aCBpbiBHbGltbWVyOyBjaGVjayBmb3IgYSBwYXRoIHdpdGggYSB0cmFpbGluZyAnLidgLFxuICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhdGgubG9jKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydHMgPSBwYXRoLnBhcnRzO1xuICAgIH1cblxuICAgIGxldCB0aGlzSGVhZCA9IGZhbHNlO1xuXG4gICAgLy8gVGhpcyBpcyB0byBmaXggYSBidWcgaW4gdGhlIEhhbmRsZWJhcnMgQVNUIHdoZXJlIHRoZSBwYXRoIGV4cHJlc3Npb25zIGluXG4gICAgLy8gYHt7dGhpcy5mb299fWAgKGFuZCBzaW1pbGFybHkgYHt7Zm9vLWJhciB0aGlzLmZvbyBuYW1lZD10aGlzLmZvb319YCBldGMpXG4gICAgLy8gYXJlIHNpbXBseSB0dXJuZWQgaW50byBge3tmb299fWAuIFRoZSBmaXggaXMgdG8gcHVzaCBpdCBiYWNrIG9udG8gdGhlXG4gICAgLy8gcGFydHMgYXJyYXkgYW5kIGxldCB0aGUgcnVudGltZSBzZWUgdGhlIGRpZmZlcmVuY2UuIEhvd2V2ZXIsIHdlIGNhbm5vdFxuICAgIC8vIHNpbXBseSB1c2UgdGhlIHN0cmluZyBgdGhpc2AgYXMgaXQgbWVhbnMgbGl0ZXJhbGx5IHRoZSBwcm9wZXJ0eSBjYWxsZWRcbiAgICAvLyBcInRoaXNcIiBpbiB0aGUgY3VycmVudCBjb250ZXh0IChpdCBjYW4gYmUgZXhwcmVzc2VkIGluIHRoZSBzeW50YXggYXNcbiAgICAvLyBge3tbdGhpc119fWAsIHdoZXJlIHRoZSBzcXVhcmUgYnJhY2tldCBhcmUgZ2VuZXJhbGx5IGZvciB0aGlzIGtpbmQgb2ZcbiAgICAvLyBlc2NhcGluZyDigJMgc3VjaCBhcyBge3tmb28uW1wiYmFyLmJhelwiXX19YCB3b3VsZCBtZWFuIGxvb2t1cCBhIHByb3BlcnR5XG4gICAgLy8gbmFtZWQgbGl0ZXJhbGx5IFwiYmFyLmJhelwiIG9uIGB0aGlzLmZvb2ApLiBCeSBjb252ZW50aW9uLCB3ZSB1c2UgYG51bGxgXG4gICAgLy8gZm9yIHRoaXMgcHVycG9zZS5cbiAgICBpZiAob3JpZ2luYWwubWF0Y2goL150aGlzKFxcLi4rKT8kLykpIHtcbiAgICAgIHRoaXNIZWFkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgcGF0aEhlYWQ6IEFTVHYxLlBhdGhIZWFkO1xuICAgIGlmICh0aGlzSGVhZCkge1xuICAgICAgcGF0aEhlYWQgPSB7XG4gICAgICAgIHR5cGU6ICdUaGlzSGVhZCcsXG4gICAgICAgIGxvYzoge1xuICAgICAgICAgIHN0YXJ0OiBwYXRoLmxvYy5zdGFydCxcbiAgICAgICAgICBlbmQ6IHsgbGluZTogcGF0aC5sb2Muc3RhcnQubGluZSwgY29sdW1uOiBwYXRoLmxvYy5zdGFydC5jb2x1bW4gKyA0IH0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocGF0aC5kYXRhKSB7XG4gICAgICBsZXQgaGVhZCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChoZWFkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHBhcnNlIGEgcGF0aCBleHByZXNzaW9uLCBidXQgaXQgd2FzIG5vdCB2YWxpZC4gUGF0aHMgYmVnaW5uaW5nIHdpdGggQCBtdXN0IHN0YXJ0IHdpdGggYS16LmAsXG4gICAgICAgICAgdGhpcy5zb3VyY2Uuc3BhbkZvcihwYXRoLmxvYylcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcGF0aEhlYWQgPSB7XG4gICAgICAgIHR5cGU6ICdBdEhlYWQnLFxuICAgICAgICBuYW1lOiBgQCR7aGVhZH1gLFxuICAgICAgICBsb2M6IHtcbiAgICAgICAgICBzdGFydDogcGF0aC5sb2Muc3RhcnQsXG4gICAgICAgICAgZW5kOiB7IGxpbmU6IHBhdGgubG9jLnN0YXJ0LmxpbmUsIGNvbHVtbjogcGF0aC5sb2Muc3RhcnQuY29sdW1uICsgaGVhZC5sZW5ndGggKyAxIH0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaGVhZCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChoZWFkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHBhcnNlIGEgcGF0aCBleHByZXNzaW9uLCBidXQgaXQgd2FzIG5vdCB2YWxpZC4gUGF0aHMgbXVzdCBzdGFydCB3aXRoIGEteiBvciBBLVouYCxcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhdGgubG9jKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBwYXRoSGVhZCA9IHtcbiAgICAgICAgdHlwZTogJ1ZhckhlYWQnLFxuICAgICAgICBuYW1lOiBoZWFkLFxuICAgICAgICBsb2M6IHtcbiAgICAgICAgICBzdGFydDogcGF0aC5sb2Muc3RhcnQsXG4gICAgICAgICAgZW5kOiB7IGxpbmU6IHBhdGgubG9jLnN0YXJ0LmxpbmUsIGNvbHVtbjogcGF0aC5sb2Muc3RhcnQuY29sdW1uICsgaGVhZC5sZW5ndGggfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQYXRoRXhwcmVzc2lvbkltcGxWMShwYXRoLm9yaWdpbmFsLCBwYXRoSGVhZCwgcGFydHMsIHRoaXMuc291cmNlLnNwYW5Gb3IocGF0aC5sb2MpKTtcbiAgfVxuXG4gIEhhc2goaGFzaDogSEJTLkhhc2gpOiBBU1R2MS5IYXNoIHtcbiAgICBsZXQgcGFpcnM6IEFTVHYxLkhhc2hQYWlyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFzaC5wYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhaXIgPSBoYXNoLnBhaXJzW2ldO1xuICAgICAgcGFpcnMucHVzaChcbiAgICAgICAgYi5wYWlyKHtcbiAgICAgICAgICBrZXk6IHBhaXIua2V5LFxuICAgICAgICAgIHZhbHVlOiB0aGlzLmFjY2VwdE5vZGUocGFpci52YWx1ZSksXG4gICAgICAgICAgbG9jOiB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhaXIubG9jKSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuaGFzaChwYWlycywgdGhpcy5zb3VyY2Uuc3BhbkZvcihoYXNoLmxvYykpO1xuICB9XG5cbiAgU3RyaW5nTGl0ZXJhbChzdHJpbmc6IEhCUy5TdHJpbmdMaXRlcmFsKTogQVNUdjEuU3RyaW5nTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCh7IHR5cGU6ICdTdHJpbmdMaXRlcmFsJywgdmFsdWU6IHN0cmluZy52YWx1ZSwgbG9jOiBzdHJpbmcubG9jIH0pO1xuICB9XG5cbiAgQm9vbGVhbkxpdGVyYWwoYm9vbGVhbjogSEJTLkJvb2xlYW5MaXRlcmFsKTogQVNUdjEuQm9vbGVhbkxpdGVyYWwge1xuICAgIHJldHVybiBiLmxpdGVyYWwoeyB0eXBlOiAnQm9vbGVhbkxpdGVyYWwnLCB2YWx1ZTogYm9vbGVhbi52YWx1ZSwgbG9jOiBib29sZWFuLmxvYyB9KTtcbiAgfVxuXG4gIE51bWJlckxpdGVyYWwobnVtYmVyOiBIQlMuTnVtYmVyTGl0ZXJhbCk6IEFTVHYxLk51bWJlckxpdGVyYWwge1xuICAgIHJldHVybiBiLmxpdGVyYWwoeyB0eXBlOiAnTnVtYmVyTGl0ZXJhbCcsIHZhbHVlOiBudW1iZXIudmFsdWUsIGxvYzogbnVtYmVyLmxvYyB9KTtcbiAgfVxuXG4gIFVuZGVmaW5lZExpdGVyYWwodW5kZWY6IEhCUy5VbmRlZmluZWRMaXRlcmFsKTogQVNUdjEuVW5kZWZpbmVkTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCh7IHR5cGU6ICdVbmRlZmluZWRMaXRlcmFsJywgdmFsdWU6IHVuZGVmaW5lZCwgbG9jOiB1bmRlZi5sb2MgfSk7XG4gIH1cblxuICBOdWxsTGl0ZXJhbChudWw6IEhCUy5OdWxsTGl0ZXJhbCk6IEFTVHYxLk51bGxMaXRlcmFsIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKHsgdHlwZTogJ051bGxMaXRlcmFsJywgdmFsdWU6IG51bGwsIGxvYzogbnVsLmxvYyB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVSaWdodFN0cmlwcGVkT2Zmc2V0cyhvcmlnaW5hbDogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAvLyBpZiBpdCBpcyBlbXB0eSwganVzdCByZXR1cm4gdGhlIGNvdW50IG9mIG5ld2xpbmVzXG4gICAgLy8gaW4gb3JpZ2luYWxcbiAgICByZXR1cm4ge1xuICAgICAgbGluZXM6IG9yaWdpbmFsLnNwbGl0KCdcXG4nKS5sZW5ndGggLSAxLFxuICAgICAgY29sdW1uczogMCxcbiAgICB9O1xuICB9XG5cbiAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBuZXdsaW5lcyBwcmlvciB0b1xuICAvLyBgdmFsdWVgXG4gIGxldCBkaWZmZXJlbmNlID0gb3JpZ2luYWwuc3BsaXQodmFsdWUpWzBdO1xuICBsZXQgbGluZXMgPSBkaWZmZXJlbmNlLnNwbGl0KC9cXG4vKTtcbiAgbGV0IGxpbmVDb3VudCA9IGxpbmVzLmxlbmd0aCAtIDE7XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lczogbGluZUNvdW50LFxuICAgIGNvbHVtbnM6IGxpbmVzW2xpbmVDb3VudF0ubGVuZ3RoLFxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUb2tlbml6ZXJMb2NhdGlvbih0b2tlbml6ZXI6IFBhcnNlclsndG9rZW5pemVyJ10sIGNvbnRlbnQ6IEhCUy5Db250ZW50U3RhdGVtZW50KSB7XG4gIGxldCBsaW5lID0gY29udGVudC5sb2Muc3RhcnQubGluZTtcbiAgbGV0IGNvbHVtbiA9IGNvbnRlbnQubG9jLnN0YXJ0LmNvbHVtbjtcblxuICBsZXQgb2Zmc2V0cyA9IGNhbGN1bGF0ZVJpZ2h0U3RyaXBwZWRPZmZzZXRzKFxuICAgIGNvbnRlbnQub3JpZ2luYWwgYXMgUmVjYXN0PEhCUy5TdHJpcEZsYWdzLCBzdHJpbmc+LFxuICAgIGNvbnRlbnQudmFsdWVcbiAgKTtcblxuICBsaW5lID0gbGluZSArIG9mZnNldHMubGluZXM7XG4gIGlmIChvZmZzZXRzLmxpbmVzKSB7XG4gICAgY29sdW1uID0gb2Zmc2V0cy5jb2x1bW5zO1xuICB9IGVsc2Uge1xuICAgIGNvbHVtbiA9IGNvbHVtbiArIG9mZnNldHMuY29sdW1ucztcbiAgfVxuXG4gIHRva2VuaXplci5saW5lID0gbGluZTtcbiAgdG9rZW5pemVyLmNvbHVtbiA9IGNvbHVtbjtcbn1cblxuZnVuY3Rpb24gYWNjZXB0Q2FsbE5vZGVzKFxuICBjb21waWxlcjogSGFuZGxlYmFyc05vZGVWaXNpdG9ycyxcbiAgbm9kZToge1xuICAgIHBhdGg6IEhCUy5QYXRoRXhwcmVzc2lvbiB8IEhCUy5TdWJFeHByZXNzaW9uO1xuICAgIHBhcmFtczogSEJTLkV4cHJlc3Npb25bXTtcbiAgICBoYXNoOiBIQlMuSGFzaDtcbiAgfVxuKToge1xuICBwYXRoOiBBU1R2MS5QYXRoRXhwcmVzc2lvbiB8IEFTVHYxLlN1YkV4cHJlc3Npb247XG4gIHBhcmFtczogQVNUdjEuRXhwcmVzc2lvbltdO1xuICBoYXNoOiBBU1R2MS5IYXNoO1xufSB7XG4gIGxldCBwYXRoID1cbiAgICBub2RlLnBhdGgudHlwZSA9PT0gJ1BhdGhFeHByZXNzaW9uJ1xuICAgICAgPyBjb21waWxlci5QYXRoRXhwcmVzc2lvbihub2RlLnBhdGgpXG4gICAgICA6IGNvbXBpbGVyLlN1YkV4cHJlc3Npb24obm9kZS5wYXRoKTtcbiAgbGV0IHBhcmFtcyA9IG5vZGUucGFyYW1zID8gbm9kZS5wYXJhbXMubWFwKChlKSA9PiBjb21waWxlci5hY2NlcHROb2RlPEFTVHYxLkV4cHJlc3Npb24+KGUpKSA6IFtdO1xuXG4gIC8vIGlmIHRoZXJlIGlzIG5vIGhhc2gsIHBvc2l0aW9uIGl0IGFzIGEgY29sbGFwc2VkIG5vZGUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGxhc3QgcGFyYW0gKG9yIHRoZVxuICAvLyBwYXRoLCBpZiB0aGVyZSBhcmUgYWxzbyBubyBwYXJhbXMpXG4gIGxldCBlbmQgPSBwYXJhbXMubGVuZ3RoID4gMCA/IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV0ubG9jIDogcGF0aC5sb2M7XG5cbiAgbGV0IGhhc2ggPSBub2RlLmhhc2hcbiAgICA/IGNvbXBpbGVyLkhhc2gobm9kZS5oYXNoKVxuICAgIDogKHtcbiAgICAgICAgdHlwZTogJ0hhc2gnLFxuICAgICAgICBwYWlyczogW10gYXMgQVNUdjEuSGFzaFBhaXJbXSxcbiAgICAgICAgbG9jOiBjb21waWxlci5zb3VyY2Uuc3BhbkZvcihlbmQpLmNvbGxhcHNlKCdlbmQnKSxcbiAgICAgIH0gYXMgY29uc3QpO1xuXG4gIHJldHVybiB7IHBhdGgsIHBhcmFtcywgaGFzaCB9O1xufVxuXG5mdW5jdGlvbiBhZGRFbGVtZW50TW9kaWZpZXIoXG4gIGVsZW1lbnQ6IFBhcnNlck5vZGVCdWlsZGVyPFRhZzwnU3RhcnRUYWcnPj4sXG4gIG11c3RhY2hlOiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudFxuKSB7XG4gIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCwgbG9jIH0gPSBtdXN0YWNoZTtcblxuICBpZiAoaXNIQlNMaXRlcmFsKHBhdGgpKSB7XG4gICAgbGV0IG1vZGlmaWVyID0gYHt7JHtwcmludExpdGVyYWwocGF0aCl9fX1gO1xuICAgIGxldCB0YWcgPSBgPCR7ZWxlbWVudC5uYW1lfSAuLi4gJHttb2RpZmllcn0gLi4uYDtcblxuICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoYEluICR7dGFnfSwgJHttb2RpZmllcn0gaXMgbm90IGEgdmFsaWQgbW9kaWZpZXJgLCBtdXN0YWNoZS5sb2MpO1xuICB9XG5cbiAgbGV0IG1vZGlmaWVyID0gYi5lbGVtZW50TW9kaWZpZXIoeyBwYXRoLCBwYXJhbXMsIGhhc2gsIGxvYyB9KTtcbiAgZWxlbWVudC5tb2RpZmllcnMucHVzaChtb2RpZmllcik7XG59XG4iLCJpbXBvcnQgeyBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2VydFByZXNlbnQsIGFzc2lnbiB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgcGFyc2UsIHBhcnNlV2l0aG91dFByb2Nlc3NpbmcgfSBmcm9tICdAaGFuZGxlYmFycy9wYXJzZXInO1xuaW1wb3J0IHsgRW50aXR5UGFyc2VyIH0gZnJvbSAnc2ltcGxlLWh0bWwtdG9rZW5pemVyJztcblxuaW1wb3J0IHByaW50IGZyb20gJy4uL2dlbmVyYXRpb24vcHJpbnQnO1xuaW1wb3J0IHsgdm9pZE1hcCB9IGZyb20gJy4uL2dlbmVyYXRpb24vcHJpbnRlcic7XG5pbXBvcnQgeyBUYWcgfSBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHsgU291cmNlIH0gZnJvbSAnLi4vc291cmNlL3NvdXJjZSc7XG5pbXBvcnQgeyBTb3VyY2VPZmZzZXQsIFNvdXJjZVNwYW4gfSBmcm9tICcuLi9zb3VyY2Uvc3Bhbic7XG5pbXBvcnQgeyBnZW5lcmF0ZVN5bnRheEVycm9yIH0gZnJvbSAnLi4vc3ludGF4LWVycm9yJztcbmltcG9ydCB0cmF2ZXJzZSBmcm9tICcuLi90cmF2ZXJzYWwvdHJhdmVyc2UnO1xuaW1wb3J0IHsgTm9kZVZpc2l0b3IgfSBmcm9tICcuLi90cmF2ZXJzYWwvdmlzaXRvcic7XG5pbXBvcnQgV2Fsa2VyIGZyb20gJy4uL3RyYXZlcnNhbC93YWxrZXInO1xuaW1wb3J0IHsgYXBwZW5kQ2hpbGQsIHBhcnNlRWxlbWVudEJsb2NrUGFyYW1zIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgQVNUdjEgZnJvbSAnLi4vdjEvYXBpJztcbmltcG9ydCAqIGFzIEhCUyBmcm9tICcuLi92MS9oYW5kbGViYXJzLWFzdCc7XG5pbXBvcnQgYiBmcm9tICcuLi92MS9wYXJzZXItYnVpbGRlcnMnO1xuaW1wb3J0IHB1YmxpY0J1aWxkZXIgZnJvbSAnLi4vdjEvcHVibGljLWJ1aWxkZXJzJztcbmltcG9ydCB7IEhhbmRsZWJhcnNOb2RlVmlzaXRvcnMgfSBmcm9tICcuL2hhbmRsZWJhcnMtbm9kZS12aXNpdG9ycyc7XG5cbmV4cG9ydCBjbGFzcyBUb2tlbml6ZXJFdmVudEhhbmRsZXJzIGV4dGVuZHMgSGFuZGxlYmFyc05vZGVWaXNpdG9ycyB7XG4gIHByaXZhdGUgdGFnT3BlbkxpbmUgPSAwO1xuICBwcml2YXRlIHRhZ09wZW5Db2x1bW4gPSAwO1xuXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBudWxsO1xuICB9XG5cbiAgLy8gQ29tbWVudFxuXG4gIGJlZ2luQ29tbWVudCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnROb2RlID0gYi5jb21tZW50KCcnLCB0aGlzLnNvdXJjZS5vZmZzZXRGb3IodGhpcy50YWdPcGVuTGluZSwgdGhpcy50YWdPcGVuQ29sdW1uKSk7XG4gIH1cblxuICBhcHBlbmRUb0NvbW1lbnREYXRhKGNoYXI6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudENvbW1lbnQudmFsdWUgKz0gY2hhcjtcbiAgfVxuXG4gIGZpbmlzaENvbW1lbnQoKTogdm9pZCB7XG4gICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCB0aGlzLmZpbmlzaCh0aGlzLmN1cnJlbnRDb21tZW50KSk7XG4gIH1cblxuICAvLyBEYXRhXG5cbiAgYmVnaW5EYXRhKCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBiLnRleHQoe1xuICAgICAgY2hhcnM6ICcnLFxuICAgICAgbG9jOiB0aGlzLm9mZnNldCgpLmNvbGxhcHNlZCgpLFxuICAgIH0pO1xuICB9XG5cbiAgYXBwZW5kVG9EYXRhKGNoYXI6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudERhdGEuY2hhcnMgKz0gY2hhcjtcbiAgfVxuXG4gIGZpbmlzaERhdGEoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50RGF0YS5sb2MgPSB0aGlzLmN1cnJlbnREYXRhLmxvYy53aXRoRW5kKHRoaXMub2Zmc2V0KCkpO1xuXG4gICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCB0aGlzLmN1cnJlbnREYXRhKTtcbiAgfVxuXG4gIC8vIFRhZ3MgLSBiYXNpY1xuXG4gIHRhZ09wZW4oKTogdm9pZCB7XG4gICAgdGhpcy50YWdPcGVuTGluZSA9IHRoaXMudG9rZW5pemVyLmxpbmU7XG4gICAgdGhpcy50YWdPcGVuQ29sdW1uID0gdGhpcy50b2tlbml6ZXIuY29sdW1uO1xuICB9XG5cbiAgYmVnaW5TdGFydFRhZygpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnROb2RlID0ge1xuICAgICAgdHlwZTogJ1N0YXJ0VGFnJyxcbiAgICAgIG5hbWU6ICcnLFxuICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICBtb2RpZmllcnM6IFtdLFxuICAgICAgY29tbWVudHM6IFtdLFxuICAgICAgc2VsZkNsb3Npbmc6IGZhbHNlLFxuICAgICAgbG9jOiB0aGlzLnNvdXJjZS5vZmZzZXRGb3IodGhpcy50YWdPcGVuTGluZSwgdGhpcy50YWdPcGVuQ29sdW1uKSxcbiAgICB9O1xuICB9XG5cbiAgYmVnaW5FbmRUYWcoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IHtcbiAgICAgIHR5cGU6ICdFbmRUYWcnLFxuICAgICAgbmFtZTogJycsXG4gICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgIG1vZGlmaWVyczogW10sXG4gICAgICBjb21tZW50czogW10sXG4gICAgICBzZWxmQ2xvc2luZzogZmFsc2UsXG4gICAgICBsb2M6IHRoaXMuc291cmNlLm9mZnNldEZvcih0aGlzLnRhZ09wZW5MaW5lLCB0aGlzLnRhZ09wZW5Db2x1bW4pLFxuICAgIH07XG4gIH1cblxuICBmaW5pc2hUYWcoKTogdm9pZCB7XG4gICAgbGV0IHRhZyA9IHRoaXMuZmluaXNoKHRoaXMuY3VycmVudFRhZyk7XG5cbiAgICBpZiAodGFnLnR5cGUgPT09ICdTdGFydFRhZycpIHtcbiAgICAgIHRoaXMuZmluaXNoU3RhcnRUYWcoKTtcblxuICAgICAgaWYgKHRhZy5uYW1lID09PSAnOicpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBuYW1lZCBibG9jayBuYW1lZCBkZXRlY3RlZCwgeW91IG1heSBoYXZlIGNyZWF0ZWQgYSBuYW1lZCBibG9jayB3aXRob3V0IGEgbmFtZSwgb3IgeW91IG1heSBoYXZlIGJlZ2FuIHlvdXIgbmFtZSB3aXRoIGEgbnVtYmVyLiBOYW1lZCBibG9ja3MgbXVzdCBoYXZlIG5hbWVzIHRoYXQgYXJlIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgbG9uZywgYW5kIGJlZ2luIHdpdGggYSBsb3dlciBjYXNlIGxldHRlcicsXG4gICAgICAgICAgdGhpcy5zb3VyY2Uuc3BhbkZvcih7XG4gICAgICAgICAgICBzdGFydDogdGhpcy5jdXJyZW50VGFnLmxvYy50b0pTT04oKSxcbiAgICAgICAgICAgIGVuZDogdGhpcy5vZmZzZXQoKS50b0pTT04oKSxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodm9pZE1hcFt0YWcubmFtZV0gfHwgdGFnLnNlbGZDbG9zaW5nKSB7XG4gICAgICAgIHRoaXMuZmluaXNoRW5kVGFnKHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGFnLnR5cGUgPT09ICdFbmRUYWcnKSB7XG4gICAgICB0aGlzLmZpbmlzaEVuZFRhZyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZmluaXNoU3RhcnRUYWcoKTogdm9pZCB7XG4gICAgbGV0IHsgbmFtZSwgYXR0cmlidXRlczogYXR0cnMsIG1vZGlmaWVycywgY29tbWVudHMsIHNlbGZDbG9zaW5nLCBsb2MgfSA9IHRoaXMuZmluaXNoKFxuICAgICAgdGhpcy5jdXJyZW50U3RhcnRUYWdcbiAgICApO1xuXG4gICAgbGV0IGVsZW1lbnQgPSBiLmVsZW1lbnQoe1xuICAgICAgdGFnOiBuYW1lLFxuICAgICAgc2VsZkNsb3NpbmcsXG4gICAgICBhdHRycyxcbiAgICAgIG1vZGlmaWVycyxcbiAgICAgIGNvbW1lbnRzLFxuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgYmxvY2tQYXJhbXM6IFtdLFxuICAgICAgbG9jLFxuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudFN0YWNrLnB1c2goZWxlbWVudCk7XG4gIH1cblxuICBmaW5pc2hFbmRUYWcoaXNWb2lkOiBib29sZWFuKTogdm9pZCB7XG4gICAgbGV0IHRhZyA9IHRoaXMuZmluaXNoKHRoaXMuY3VycmVudFRhZyk7XG5cbiAgICBsZXQgZWxlbWVudCA9IHRoaXMuZWxlbWVudFN0YWNrLnBvcCgpIGFzIEFTVHYxLkVsZW1lbnROb2RlO1xuICAgIGxldCBwYXJlbnQgPSB0aGlzLmN1cnJlbnRFbGVtZW50KCk7XG5cbiAgICB0aGlzLnZhbGlkYXRlRW5kVGFnKHRhZywgZWxlbWVudCwgaXNWb2lkKTtcblxuICAgIGVsZW1lbnQubG9jID0gZWxlbWVudC5sb2Mud2l0aEVuZCh0aGlzLm9mZnNldCgpKTtcbiAgICBwYXJzZUVsZW1lbnRCbG9ja1BhcmFtcyhlbGVtZW50KTtcbiAgICBhcHBlbmRDaGlsZChwYXJlbnQsIGVsZW1lbnQpO1xuICB9XG5cbiAgbWFya1RhZ0FzU2VsZkNsb3NpbmcoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50VGFnLnNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRhZ3MgLSBuYW1lXG5cbiAgYXBwZW5kVG9UYWdOYW1lKGNoYXI6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFRhZy5uYW1lICs9IGNoYXI7XG4gIH1cblxuICAvLyBUYWdzIC0gYXR0cmlidXRlc1xuXG4gIGJlZ2luQXR0cmlidXRlKCk6IHZvaWQge1xuICAgIGxldCBvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG4gICAgdGhpcy5jdXJyZW50QXR0cmlidXRlID0ge1xuICAgICAgbmFtZTogJycsXG4gICAgICBwYXJ0czogW10sXG4gICAgICBjdXJyZW50UGFydDogbnVsbCxcbiAgICAgIGlzUXVvdGVkOiBmYWxzZSxcbiAgICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgICBzdGFydDogb2Zmc2V0LFxuICAgICAgdmFsdWVTcGFuOiBvZmZzZXQuY29sbGFwc2VkKCksXG4gICAgfTtcbiAgfVxuXG4gIGFwcGVuZFRvQXR0cmlidXRlTmFtZShjaGFyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRBdHRyLm5hbWUgKz0gY2hhcjtcbiAgfVxuXG4gIGJlZ2luQXR0cmlidXRlVmFsdWUoaXNRdW90ZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRBdHRyLmlzUXVvdGVkID0gaXNRdW90ZWQ7XG4gICAgdGhpcy5zdGFydFRleHRQYXJ0KCk7XG4gICAgdGhpcy5jdXJyZW50QXR0ci52YWx1ZVNwYW4gPSB0aGlzLm9mZnNldCgpLmNvbGxhcHNlZCgpO1xuICB9XG5cbiAgYXBwZW5kVG9BdHRyaWJ1dGVWYWx1ZShjaGFyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBsZXQgcGFydHMgPSB0aGlzLmN1cnJlbnRBdHRyLnBhcnRzO1xuICAgIGxldCBsYXN0UGFydCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnRBdHRyLmN1cnJlbnRQYXJ0O1xuXG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGN1cnJlbnQuY2hhcnMgKz0gY2hhcjtcblxuICAgICAgLy8gdXBkYXRlIGVuZCBsb2NhdGlvbiBmb3IgZWFjaCBhZGRlZCBjaGFyXG4gICAgICBjdXJyZW50LmxvYyA9IGN1cnJlbnQubG9jLndpdGhFbmQodGhpcy5vZmZzZXQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluaXRpYWxseSBhc3N1bWUgdGhlIHRleHQgbm9kZSBpcyBhIHNpbmdsZSBjaGFyXG4gICAgICBsZXQgbG9jOiBTb3VyY2VPZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG4gICAgICAvLyB0aGUgdG9rZW5pemVyIGxpbmUvY29sdW1uIGhhdmUgYWxyZWFkeSBiZWVuIGFkdmFuY2VkLCBjb3JyZWN0IGxvY2F0aW9uIGluZm9cbiAgICAgIGlmIChjaGFyID09PSAnXFxuJykge1xuICAgICAgICBsb2MgPSBsYXN0UGFydCA/IGxhc3RQYXJ0LmxvYy5nZXRFbmQoKSA6IHRoaXMuY3VycmVudEF0dHIudmFsdWVTcGFuLmdldFN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2MgPSBsb2MubW92ZSgtMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudEF0dHIuY3VycmVudFBhcnQgPSBiLnRleHQoeyBjaGFyczogY2hhciwgbG9jOiBsb2MuY29sbGFwc2VkKCkgfSk7XG4gICAgfVxuICB9XG5cbiAgZmluaXNoQXR0cmlidXRlVmFsdWUoKTogdm9pZCB7XG4gICAgdGhpcy5maW5hbGl6ZVRleHRQYXJ0KCk7XG5cbiAgICBsZXQgdGFnID0gdGhpcy5jdXJyZW50VGFnO1xuICAgIGxldCB0b2tlbml6ZXJQb3MgPSB0aGlzLm9mZnNldCgpO1xuXG4gICAgaWYgKHRhZy50eXBlID09PSAnRW5kVGFnJykge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYEludmFsaWQgZW5kIHRhZzogY2xvc2luZyB0YWcgbXVzdCBub3QgaGF2ZSBhdHRyaWJ1dGVzYCxcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3BhbkZvcih7IHN0YXJ0OiB0YWcubG9jLnRvSlNPTigpLCBlbmQ6IHRva2VuaXplclBvcy50b0pTT04oKSB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgeyBuYW1lLCBwYXJ0cywgc3RhcnQsIGlzUXVvdGVkLCBpc0R5bmFtaWMsIHZhbHVlU3BhbiB9ID0gdGhpcy5jdXJyZW50QXR0cjtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmFzc2VtYmxlQXR0cmlidXRlVmFsdWUocGFydHMsIGlzUXVvdGVkLCBpc0R5bmFtaWMsIHN0YXJ0LnVudGlsKHRva2VuaXplclBvcykpO1xuICAgIHZhbHVlLmxvYyA9IHZhbHVlU3Bhbi53aXRoRW5kKHRva2VuaXplclBvcyk7XG5cbiAgICBsZXQgYXR0cmlidXRlID0gYi5hdHRyKHsgbmFtZSwgdmFsdWUsIGxvYzogc3RhcnQudW50aWwodG9rZW5pemVyUG9zKSB9KTtcblxuICAgIHRoaXMuY3VycmVudFN0YXJ0VGFnLmF0dHJpYnV0ZXMucHVzaChhdHRyaWJ1dGUpO1xuICB9XG5cbiAgcmVwb3J0U3ludGF4RXJyb3IobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihtZXNzYWdlLCB0aGlzLm9mZnNldCgpLmNvbGxhcHNlZCgpKTtcbiAgfVxuXG4gIGFzc2VtYmxlQ29uY2F0ZW5hdGVkVmFsdWUoXG4gICAgcGFydHM6IChBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCB8IEFTVHYxLlRleHROb2RlKVtdXG4gICk6IEFTVHYxLkNvbmNhdFN0YXRlbWVudCB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhcnQ6IEFTVHYxLkJhc2VOb2RlID0gcGFydHNbaV07XG5cbiAgICAgIGlmIChwYXJ0LnR5cGUgIT09ICdNdXN0YWNoZVN0YXRlbWVudCcgJiYgcGFydC50eXBlICE9PSAnVGV4dE5vZGUnKSB7XG4gICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgJ1Vuc3VwcG9ydGVkIG5vZGUgaW4gcXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZTogJyArIHBhcnRbJ3R5cGUnXSxcbiAgICAgICAgICBwYXJ0LmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzc2VydFByZXNlbnQocGFydHMsIGB0aGUgY29uY2F0ZW5hdGlvbiBwYXJ0cyBvZiBhbiBlbGVtZW50IHNob3VsZCBub3QgYmUgZW1wdHlgKTtcblxuICAgIGxldCBmaXJzdCA9IHBhcnRzWzBdO1xuICAgIGxldCBsYXN0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG5cbiAgICByZXR1cm4gYi5jb25jYXQocGFydHMsIHRoaXMuc291cmNlLnNwYW5Gb3IoZmlyc3QubG9jKS5leHRlbmQodGhpcy5zb3VyY2Uuc3BhbkZvcihsYXN0LmxvYykpKTtcbiAgfVxuXG4gIHZhbGlkYXRlRW5kVGFnKFxuICAgIHRhZzogVGFnPCdTdGFydFRhZycgfCAnRW5kVGFnJz4sXG4gICAgZWxlbWVudDogQVNUdjEuRWxlbWVudE5vZGUsXG4gICAgc2VsZkNsb3Npbmc6IGJvb2xlYW5cbiAgKTogdm9pZCB7XG4gICAgbGV0IGVycm9yO1xuXG4gICAgaWYgKHZvaWRNYXBbdGFnLm5hbWVdICYmICFzZWxmQ2xvc2luZykge1xuICAgICAgLy8gRW5nVGFnIGlzIGFsc28gY2FsbGVkIGJ5IFN0YXJ0VGFnIGZvciB2b2lkIGFuZCBzZWxmLWNsb3NpbmcgdGFncyAoaS5lLlxuICAgICAgLy8gPGlucHV0PiBvciA8YnIgLz4sIHNvIHdlIG5lZWQgdG8gY2hlY2sgZm9yIHRoYXQgaGVyZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZFxuICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgZm9yIHRob3NlIGNhc2VzLlxuICAgICAgZXJyb3IgPSBgPCR7dGFnLm5hbWV9PiBlbGVtZW50cyBkbyBub3QgbmVlZCBlbmQgdGFncy4gWW91IHNob3VsZCByZW1vdmUgaXRgO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50YWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBgQ2xvc2luZyB0YWcgPC8ke3RhZy5uYW1lfT4gd2l0aG91dCBhbiBvcGVuIHRhZ2A7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LnRhZyAhPT0gdGFnLm5hbWUpIHtcbiAgICAgIGVycm9yID0gYENsb3NpbmcgdGFnIDwvJHt0YWcubmFtZX0+IGRpZCBub3QgbWF0Y2ggbGFzdCBvcGVuIHRhZyA8JHtlbGVtZW50LnRhZ30+IChvbiBsaW5lICR7ZWxlbWVudC5sb2Muc3RhcnRQb3NpdGlvbi5saW5lfSlgO1xuICAgIH1cblxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihlcnJvciwgdGFnLmxvYyk7XG4gICAgfVxuICB9XG5cbiAgYXNzZW1ibGVBdHRyaWJ1dGVWYWx1ZShcbiAgICBwYXJ0czogKEFTVHYxLk11c3RhY2hlU3RhdGVtZW50IHwgQVNUdjEuVGV4dE5vZGUpW10sXG4gICAgaXNRdW90ZWQ6IGJvb2xlYW4sXG4gICAgaXNEeW5hbWljOiBib29sZWFuLFxuICAgIHNwYW46IFNvdXJjZVNwYW5cbiAgKTogQVNUdjEuQ29uY2F0U3RhdGVtZW50IHwgQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1R2MS5UZXh0Tm9kZSB7XG4gICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgaWYgKGlzUXVvdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2VtYmxlQ29uY2F0ZW5hdGVkVmFsdWUocGFydHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBhcnRzLmxlbmd0aCA9PT0gMSB8fFxuICAgICAgICAgIChwYXJ0cy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIHBhcnRzWzFdLnR5cGUgPT09ICdUZXh0Tm9kZScgJiZcbiAgICAgICAgICAgIChwYXJ0c1sxXSBhcyBBU1R2MS5UZXh0Tm9kZSkuY2hhcnMgPT09ICcvJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgICBgQW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBtdXN0YWNoZSwgYCArXG4gICAgICAgICAgICAgIGBwcmVjZWRlZCBieSB3aGl0ZXNwYWNlIG9yIGEgJz0nIGNoYXJhY3RlciwgYW5kIGAgK1xuICAgICAgICAgICAgICBgZm9sbG93ZWQgYnkgd2hpdGVzcGFjZSwgYSAnPicgY2hhcmFjdGVyLCBvciAnLz4nYCxcbiAgICAgICAgICAgIHNwYW5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiBiLnRleHQoeyBjaGFyczogJycsIGxvYzogc3BhbiB9KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gIEFTVFBsdWdpbnMgY2FuIG1ha2UgY2hhbmdlcyB0byB0aGUgR2xpbW1lciB0ZW1wbGF0ZSBBU1QgYmVmb3JlXG4gIGNvbXBpbGF0aW9uIGJlZ2lucy5cbiovXG5leHBvcnQgaW50ZXJmYWNlIEFTVFBsdWdpbkJ1aWxkZXI8VEVudiBleHRlbmRzIEFTVFBsdWdpbkVudmlyb25tZW50ID0gQVNUUGx1Z2luRW52aXJvbm1lbnQ+IHtcbiAgKGVudjogVEVudik6IEFTVFBsdWdpbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBU1RQbHVnaW4ge1xuICBuYW1lOiBzdHJpbmc7XG4gIHZpc2l0b3I6IE5vZGVWaXNpdG9yO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFTVFBsdWdpbkVudmlyb25tZW50IHtcbiAgbWV0YT86IG9iamVjdDtcbiAgc3ludGF4OiBTeW50YXg7XG59XG5cbmludGVyZmFjZSBIYW5kbGViYXJzUGFyc2VPcHRpb25zIHtcbiAgc3JjTmFtZT86IHN0cmluZztcbiAgaWdub3JlU3RhbmRhbG9uZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVtcGxhdGVJZEZuIHtcbiAgKHNyYzogc3RyaW5nKTogT3B0aW9uPHN0cmluZz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlY29tcGlsZU9wdGlvbnMgZXh0ZW5kcyBQcmVwcm9jZXNzT3B0aW9ucyB7XG4gIGlkPzogVGVtcGxhdGVJZEZuO1xuICBjdXN0b21pemVDb21wb25lbnROYW1lPyhpbnB1dDogc3RyaW5nKTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByZXByb2Nlc3NPcHRpb25zIHtcbiAgc3RyaWN0TW9kZT86IGJvb2xlYW47XG4gIGxvY2Fscz86IHN0cmluZ1tdO1xuICBtZXRhPzoge1xuICAgIG1vZHVsZU5hbWU/OiBzdHJpbmc7XG4gIH07XG4gIHBsdWdpbnM/OiB7XG4gICAgYXN0PzogQVNUUGx1Z2luQnVpbGRlcltdO1xuICB9O1xuICBwYXJzZU9wdGlvbnM/OiBIYW5kbGViYXJzUGFyc2VPcHRpb25zO1xuICBjdXN0b21pemVDb21wb25lbnROYW1lPyhpbnB1dDogc3RyaW5nKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgIFVzZWZ1bCBmb3Igc3BlY2lmeWluZyBhIGdyb3VwIG9mIG9wdGlvbnMgdG9nZXRoZXIuXG5cbiAgICBXaGVuIGAnY29kZW1vZCdgIHdlIGRpc2FibGUgYWxsIHdoaXRlc3BhY2UgY29udHJvbCBpbiBoYW5kbGViYXJzXG4gICAgKHRvIHByZXNlcnZlIGFzIG11Y2ggYXMgcG9zc2libGUpIGFuZCB3ZSBhbHNvIGF2b2lkIGFueVxuICAgIGVzY2FwaW5nL3VuZXNjYXBpbmcgb2YgSFRNTCBlbnRpdHkgY29kZXMuXG4gICAqL1xuICBtb2RlPzogJ2NvZGVtb2QnIHwgJ3ByZWNvbXBpbGUnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN5bnRheCB7XG4gIHBhcnNlOiB0eXBlb2YgcHJlcHJvY2VzcztcbiAgYnVpbGRlcnM6IHR5cGVvZiBwdWJsaWNCdWlsZGVyO1xuICBwcmludDogdHlwZW9mIHByaW50O1xuICB0cmF2ZXJzZTogdHlwZW9mIHRyYXZlcnNlO1xuICBXYWxrZXI6IHR5cGVvZiBXYWxrZXI7XG59XG5cbmNvbnN0IHN5bnRheDogU3ludGF4ID0ge1xuICBwYXJzZTogcHJlcHJvY2VzcyxcbiAgYnVpbGRlcnM6IHB1YmxpY0J1aWxkZXIsXG4gIHByaW50LFxuICB0cmF2ZXJzZSxcbiAgV2Fsa2VyLFxufTtcblxuY2xhc3MgQ29kZW1vZEVudGl0eVBhcnNlciBleHRlbmRzIEVudGl0eVBhcnNlciB7XG4gIC8vIG1hdGNoIHVwc3RyZWFtIHR5cGVzLCBidXQgbmV2ZXIgbWF0Y2ggYW4gZW50aXR5XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHt9KTtcbiAgfVxuXG4gIHBhcnNlKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlcHJvY2VzcyhcbiAgaW5wdXQ6IHN0cmluZyB8IFNvdXJjZSB8IEhCUy5Qcm9ncmFtLFxuICBvcHRpb25zOiBQcmVwcm9jZXNzT3B0aW9ucyA9IHt9XG4pOiBBU1R2MS5UZW1wbGF0ZSB7XG4gIGxldCBtb2RlID0gb3B0aW9ucy5tb2RlIHx8ICdwcmVjb21waWxlJztcblxuICBsZXQgc291cmNlOiBTb3VyY2U7XG4gIGxldCBhc3Q6IEhCUy5Qcm9ncmFtO1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZSA9IG5ldyBTb3VyY2UoaW5wdXQsIG9wdGlvbnMubWV0YT8ubW9kdWxlTmFtZSk7XG5cbiAgICBpZiAobW9kZSA9PT0gJ2NvZGVtb2QnKSB7XG4gICAgICBhc3QgPSBwYXJzZVdpdGhvdXRQcm9jZXNzaW5nKGlucHV0LCBvcHRpb25zLnBhcnNlT3B0aW9ucykgYXMgSEJTLlByb2dyYW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzdCA9IHBhcnNlKGlucHV0LCBvcHRpb25zLnBhcnNlT3B0aW9ucykgYXMgSEJTLlByb2dyYW07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgU291cmNlKSB7XG4gICAgc291cmNlID0gaW5wdXQ7XG5cbiAgICBpZiAobW9kZSA9PT0gJ2NvZGVtb2QnKSB7XG4gICAgICBhc3QgPSBwYXJzZVdpdGhvdXRQcm9jZXNzaW5nKGlucHV0LnNvdXJjZSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpIGFzIEhCUy5Qcm9ncmFtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3QgPSBwYXJzZShpbnB1dC5zb3VyY2UsIG9wdGlvbnMucGFyc2VPcHRpb25zKSBhcyBIQlMuUHJvZ3JhbTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc291cmNlID0gbmV3IFNvdXJjZSgnJywgb3B0aW9ucy5tZXRhPy5tb2R1bGVOYW1lKTtcbiAgICBhc3QgPSBpbnB1dDtcbiAgfVxuXG4gIGxldCBlbnRpdHlQYXJzZXIgPSB1bmRlZmluZWQ7XG4gIGlmIChtb2RlID09PSAnY29kZW1vZCcpIHtcbiAgICBlbnRpdHlQYXJzZXIgPSBuZXcgQ29kZW1vZEVudGl0eVBhcnNlcigpO1xuICB9XG5cbiAgbGV0IG9mZnNldHMgPSBTb3VyY2VTcGFuLmZvckNoYXJQb3NpdGlvbnMoc291cmNlLCAwLCBzb3VyY2Uuc291cmNlLmxlbmd0aCk7XG4gIGFzdC5sb2MgPSB7XG4gICAgc291cmNlOiAnKHByb2dyYW0pJyxcbiAgICBzdGFydDogb2Zmc2V0cy5zdGFydFBvc2l0aW9uLFxuICAgIGVuZDogb2Zmc2V0cy5lbmRQb3NpdGlvbixcbiAgfTtcblxuICBsZXQgcHJvZ3JhbSA9IG5ldyBUb2tlbml6ZXJFdmVudEhhbmRsZXJzKHNvdXJjZSwgZW50aXR5UGFyc2VyLCBtb2RlKS5hY2NlcHRUZW1wbGF0ZShhc3QpO1xuXG4gIGlmIChvcHRpb25zLnN0cmljdE1vZGUpIHtcbiAgICBwcm9ncmFtLmJsb2NrUGFyYW1zID0gb3B0aW9ucy5sb2NhbHMgPz8gW107XG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBsdWdpbnMgJiYgb3B0aW9ucy5wbHVnaW5zLmFzdCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gb3B0aW9ucy5wbHVnaW5zLmFzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxldCB0cmFuc2Zvcm0gPSBvcHRpb25zLnBsdWdpbnMuYXN0W2ldO1xuICAgICAgbGV0IGVudjogQVNUUGx1Z2luRW52aXJvbm1lbnQgPSBhc3NpZ24oe30sIG9wdGlvbnMsIHsgc3ludGF4IH0sIHsgcGx1Z2luczogdW5kZWZpbmVkIH0pO1xuXG4gICAgICBsZXQgcGx1Z2luUmVzdWx0ID0gdHJhbnNmb3JtKGVudik7XG5cbiAgICAgIHRyYXZlcnNlKHByb2dyYW0sIHBsdWdpblJlc3VsdC52aXNpdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvZ3JhbTtcbn1cbiIsImltcG9ydCB7IENvcmUsIERpY3QsIFNleHBPcGNvZGVzIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBkaWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmltcG9ydCB7IEFTVHYyIH0gZnJvbSAnLi4nO1xuaW1wb3J0IHsgaXNVcHBlckNhc2UgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN5bWJvbFRhYmxlIHtcbiAgc3RhdGljIHRvcChcbiAgICBsb2NhbHM6IHN0cmluZ1tdLFxuICAgIGN1c3RvbWl6ZUNvbXBvbmVudE5hbWU6IChpbnB1dDogc3RyaW5nKSA9PiBzdHJpbmdcbiAgKTogUHJvZ3JhbVN5bWJvbFRhYmxlIHtcbiAgICByZXR1cm4gbmV3IFByb2dyYW1TeW1ib2xUYWJsZShsb2NhbHMsIGN1c3RvbWl6ZUNvbXBvbmVudE5hbWUpO1xuICB9XG5cbiAgYWJzdHJhY3QgaGFzKG5hbWU6IHN0cmluZyk6IGJvb2xlYW47XG4gIGFic3RyYWN0IGdldChuYW1lOiBzdHJpbmcpOiBbc3ltYm9sOiBudW1iZXIsIGlzUm9vdDogYm9vbGVhbl07XG5cbiAgYWJzdHJhY3QgZ2V0TG9jYWxzTWFwKCk6IERpY3Q8bnVtYmVyPjtcbiAgYWJzdHJhY3QgZ2V0RXZhbEluZm8oKTogQ29yZS5FdmFsSW5mbztcblxuICBhYnN0cmFjdCBhbGxvY2F0ZUZyZWUobmFtZTogc3RyaW5nLCByZXNvbHV0aW9uOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbik6IG51bWJlcjtcbiAgYWJzdHJhY3QgYWxsb2NhdGVOYW1lZChuYW1lOiBzdHJpbmcpOiBudW1iZXI7XG4gIGFic3RyYWN0IGFsbG9jYXRlQmxvY2sobmFtZTogc3RyaW5nKTogbnVtYmVyO1xuICBhYnN0cmFjdCBhbGxvY2F0ZShpZGVudGlmaWVyOiBzdHJpbmcpOiBudW1iZXI7XG5cbiAgYWJzdHJhY3Qgc2V0SGFzRXZhbCgpOiB2b2lkO1xuXG4gIGNoaWxkKGxvY2Fsczogc3RyaW5nW10pOiBCbG9ja1N5bWJvbFRhYmxlIHtcbiAgICBsZXQgc3ltYm9scyA9IGxvY2Fscy5tYXAoKG5hbWUpID0+IHRoaXMuYWxsb2NhdGUobmFtZSkpO1xuICAgIHJldHVybiBuZXcgQmxvY2tTeW1ib2xUYWJsZSh0aGlzLCBsb2NhbHMsIHN5bWJvbHMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9ncmFtU3ltYm9sVGFibGUgZXh0ZW5kcyBTeW1ib2xUYWJsZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdGVtcGxhdGVMb2NhbHM6IHN0cmluZ1tdLFxuICAgIHByaXZhdGUgY3VzdG9taXplQ29tcG9uZW50TmFtZTogKGlucHV0OiBzdHJpbmcpID0+IHN0cmluZ1xuICApIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgcHVibGljIHN5bWJvbHM6IHN0cmluZ1tdID0gW107XG4gIHB1YmxpYyB1cHZhcnM6IHN0cmluZ1tdID0gW107XG5cbiAgcHJpdmF0ZSBzaXplID0gMTtcbiAgcHJpdmF0ZSBuYW1lZCA9IGRpY3Q8bnVtYmVyPigpO1xuICBwcml2YXRlIGJsb2NrcyA9IGRpY3Q8bnVtYmVyPigpO1xuICBwcml2YXRlIHVzZWRUZW1wbGF0ZUxvY2Fsczogc3RyaW5nW10gPSBbXTtcblxuICAjaGFzRXZhbCA9IGZhbHNlO1xuXG4gIGdldFVzZWRUZW1wbGF0ZUxvY2FscygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMudXNlZFRlbXBsYXRlTG9jYWxzO1xuICB9XG5cbiAgc2V0SGFzRXZhbCgpOiB2b2lkIHtcbiAgICB0aGlzLiNoYXNFdmFsID0gdHJ1ZTtcbiAgfVxuXG4gIGdldCBoYXNFdmFsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLiNoYXNFdmFsO1xuICB9XG5cbiAgaGFzKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnRlbXBsYXRlTG9jYWxzLmluZGV4T2YobmFtZSkgIT09IC0xO1xuICB9XG5cbiAgZ2V0KG5hbWU6IHN0cmluZyk6IFtudW1iZXIsIGJvb2xlYW5dIHtcbiAgICBsZXQgaW5kZXggPSB0aGlzLnVzZWRUZW1wbGF0ZUxvY2Fscy5pbmRleE9mKG5hbWUpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgcmV0dXJuIFtpbmRleCwgdHJ1ZV07XG4gICAgfVxuXG4gICAgaW5kZXggPSB0aGlzLnVzZWRUZW1wbGF0ZUxvY2Fscy5sZW5ndGg7XG4gICAgdGhpcy51c2VkVGVtcGxhdGVMb2NhbHMucHVzaChuYW1lKTtcbiAgICByZXR1cm4gW2luZGV4LCB0cnVlXTtcbiAgfVxuXG4gIGdldExvY2Fsc01hcCgpOiBEaWN0PG51bWJlcj4ge1xuICAgIHJldHVybiBkaWN0KCk7XG4gIH1cblxuICBnZXRFdmFsSW5mbygpOiBDb3JlLkV2YWxJbmZvIHtcbiAgICBsZXQgbG9jYWxzID0gdGhpcy5nZXRMb2NhbHNNYXAoKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobG9jYWxzKS5tYXAoKHN5bWJvbCkgPT4gbG9jYWxzW3N5bWJvbF0pO1xuICB9XG5cbiAgYWxsb2NhdGVGcmVlKG5hbWU6IHN0cmluZywgcmVzb2x1dGlvbjogQVNUdjIuRnJlZVZhclJlc29sdXRpb24pOiBudW1iZXIge1xuICAgIC8vIElmIHRoZSBuYW1lIGluIHF1ZXN0aW9uIGlzIGFuIHVwcGVyY2FzZSAoaS5lLiBhbmdsZS1icmFja2V0KSBjb21wb25lbnQgaW52b2NhdGlvbiwgcnVuXG4gICAgLy8gdGhlIG9wdGlvbmFsIGBjdXN0b21pemVDb21wb25lbnROYW1lYCBmdW5jdGlvbiBwcm92aWRlZCB0byB0aGUgcHJlY29tcGlsZXIuXG4gICAgaWYgKFxuICAgICAgcmVzb2x1dGlvbi5yZXNvbHV0aW9uKCkgPT09IFNleHBPcGNvZGVzLkdldEZyZWVBc0NvbXBvbmVudEhlYWQgJiZcbiAgICAgIHJlc29sdXRpb24uaXNBbmdsZUJyYWNrZXQgJiZcbiAgICAgIGlzVXBwZXJDYXNlKG5hbWUpXG4gICAgKSB7XG4gICAgICBuYW1lID0gdGhpcy5jdXN0b21pemVDb21wb25lbnROYW1lKG5hbWUpO1xuICAgIH1cblxuICAgIGxldCBpbmRleCA9IHRoaXMudXB2YXJzLmluZGV4T2YobmFtZSk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgaW5kZXggPSB0aGlzLnVwdmFycy5sZW5ndGg7XG4gICAgdGhpcy51cHZhcnMucHVzaChuYW1lKTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBhbGxvY2F0ZU5hbWVkKG5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgbGV0IG5hbWVkID0gdGhpcy5uYW1lZFtuYW1lXTtcblxuICAgIGlmICghbmFtZWQpIHtcbiAgICAgIG5hbWVkID0gdGhpcy5uYW1lZFtuYW1lXSA9IHRoaXMuYWxsb2NhdGUobmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWVkO1xuICB9XG5cbiAgYWxsb2NhdGVCbG9jayhuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGlmIChuYW1lID09PSAnaW52ZXJzZScpIHtcbiAgICAgIG5hbWUgPSAnZWxzZSc7XG4gICAgfVxuXG4gICAgbGV0IGJsb2NrID0gdGhpcy5ibG9ja3NbbmFtZV07XG5cbiAgICBpZiAoIWJsb2NrKSB7XG4gICAgICBibG9jayA9IHRoaXMuYmxvY2tzW25hbWVdID0gdGhpcy5hbGxvY2F0ZShgJiR7bmFtZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2s7XG4gIH1cblxuICBhbGxvY2F0ZShpZGVudGlmaWVyOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHRoaXMuc3ltYm9scy5wdXNoKGlkZW50aWZpZXIpO1xuICAgIHJldHVybiB0aGlzLnNpemUrKztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmxvY2tTeW1ib2xUYWJsZSBleHRlbmRzIFN5bWJvbFRhYmxlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwYXJlbnQ6IFN5bWJvbFRhYmxlLCBwdWJsaWMgc3ltYm9sczogc3RyaW5nW10sIHB1YmxpYyBzbG90czogbnVtYmVyW10pIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgZ2V0IGxvY2FscygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuc3ltYm9scztcbiAgfVxuXG4gIGhhcyhuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zeW1ib2xzLmluZGV4T2YobmFtZSkgIT09IC0xIHx8IHRoaXMucGFyZW50LmhhcyhuYW1lKTtcbiAgfVxuXG4gIGdldChuYW1lOiBzdHJpbmcpOiBbbnVtYmVyLCBib29sZWFuXSB7XG4gICAgbGV0IHNsb3QgPSB0aGlzLnN5bWJvbHMuaW5kZXhPZihuYW1lKTtcbiAgICByZXR1cm4gc2xvdCA9PT0gLTEgPyB0aGlzLnBhcmVudC5nZXQobmFtZSkgOiBbdGhpcy5zbG90c1tzbG90XSwgZmFsc2VdO1xuICB9XG5cbiAgZ2V0TG9jYWxzTWFwKCk6IERpY3Q8bnVtYmVyPiB7XG4gICAgbGV0IGRpY3QgPSB0aGlzLnBhcmVudC5nZXRMb2NhbHNNYXAoKTtcbiAgICB0aGlzLnN5bWJvbHMuZm9yRWFjaCgoc3ltYm9sKSA9PiAoZGljdFtzeW1ib2xdID0gdGhpcy5nZXQoc3ltYm9sKVswXSkpO1xuICAgIHJldHVybiBkaWN0O1xuICB9XG5cbiAgZ2V0RXZhbEluZm8oKTogQ29yZS5FdmFsSW5mbyB7XG4gICAgbGV0IGxvY2FscyA9IHRoaXMuZ2V0TG9jYWxzTWFwKCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGxvY2FscykubWFwKChzeW1ib2wpID0+IGxvY2Fsc1tzeW1ib2xdKTtcbiAgfVxuXG4gIHNldEhhc0V2YWwoKTogdm9pZCB7XG4gICAgdGhpcy5wYXJlbnQuc2V0SGFzRXZhbCgpO1xuICB9XG5cbiAgYWxsb2NhdGVGcmVlKG5hbWU6IHN0cmluZywgcmVzb2x1dGlvbjogQVNUdjIuRnJlZVZhclJlc29sdXRpb24pOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5hbGxvY2F0ZUZyZWUobmFtZSwgcmVzb2x1dGlvbik7XG4gIH1cblxuICBhbGxvY2F0ZU5hbWVkKG5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmFsbG9jYXRlTmFtZWQobmFtZSk7XG4gIH1cblxuICBhbGxvY2F0ZUJsb2NrKG5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmFsbG9jYXRlQmxvY2sobmFtZSk7XG4gIH1cblxuICBhbGxvY2F0ZShpZGVudGlmaWVyOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5hbGxvY2F0ZShpZGVudGlmaWVyKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBQcmVzZW50QXJyYXkgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0UHJlc2VudCwgYXNzaWduIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmltcG9ydCB7IFNvdXJjZVNsaWNlIH0gZnJvbSAnLi4vc291cmNlL3NsaWNlJztcbmltcG9ydCB7IFNvdXJjZVNwYW4gfSBmcm9tICcuLi9zb3VyY2Uvc3Bhbic7XG5pbXBvcnQgeyBTcGFuTGlzdCB9IGZyb20gJy4uL3NvdXJjZS9zcGFuLWxpc3QnO1xuaW1wb3J0IHsgQmxvY2tTeW1ib2xUYWJsZSwgUHJvZ3JhbVN5bWJvbFRhYmxlLCBTeW1ib2xUYWJsZSB9IGZyb20gJy4uL3N5bWJvbC10YWJsZSc7XG5pbXBvcnQgKiBhcyBBU1R2MiBmcm9tICcuL2FwaSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbFBhcnRzIHtcbiAgY2FsbGVlOiBBU1R2Mi5FeHByZXNzaW9uTm9kZTtcbiAgYXJnczogQVNUdjIuQXJncztcbn1cblxuZXhwb3J0IGNsYXNzIEJ1aWxkZXIge1xuICAvLyBURU1QTEFURSAvL1xuXG4gIHRlbXBsYXRlKFxuICAgIHN5bWJvbHM6IFByb2dyYW1TeW1ib2xUYWJsZSxcbiAgICBib2R5OiBBU1R2Mi5Db250ZW50Tm9kZVtdLFxuICAgIGxvYzogU291cmNlU3BhblxuICApOiBBU1R2Mi5UZW1wbGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBBU1R2Mi5UZW1wbGF0ZSh7XG4gICAgICB0YWJsZTogc3ltYm9scyxcbiAgICAgIGJvZHksXG4gICAgICBsb2MsXG4gICAgfSk7XG4gIH1cblxuICAvLyBJTlRFUk5BTCAodGhlc2Ugbm9kZXMgY2Fubm90IGJlIHJlYWNoZWQgd2hlbiBkb2luZyBnZW5lcmFsLXB1cnBvc2UgdmlzaXRpbmcpIC8vXG5cbiAgYmxvY2soc3ltYm9sczogQmxvY2tTeW1ib2xUYWJsZSwgYm9keTogQVNUdjIuQ29udGVudE5vZGVbXSwgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjIuQmxvY2sge1xuICAgIHJldHVybiBuZXcgQVNUdjIuQmxvY2soe1xuICAgICAgc2NvcGU6IHN5bWJvbHMsXG4gICAgICBib2R5LFxuICAgICAgbG9jLFxuICAgIH0pO1xuICB9XG5cbiAgbmFtZWRCbG9jayhuYW1lOiBTb3VyY2VTbGljZSwgYmxvY2s6IEFTVHYyLkJsb2NrLCBsb2M6IFNvdXJjZVNwYW4pOiBBU1R2Mi5OYW1lZEJsb2NrIHtcbiAgICByZXR1cm4gbmV3IEFTVHYyLk5hbWVkQmxvY2soe1xuICAgICAgbmFtZSxcbiAgICAgIGJsb2NrLFxuICAgICAgYXR0cnM6IFtdLFxuICAgICAgY29tcG9uZW50QXJnczogW10sXG4gICAgICBtb2RpZmllcnM6IFtdLFxuICAgICAgbG9jLFxuICAgIH0pO1xuICB9XG5cbiAgc2ltcGxlTmFtZWRCbG9jayhuYW1lOiBTb3VyY2VTbGljZSwgYmxvY2s6IEFTVHYyLkJsb2NrLCBsb2M6IFNvdXJjZVNwYW4pOiBBU1R2Mi5OYW1lZEJsb2NrIHtcbiAgICByZXR1cm4gbmV3IEJ1aWxkRWxlbWVudCh7XG4gICAgICBzZWxmQ2xvc2luZzogZmFsc2UsXG4gICAgICBhdHRyczogW10sXG4gICAgICBjb21wb25lbnRBcmdzOiBbXSxcbiAgICAgIG1vZGlmaWVyczogW10sXG4gICAgICBjb21tZW50czogW10sXG4gICAgfSkubmFtZWQobmFtZSwgYmxvY2ssIGxvYyk7XG4gIH1cblxuICBzbGljZShjaGFyczogc3RyaW5nLCBsb2M6IFNvdXJjZVNwYW4pOiBTb3VyY2VTbGljZSB7XG4gICAgcmV0dXJuIG5ldyBTb3VyY2VTbGljZSh7XG4gICAgICBsb2MsXG4gICAgICBjaGFycyxcbiAgICB9KTtcbiAgfVxuXG4gIGFyZ3MoXG4gICAgcG9zaXRpb25hbDogQVNUdjIuUG9zaXRpb25hbEFyZ3VtZW50cyxcbiAgICBuYW1lZDogQVNUdjIuTmFtZWRBcmd1bWVudHMsXG4gICAgbG9jOiBTb3VyY2VTcGFuXG4gICk6IEFTVHYyLkFyZ3Mge1xuICAgIHJldHVybiBuZXcgQVNUdjIuQXJncyh7XG4gICAgICBsb2MsXG4gICAgICBwb3NpdGlvbmFsLFxuICAgICAgbmFtZWQsXG4gICAgfSk7XG4gIH1cblxuICBwb3NpdGlvbmFsKGV4cHJzOiBBU1R2Mi5FeHByZXNzaW9uTm9kZVtdLCBsb2M6IFNvdXJjZVNwYW4pOiBBU1R2Mi5Qb3NpdGlvbmFsQXJndW1lbnRzIHtcbiAgICByZXR1cm4gbmV3IEFTVHYyLlBvc2l0aW9uYWxBcmd1bWVudHMoe1xuICAgICAgbG9jLFxuICAgICAgZXhwcnMsXG4gICAgfSk7XG4gIH1cblxuICBuYW1lZEFyZ3VtZW50KGtleTogU291cmNlU2xpY2UsIHZhbHVlOiBBU1R2Mi5FeHByZXNzaW9uTm9kZSk6IEFTVHYyLk5hbWVkQXJndW1lbnQge1xuICAgIHJldHVybiBuZXcgQVNUdjIuTmFtZWRBcmd1bWVudCh7XG4gICAgICBuYW1lOiBrZXksXG4gICAgICB2YWx1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIG5hbWVkKGVudHJpZXM6IEFTVHYyLk5hbWVkQXJndW1lbnRbXSwgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjIuTmFtZWRBcmd1bWVudHMge1xuICAgIHJldHVybiBuZXcgQVNUdjIuTmFtZWRBcmd1bWVudHMoe1xuICAgICAgbG9jLFxuICAgICAgZW50cmllcyxcbiAgICB9KTtcbiAgfVxuXG4gIGF0dHIoXG4gICAge1xuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgdHJ1c3RpbmcsXG4gICAgfTogeyBuYW1lOiBTb3VyY2VTbGljZTsgdmFsdWU6IEFTVHYyLkV4cHJlc3Npb25Ob2RlOyB0cnVzdGluZzogYm9vbGVhbiB9LFxuICAgIGxvYzogU291cmNlU3BhblxuICApOiBBU1R2Mi5IdG1sQXR0ciB7XG4gICAgcmV0dXJuIG5ldyBBU1R2Mi5IdG1sQXR0cih7XG4gICAgICBsb2MsXG4gICAgICBuYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICB0cnVzdGluZyxcbiAgICB9KTtcbiAgfVxuXG4gIHNwbGF0QXR0cihzeW1ib2w6IG51bWJlciwgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjIuU3BsYXRBdHRyIHtcbiAgICByZXR1cm4gbmV3IEFTVHYyLlNwbGF0QXR0cih7XG4gICAgICBzeW1ib2wsXG4gICAgICBsb2MsXG4gICAgfSk7XG4gIH1cblxuICBhcmcoXG4gICAge1xuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgdHJ1c3RpbmcsXG4gICAgfTogeyBuYW1lOiBTb3VyY2VTbGljZTsgdmFsdWU6IEFTVHYyLkV4cHJlc3Npb25Ob2RlOyB0cnVzdGluZzogYm9vbGVhbiB9LFxuICAgIGxvYzogU291cmNlU3BhblxuICApOiBBU1R2Mi5Db21wb25lbnRBcmcge1xuICAgIHJldHVybiBuZXcgQVNUdjIuQ29tcG9uZW50QXJnKHtcbiAgICAgIG5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIHRydXN0aW5nLFxuICAgICAgbG9jLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gRVhQUkVTU0lPTlMgLy9cblxuICBwYXRoKGhlYWQ6IEFTVHYyLlZhcmlhYmxlUmVmZXJlbmNlLCB0YWlsOiBTb3VyY2VTbGljZVtdLCBsb2M6IFNvdXJjZVNwYW4pOiBBU1R2Mi5QYXRoRXhwcmVzc2lvbiB7XG4gICAgcmV0dXJuIG5ldyBBU1R2Mi5QYXRoRXhwcmVzc2lvbih7XG4gICAgICBsb2MsXG4gICAgICByZWY6IGhlYWQsXG4gICAgICB0YWlsLFxuICAgIH0pO1xuICB9XG5cbiAgc2VsZihsb2M6IFNvdXJjZVNwYW4pOiBBU1R2Mi5WYXJpYWJsZVJlZmVyZW5jZSB7XG4gICAgcmV0dXJuIG5ldyBBU1R2Mi5UaGlzUmVmZXJlbmNlKHtcbiAgICAgIGxvYyxcbiAgICB9KTtcbiAgfVxuXG4gIGF0KG5hbWU6IHN0cmluZywgc3ltYm9sOiBudW1iZXIsIGxvYzogU291cmNlU3Bhbik6IEFTVHYyLlZhcmlhYmxlUmVmZXJlbmNlIHtcbiAgICAvLyB0aGUgYEBgIHNob3VsZCBiZSBpbmNsdWRlZCBzbyB3ZSBoYXZlIGEgY29tcGxldGUgc291cmNlIHJhbmdlXG4gICAgYXNzZXJ0KG5hbWVbMF0gPT09ICdAJywgYGNhbGwgYnVpbGRlcnMuYXQoKSB3aXRoIGEgc3RyaW5nIHRoYXQgc3RhcnRzIHdpdGggJ0AnYCk7XG5cbiAgICByZXR1cm4gbmV3IEFTVHYyLkFyZ1JlZmVyZW5jZSh7XG4gICAgICBsb2MsXG4gICAgICBuYW1lOiBuZXcgU291cmNlU2xpY2UoeyBsb2MsIGNoYXJzOiBuYW1lIH0pLFxuICAgICAgc3ltYm9sLFxuICAgIH0pO1xuICB9XG5cbiAgZnJlZVZhcih7XG4gICAgbmFtZSxcbiAgICBjb250ZXh0LFxuICAgIHN5bWJvbCxcbiAgICBsb2MsXG4gIH06IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgY29udGV4dDogQVNUdjIuRnJlZVZhclJlc29sdXRpb247XG4gICAgc3ltYm9sOiBudW1iZXI7XG4gICAgbG9jOiBTb3VyY2VTcGFuO1xuICB9KTogQVNUdjIuRnJlZVZhclJlZmVyZW5jZSB7XG4gICAgYXNzZXJ0KFxuICAgICAgbmFtZSAhPT0gJ3RoaXMnLFxuICAgICAgYFlvdSBjYWxsZWQgYnVpbGRlcnMuZnJlZVZhcigpIHdpdGggJ3RoaXMnLiBDYWxsIGJ1aWxkZXJzLnRoaXMgaW5zdGVhZGBcbiAgICApO1xuICAgIGFzc2VydChcbiAgICAgIG5hbWVbMF0gIT09ICdAJyxcbiAgICAgIGBZb3UgY2FsbGVkIGJ1aWxkZXJzLmZyZWVWYXIoKSB3aXRoICcke25hbWV9Jy4gQ2FsbCBidWlsZGVycy5hdCgnJHtuYW1lfScpIGluc3RlYWRgXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgQVNUdjIuRnJlZVZhclJlZmVyZW5jZSh7XG4gICAgICBuYW1lLFxuICAgICAgcmVzb2x1dGlvbjogY29udGV4dCxcbiAgICAgIHN5bWJvbCxcbiAgICAgIGxvYyxcbiAgICB9KTtcbiAgfVxuXG4gIGxvY2FsVmFyKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBzeW1ib2w6IG51bWJlcixcbiAgICBpc1RlbXBsYXRlTG9jYWw6IGJvb2xlYW4sXG4gICAgbG9jOiBTb3VyY2VTcGFuXG4gICk6IEFTVHYyLlZhcmlhYmxlUmVmZXJlbmNlIHtcbiAgICBhc3NlcnQobmFtZSAhPT0gJ3RoaXMnLCBgWW91IGNhbGxlZCBidWlsZGVycy52YXIoKSB3aXRoICd0aGlzJy4gQ2FsbCBidWlsZGVycy50aGlzIGluc3RlYWRgKTtcbiAgICBhc3NlcnQoXG4gICAgICBuYW1lWzBdICE9PSAnQCcsXG4gICAgICBgWW91IGNhbGxlZCBidWlsZGVycy52YXIoKSB3aXRoICcke25hbWV9Jy4gQ2FsbCBidWlsZGVycy5hdCgnJHtuYW1lfScpIGluc3RlYWRgXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgQVNUdjIuTG9jYWxWYXJSZWZlcmVuY2Uoe1xuICAgICAgbG9jLFxuICAgICAgbmFtZSxcbiAgICAgIGlzVGVtcGxhdGVMb2NhbCxcbiAgICAgIHN5bWJvbCxcbiAgICB9KTtcbiAgfVxuXG4gIHNleHAocGFydHM6IENhbGxQYXJ0cywgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjIuQ2FsbEV4cHJlc3Npb24ge1xuICAgIHJldHVybiBuZXcgQVNUdjIuQ2FsbEV4cHJlc3Npb24oe1xuICAgICAgbG9jLFxuICAgICAgY2FsbGVlOiBwYXJ0cy5jYWxsZWUsXG4gICAgICBhcmdzOiBwYXJ0cy5hcmdzLFxuICAgIH0pO1xuICB9XG5cbiAgZGVwcmVjYXRlZENhbGwoXG4gICAgYXJnOiBTb3VyY2VTbGljZSxcbiAgICBjYWxsZWU6IEFTVHYyLkZyZWVWYXJSZWZlcmVuY2UsXG4gICAgbG9jOiBTb3VyY2VTcGFuXG4gICk6IEFTVHYyLkRlcHJlY2F0ZWRDYWxsRXhwcmVzc2lvbiB7XG4gICAgcmV0dXJuIG5ldyBBU1R2Mi5EZXByZWNhdGVkQ2FsbEV4cHJlc3Npb24oe1xuICAgICAgbG9jLFxuICAgICAgYXJnLFxuICAgICAgY2FsbGVlLFxuICAgIH0pO1xuICB9XG5cbiAgaW50ZXJwb2xhdGUocGFydHM6IEFTVHYyLkV4cHJlc3Npb25Ob2RlW10sIGxvYzogU291cmNlU3Bhbik6IEFTVHYyLkludGVycG9sYXRlRXhwcmVzc2lvbiB7XG4gICAgYXNzZXJ0UHJlc2VudChwYXJ0cyk7XG5cbiAgICByZXR1cm4gbmV3IEFTVHYyLkludGVycG9sYXRlRXhwcmVzc2lvbih7XG4gICAgICBsb2MsXG4gICAgICBwYXJ0cyxcbiAgICB9KTtcbiAgfVxuXG4gIGxpdGVyYWwodmFsdWU6IHN0cmluZywgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjIuTGl0ZXJhbEV4cHJlc3Npb24gJiB7IHZhbHVlOiBzdHJpbmcgfTtcbiAgbGl0ZXJhbCh2YWx1ZTogbnVtYmVyLCBsb2M6IFNvdXJjZVNwYW4pOiBBU1R2Mi5MaXRlcmFsRXhwcmVzc2lvbiAmIHsgdmFsdWU6IG51bWJlciB9O1xuICBsaXRlcmFsKHZhbHVlOiBib29sZWFuLCBsb2M6IFNvdXJjZVNwYW4pOiBBU1R2Mi5MaXRlcmFsRXhwcmVzc2lvbiAmIHsgdmFsdWU6IGJvb2xlYW4gfTtcbiAgbGl0ZXJhbCh2YWx1ZTogbnVsbCwgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjIuTGl0ZXJhbEV4cHJlc3Npb24gJiB7IHZhbHVlOiBudWxsIH07XG4gIGxpdGVyYWwodmFsdWU6IHVuZGVmaW5lZCwgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjIuTGl0ZXJhbEV4cHJlc3Npb24gJiB7IHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgbGl0ZXJhbChcbiAgICB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgbG9jOiBTb3VyY2VTcGFuXG4gICk6IEFTVHYyLkxpdGVyYWxFeHByZXNzaW9uO1xuICBsaXRlcmFsKFxuICAgIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBsb2M6IFNvdXJjZVNwYW5cbiAgKTogQVNUdjIuTGl0ZXJhbEV4cHJlc3Npb24ge1xuICAgIHJldHVybiBuZXcgQVNUdjIuTGl0ZXJhbEV4cHJlc3Npb24oe1xuICAgICAgbG9jLFxuICAgICAgdmFsdWUsXG4gICAgfSk7XG4gIH1cblxuICAvLyBTVEFURU1FTlRTIC8vXG5cbiAgYXBwZW5kKFxuICAgIHtcbiAgICAgIHRhYmxlLFxuICAgICAgdHJ1c3RpbmcsXG4gICAgICB2YWx1ZSxcbiAgICB9OiB7IHRhYmxlOiBTeW1ib2xUYWJsZTsgdHJ1c3Rpbmc6IGJvb2xlYW47IHZhbHVlOiBBU1R2Mi5FeHByZXNzaW9uTm9kZSB9LFxuICAgIGxvYzogU291cmNlU3BhblxuICApOiBBU1R2Mi5BcHBlbmRDb250ZW50IHtcbiAgICByZXR1cm4gbmV3IEFTVHYyLkFwcGVuZENvbnRlbnQoe1xuICAgICAgdGFibGUsXG4gICAgICB0cnVzdGluZyxcbiAgICAgIHZhbHVlLFxuICAgICAgbG9jLFxuICAgIH0pO1xuICB9XG5cbiAgbW9kaWZpZXIoeyBjYWxsZWUsIGFyZ3MgfTogQ2FsbFBhcnRzLCBsb2M6IFNvdXJjZVNwYW4pOiBBU1R2Mi5FbGVtZW50TW9kaWZpZXIge1xuICAgIHJldHVybiBuZXcgQVNUdjIuRWxlbWVudE1vZGlmaWVyKHtcbiAgICAgIGxvYyxcbiAgICAgIGNhbGxlZSxcbiAgICAgIGFyZ3MsXG4gICAgfSk7XG4gIH1cblxuICBuYW1lZEJsb2NrcyhibG9ja3M6IEFTVHYyLk5hbWVkQmxvY2tbXSwgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjIuTmFtZWRCbG9ja3Mge1xuICAgIHJldHVybiBuZXcgQVNUdjIuTmFtZWRCbG9ja3Moe1xuICAgICAgbG9jLFxuICAgICAgYmxvY2tzLFxuICAgIH0pO1xuICB9XG5cbiAgYmxvY2tTdGF0ZW1lbnQoXG4gICAge1xuICAgICAgc3ltYm9scyxcbiAgICAgIHByb2dyYW0sXG4gICAgICBpbnZlcnNlID0gbnVsbCxcbiAgICAgIC4uLmNhbGxcbiAgICB9OiB7XG4gICAgICBzeW1ib2xzOiBTeW1ib2xUYWJsZTtcbiAgICAgIHByb2dyYW06IEFTVHYyLkJsb2NrO1xuICAgICAgaW52ZXJzZT86IEFTVHYyLkJsb2NrIHwgbnVsbDtcbiAgICB9ICYgQ2FsbFBhcnRzLFxuICAgIGxvYzogU291cmNlU3BhblxuICApOiBBU1R2Mi5JbnZva2VCbG9jayB7XG4gICAgbGV0IGJsb2Nrc0xvYyA9IHByb2dyYW0ubG9jO1xuICAgIGxldCBibG9ja3M6IFByZXNlbnRBcnJheTxBU1R2Mi5OYW1lZEJsb2NrPiA9IFtcbiAgICAgIHRoaXMubmFtZWRCbG9jayhTb3VyY2VTbGljZS5zeW50aGV0aWMoJ2RlZmF1bHQnKSwgcHJvZ3JhbSwgcHJvZ3JhbS5sb2MpLFxuICAgIF07XG4gICAgaWYgKGludmVyc2UpIHtcbiAgICAgIGJsb2Nrc0xvYyA9IGJsb2Nrc0xvYy5leHRlbmQoaW52ZXJzZS5sb2MpO1xuICAgICAgYmxvY2tzLnB1c2godGhpcy5uYW1lZEJsb2NrKFNvdXJjZVNsaWNlLnN5bnRoZXRpYygnZWxzZScpLCBpbnZlcnNlLCBpbnZlcnNlLmxvYykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQVNUdjIuSW52b2tlQmxvY2soe1xuICAgICAgbG9jLFxuICAgICAgYmxvY2tzOiB0aGlzLm5hbWVkQmxvY2tzKGJsb2NrcywgYmxvY2tzTG9jKSxcbiAgICAgIGNhbGxlZTogY2FsbC5jYWxsZWUsXG4gICAgICBhcmdzOiBjYWxsLmFyZ3MsXG4gICAgfSk7XG4gIH1cblxuICBlbGVtZW50KG9wdGlvbnM6IEJ1aWxkQmFzZUVsZW1lbnQpOiBCdWlsZEVsZW1lbnQge1xuICAgIHJldHVybiBuZXcgQnVpbGRFbGVtZW50KG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVpbGRCYXNlRWxlbWVudCB7XG4gIHNlbGZDbG9zaW5nOiBib29sZWFuO1xuICBhdHRyczogQVNUdjIuSHRtbE9yU3BsYXRBdHRyW107XG4gIGNvbXBvbmVudEFyZ3M6IEFTVHYyLkNvbXBvbmVudEFyZ1tdO1xuICBtb2RpZmllcnM6IEFTVHYyLkVsZW1lbnRNb2RpZmllcltdO1xuICBjb21tZW50czogQVNUdjIuR2xpbW1lckNvbW1lbnRbXTtcbn1cblxuZXhwb3J0IGNsYXNzIEJ1aWxkRWxlbWVudCB7XG4gIHJlYWRvbmx5IGJ1aWxkZXI6IEJ1aWxkZXI7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGJhc2U6IEJ1aWxkQmFzZUVsZW1lbnQpIHtcbiAgICB0aGlzLmJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICB9XG5cbiAgc2ltcGxlKHRhZzogU291cmNlU2xpY2UsIGJvZHk6IEFTVHYyLkNvbnRlbnROb2RlW10sIGxvYzogU291cmNlU3Bhbik6IEFTVHYyLlNpbXBsZUVsZW1lbnQge1xuICAgIHJldHVybiBuZXcgQVNUdjIuU2ltcGxlRWxlbWVudChcbiAgICAgIGFzc2lnbihcbiAgICAgICAge1xuICAgICAgICAgIHRhZyxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGNvbXBvbmVudEFyZ3M6IFtdLFxuICAgICAgICAgIGxvYyxcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy5iYXNlXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIG5hbWVkKG5hbWU6IFNvdXJjZVNsaWNlLCBibG9jazogQVNUdjIuQmxvY2ssIGxvYzogU291cmNlU3Bhbik6IEFTVHYyLk5hbWVkQmxvY2sge1xuICAgIHJldHVybiBuZXcgQVNUdjIuTmFtZWRCbG9jayhcbiAgICAgIGFzc2lnbihcbiAgICAgICAge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgY29tcG9uZW50QXJnczogW10sXG4gICAgICAgICAgbG9jLFxuICAgICAgICB9LFxuICAgICAgICB0aGlzLmJhc2VcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgc2VsZkNsb3NpbmdDb21wb25lbnQoY2FsbGVlOiBBU1R2Mi5FeHByZXNzaW9uTm9kZSwgbG9jOiBTb3VyY2VTcGFuKTogQVNUdjIuSW52b2tlQ29tcG9uZW50IHtcbiAgICByZXR1cm4gbmV3IEFTVHYyLkludm9rZUNvbXBvbmVudChcbiAgICAgIGFzc2lnbihcbiAgICAgICAge1xuICAgICAgICAgIGxvYyxcbiAgICAgICAgICBjYWxsZWUsXG4gICAgICAgICAgLy8gcG9pbnQgdGhlIGVtcHR5IG5hbWVkIGJsb2NrcyBhdCB0aGUgYC9gIHNlbGYtY2xvc2luZyB0YWdcbiAgICAgICAgICBibG9ja3M6IG5ldyBBU1R2Mi5OYW1lZEJsb2Nrcyh7XG4gICAgICAgICAgICBibG9ja3M6IFtdLFxuICAgICAgICAgICAgbG9jOiBsb2Muc2xpY2VFbmRDaGFycyh7IHNraXBFbmQ6IDEsIGNoYXJzOiAxIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9LFxuICAgICAgICB0aGlzLmJhc2VcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgY29tcG9uZW50V2l0aERlZmF1bHRCbG9jayhcbiAgICBjYWxsZWU6IEFTVHYyLkV4cHJlc3Npb25Ob2RlLFxuICAgIGNoaWxkcmVuOiBBU1R2Mi5Db250ZW50Tm9kZVtdLFxuICAgIHN5bWJvbHM6IEJsb2NrU3ltYm9sVGFibGUsXG4gICAgbG9jOiBTb3VyY2VTcGFuXG4gICk6IEFTVHYyLkludm9rZUNvbXBvbmVudCB7XG4gICAgbGV0IGJsb2NrID0gdGhpcy5idWlsZGVyLmJsb2NrKHN5bWJvbHMsIGNoaWxkcmVuLCBsb2MpO1xuICAgIGxldCBuYW1lZEJsb2NrID0gdGhpcy5idWlsZGVyLm5hbWVkQmxvY2soU291cmNlU2xpY2Uuc3ludGhldGljKCdkZWZhdWx0JyksIGJsb2NrLCBsb2MpOyAvLyBCVUlMREVSLnNpbXBsZU5hbWVkQmxvY2soJ2RlZmF1bHQnLCBjaGlsZHJlbiwgc3ltYm9scywgbG9jKTtcblxuICAgIHJldHVybiBuZXcgQVNUdjIuSW52b2tlQ29tcG9uZW50KFxuICAgICAgYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgbG9jLFxuICAgICAgICAgIGNhbGxlZSxcbiAgICAgICAgICBibG9ja3M6IHRoaXMuYnVpbGRlci5uYW1lZEJsb2NrcyhbbmFtZWRCbG9ja10sIG5hbWVkQmxvY2subG9jKSxcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy5iYXNlXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpdGhOYW1lZEJsb2NrcyhcbiAgICBjYWxsZWU6IEFTVHYyLkV4cHJlc3Npb25Ob2RlLFxuICAgIGJsb2NrczogUHJlc2VudEFycmF5PEFTVHYyLk5hbWVkQmxvY2s+LFxuICAgIGxvYzogU291cmNlU3BhblxuICApOiBBU1R2Mi5JbnZva2VDb21wb25lbnQge1xuICAgIHJldHVybiBuZXcgQVNUdjIuSW52b2tlQ29tcG9uZW50KFxuICAgICAgYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgbG9jLFxuICAgICAgICAgIGNhbGxlZSxcbiAgICAgICAgICBibG9ja3M6IHRoaXMuYnVpbGRlci5uYW1lZEJsb2NrcyhibG9ja3MsIFNwYW5MaXN0LnJhbmdlKGJsb2NrcykpLFxuICAgICAgICB9LFxuICAgICAgICB0aGlzLmJhc2VcbiAgICAgIClcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBBU1R2MSBmcm9tICcuLi92MS9hcGknO1xuaW1wb3J0ICogYXMgQVNUdjIgZnJvbSAnLi9hcGknO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFzdENhbGxQYXJ0cyB7XG4gIHBhdGg6IEFTVHYxLkV4cHJlc3Npb247XG4gIHBhcmFtczogQVNUdjEuRXhwcmVzc2lvbltdO1xuICBoYXNoOiBBU1R2MS5IYXNoO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZhclBhdGggZXh0ZW5kcyBBU1R2MS5QYXRoRXhwcmVzc2lvbiB7XG4gIGhlYWQ6IEFTVHYxLlZhckhlYWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZXhwU3ludGF4Q29udGV4dChub2RlOiBBU1R2MS5TdWJFeHByZXNzaW9uKTogQVNUdjIuRnJlZVZhclJlc29sdXRpb24gfCBudWxsIHtcbiAgaWYgKGlzU2ltcGxlQ2FsbGVlKG5vZGUpKSB7XG4gICAgcmV0dXJuIEFTVHYyLkxvb3NlTW9kZVJlc29sdXRpb24ubmFtZXNwYWNlZChBU1R2Mi5GcmVlVmFyTmFtZXNwYWNlLkhlbHBlcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE1vZGlmaWVyU3ludGF4Q29udGV4dChcbiAgbm9kZTogQVNUdjEuRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50XG4pOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbiB8IG51bGwge1xuICBpZiAoaXNTaW1wbGVDYWxsZWUobm9kZSkpIHtcbiAgICByZXR1cm4gQVNUdjIuTG9vc2VNb2RlUmVzb2x1dGlvbi5uYW1lc3BhY2VkKEFTVHYyLkZyZWVWYXJOYW1lc3BhY2UuTW9kaWZpZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBCbG9ja1N5bnRheENvbnRleHQobm9kZTogQVNUdjEuQmxvY2tTdGF0ZW1lbnQpOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbiB8IG51bGwge1xuICBpZiAoaXNTaW1wbGVDYWxsZWUobm9kZSkpIHtcbiAgICByZXR1cm4gQVNUdjIuTG9vc2VNb2RlUmVzb2x1dGlvbi5uYW1lc3BhY2VkKEFTVHYyLkZyZWVWYXJOYW1lc3BhY2UuQ29tcG9uZW50KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQVNUdjIuTG9vc2VNb2RlUmVzb2x1dGlvbi5mYWxsYmFjaygpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb21wb25lbnRTeW50YXhDb250ZXh0KG5vZGU6IEFTVHYxLlBhdGhFeHByZXNzaW9uKTogQVNUdjIuRnJlZVZhclJlc29sdXRpb24gfCBudWxsIHtcbiAgaWYgKGlzU2ltcGxlUGF0aChub2RlKSkge1xuICAgIHJldHVybiBBU1R2Mi5Mb29zZU1vZGVSZXNvbHV0aW9uLm5hbWVzcGFjZWQoQVNUdjIuRnJlZVZhck5hbWVzcGFjZS5Db21wb25lbnQsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBjb3JyZXNwb25kcyB0byBhcHBlbmQgcG9zaXRpb25zICh0ZXh0IGN1cmxpZXMgb3IgYXR0cmlidXRlXG4gKiBjdXJsaWVzKS4gSW4gc3RyaWN0IG1vZGUsIHRoaXMgYWxzbyBjb3JyZXNwb25kcyB0byBhcmcgY3VybGllcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEF0dHJWYWx1ZVN5bnRheENvbnRleHQobm9kZTogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQpOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbiB7XG4gIGxldCBpc1NpbXBsZSA9IGlzU2ltcGxlQ2FsbGVlKG5vZGUpO1xuICBsZXQgaXNJbnZva2UgPSBpc0ludm9rZU5vZGUobm9kZSk7XG5cbiAgaWYgKGlzU2ltcGxlKSB7XG4gICAgcmV0dXJuIGlzSW52b2tlXG4gICAgICA/IEFTVHYyLkxvb3NlTW9kZVJlc29sdXRpb24ubmFtZXNwYWNlZChBU1R2Mi5GcmVlVmFyTmFtZXNwYWNlLkhlbHBlcilcbiAgICAgIDogQVNUdjIuTG9vc2VNb2RlUmVzb2x1dGlvbi5hdHRyKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlzSW52b2tlID8gQVNUdjIuU1RSSUNUX1JFU09MVVRJT04gOiBBU1R2Mi5Mb29zZU1vZGVSZXNvbHV0aW9uLmZhbGxiYWNrKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNvcnJlc3BvbmRzIHRvIGFwcGVuZCBwb3NpdGlvbnMgKHRleHQgY3VybGllcyBvciBhdHRyaWJ1dGVcbiAqIGN1cmxpZXMpLiBJbiBzdHJpY3QgbW9kZSwgdGhpcyBhbHNvIGNvcnJlc3BvbmRzIHRvIGFyZyBjdXJsaWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQXBwZW5kU3ludGF4Q29udGV4dChub2RlOiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCk6IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uIHtcbiAgbGV0IGlzU2ltcGxlID0gaXNTaW1wbGVDYWxsZWUobm9kZSk7XG4gIGxldCBpc0ludm9rZSA9IGlzSW52b2tlTm9kZShub2RlKTtcbiAgbGV0IHRydXN0aW5nID0gbm9kZS50cnVzdGluZztcblxuICBpZiAoaXNTaW1wbGUpIHtcbiAgICByZXR1cm4gdHJ1c3RpbmdcbiAgICAgID8gQVNUdjIuTG9vc2VNb2RlUmVzb2x1dGlvbi50cnVzdGluZ0FwcGVuZCh7IGludm9rZTogaXNJbnZva2UgfSlcbiAgICAgIDogQVNUdjIuTG9vc2VNb2RlUmVzb2x1dGlvbi5hcHBlbmQoeyBpbnZva2U6IGlzSW52b2tlIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBU1R2Mi5Mb29zZU1vZGVSZXNvbHV0aW9uLmZhbGxiYWNrKCk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgUmVzb2x1dGlvbjxQIGV4dGVuZHMgQXN0Q2FsbFBhcnRzIHwgQVNUdjEuUGF0aEV4cHJlc3Npb24+ID0gKFxuICBjYWxsOiBQXG4pID0+IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uIHwgbnVsbDtcblxuLy8gVVRJTElUSUVTXG5cbi8qKlxuICogQSBjYWxsIG5vZGUgaGFzIGEgc2ltcGxlIGNhbGxlZSBpZiBpdHMgaGVhZCBpczpcbiAqXG4gKiAtIGEgYFBhdGhFeHByZXNzaW9uYFxuICogLSB0aGUgYFBhdGhFeHByZXNzaW9uYCdzIGhlYWQgaXMgYSBgVmFySGVhZGBcbiAqIC0gaXQgaGFzIG5vIHRhaWxcbiAqXG4gKiBTaW1wbGUgaGVhZHM6XG4gKlxuICogYGBgXG4gKiB7e3h9fVxuICoge3t4IHl9fVxuICogYGBgXG4gKlxuICogTm90IHNpbXBsZSBoZWFkczpcbiAqXG4gKiBgYGBcbiAqIHt7eC55fX1cbiAqIHt7eC55IHp9fVxuICoge3tAeH19XG4gKiB7e0B4IGF9fVxuICoge3t0aGlzfX1cbiAqIHt7dGhpcyBhfX1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBpc1NpbXBsZUNhbGxlZShub2RlOiBBc3RDYWxsUGFydHMpOiBib29sZWFuIHtcbiAgbGV0IHBhdGggPSBub2RlLnBhdGg7XG5cbiAgcmV0dXJuIGlzU2ltcGxlUGF0aChwYXRoKTtcbn1cblxuZnVuY3Rpb24gaXNTaW1wbGVQYXRoKG5vZGU6IEFTVHYxLkV4cHJlc3Npb24pOiBib29sZWFuIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ1BhdGhFeHByZXNzaW9uJyAmJiBub2RlLmhlYWQudHlwZSA9PT0gJ1ZhckhlYWQnKSB7XG4gICAgcmV0dXJuIG5vZGUudGFpbC5sZW5ndGggPT09IDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGNhbGwgZXhwcmVzc2lvbiBoYXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LlxuICovXG5mdW5jdGlvbiBpc0ludm9rZU5vZGUobm9kZTogQXN0Q2FsbFBhcnRzKTogYm9vbGVhbiB7XG4gIHJldHVybiBub2RlLnBhcmFtcy5sZW5ndGggPiAwIHx8IG5vZGUuaGFzaC5wYWlycy5sZW5ndGggPiAwO1xufVxuIiwiaW1wb3J0IHsgUHJlc2VudEFycmF5IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2lnbiwgaXNQcmVzZW50IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmltcG9ydCBQcmludGVyIGZyb20gJy4uL2dlbmVyYXRpb24vcHJpbnRlcic7XG5pbXBvcnQgeyBQcmVjb21waWxlT3B0aW9ucywgcHJlcHJvY2VzcyB9IGZyb20gJy4uL3BhcnNlci90b2tlbml6ZXItZXZlbnQtaGFuZGxlcnMnO1xuaW1wb3J0IHsgU291cmNlTG9jYXRpb24gfSBmcm9tICcuLi9zb3VyY2UvbG9jYXRpb24nO1xuaW1wb3J0IHsgU291cmNlU2xpY2UgfSBmcm9tICcuLi9zb3VyY2Uvc2xpY2UnO1xuaW1wb3J0IHsgU291cmNlIH0gZnJvbSAnLi4vc291cmNlL3NvdXJjZSc7XG5pbXBvcnQgeyBTb3VyY2VTcGFuIH0gZnJvbSAnLi4vc291cmNlL3NwYW4nO1xuaW1wb3J0IHsgU3Bhbkxpc3QgfSBmcm9tICcuLi9zb3VyY2Uvc3Bhbi1saXN0JztcbmltcG9ydCB7IEJsb2NrU3ltYm9sVGFibGUsIFByb2dyYW1TeW1ib2xUYWJsZSwgU3ltYm9sVGFibGUgfSBmcm9tICcuLi9zeW1ib2wtdGFibGUnO1xuaW1wb3J0IHsgZ2VuZXJhdGVTeW50YXhFcnJvciB9IGZyb20gJy4uL3N5bnRheC1lcnJvcic7XG5pbXBvcnQgeyBpc0xvd2VyQ2FzZSwgaXNVcHBlckNhc2UgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgKiBhcyBBU1R2MSBmcm9tICcuLi92MS9hcGknO1xuaW1wb3J0IGIgZnJvbSAnLi4vdjEvcGFyc2VyLWJ1aWxkZXJzJztcbmltcG9ydCAqIGFzIEFTVHYyIGZyb20gJy4vYXBpJztcbmltcG9ydCB7IEJ1aWxkRWxlbWVudCwgQnVpbGRlciwgQ2FsbFBhcnRzIH0gZnJvbSAnLi9idWlsZGVycyc7XG5pbXBvcnQge1xuICBBcHBlbmRTeW50YXhDb250ZXh0LFxuICBBdHRyVmFsdWVTeW50YXhDb250ZXh0LFxuICBCbG9ja1N5bnRheENvbnRleHQsXG4gIENvbXBvbmVudFN5bnRheENvbnRleHQsXG4gIE1vZGlmaWVyU3ludGF4Q29udGV4dCxcbiAgUmVzb2x1dGlvbixcbiAgU2V4cFN5bnRheENvbnRleHQsXG59IGZyb20gJy4vbG9vc2UtcmVzb2x1dGlvbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUoXG4gIHNvdXJjZTogU291cmNlLFxuICBvcHRpb25zOiBQcmVjb21waWxlT3B0aW9ucyA9IHt9XG4pOiBbYXN0OiBBU1R2Mi5UZW1wbGF0ZSwgbG9jYWxzOiBzdHJpbmdbXV0ge1xuICBsZXQgYXN0ID0gcHJlcHJvY2Vzcyhzb3VyY2UsIG9wdGlvbnMpO1xuXG4gIGxldCBub3JtYWxpemVPcHRpb25zID0gYXNzaWduKFxuICAgIHtcbiAgICAgIHN0cmljdE1vZGU6IGZhbHNlLFxuICAgICAgbG9jYWxzOiBbXSxcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcblxuICBsZXQgdG9wID0gU3ltYm9sVGFibGUudG9wKFxuICAgIG5vcm1hbGl6ZU9wdGlvbnMuc3RyaWN0TW9kZSA/IG5vcm1hbGl6ZU9wdGlvbnMubG9jYWxzIDogW10sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgIG9wdGlvbnMuY3VzdG9taXplQ29tcG9uZW50TmFtZSA/PyAoKG5hbWUpID0+IG5hbWUpXG4gICk7XG4gIGxldCBibG9jayA9IG5ldyBCbG9ja0NvbnRleHQoc291cmNlLCBub3JtYWxpemVPcHRpb25zLCB0b3ApO1xuICBsZXQgbm9ybWFsaXplciA9IG5ldyBTdGF0ZW1lbnROb3JtYWxpemVyKGJsb2NrKTtcblxuICBsZXQgYXN0VjIgPSBuZXcgVGVtcGxhdGVDaGlsZHJlbihcbiAgICBibG9jay5sb2MoYXN0LmxvYyksXG4gICAgYXN0LmJvZHkubWFwKChiKSA9PiBub3JtYWxpemVyLm5vcm1hbGl6ZShiKSksXG4gICAgYmxvY2tcbiAgKS5hc3NlcnRUZW1wbGF0ZSh0b3ApO1xuXG4gIGxldCBsb2NhbHMgPSB0b3AuZ2V0VXNlZFRlbXBsYXRlTG9jYWxzKCk7XG5cbiAgcmV0dXJuIFthc3RWMiwgbG9jYWxzXTtcbn1cblxuLyoqXG4gKiBBIGBCbG9ja0NvbnRleHRgIHJlcHJlc2VudHMgdGhlIGJsb2NrIHRoYXQgYSBwYXJ0aWN1bGFyIEFTVCBub2RlIGlzIGNvbnRhaW5lZCBpbnNpZGUgb2YuXG4gKlxuICogYEJsb2NrQ29udGV4dGAgaXMgYXdhcmUgb2YgdGVtcGxhdGUtd2lkZSBvcHRpb25zIChzdWNoIGFzIHN0cmljdCBtb2RlKSwgYXMgd2VsbCBhcyB0aGUgYmluZGluZ3NcbiAqIHRoYXQgYXJlIGluLXNjb3BlIHdpdGhpbiB0aGF0IGJsb2NrLlxuICpcbiAqIENvbmNyZXRlbHksIGl0IGhhcyB0aGUgYFByZWNvbXBpbGVPcHRpb25zYCBhbmQgY3VycmVudCBgU3ltYm9sVGFibGVgLCBhbmQgcHJvdmlkZXNcbiAqIGZhY2lsaXRpZXMgZm9yIHdvcmtpbmcgd2l0aCB0aG9zZSBvcHRpb25zLlxuICpcbiAqIGBCbG9ja0NvbnRleHRgIGlzIHN0YXRlbGVzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrQ29udGV4dDxUYWJsZSBleHRlbmRzIFN5bWJvbFRhYmxlID0gU3ltYm9sVGFibGU+IHtcbiAgcmVhZG9ubHkgYnVpbGRlcjogQnVpbGRlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBzb3VyY2U6IFNvdXJjZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IFByZWNvbXBpbGVPcHRpb25zLFxuICAgIHJlYWRvbmx5IHRhYmxlOiBUYWJsZVxuICApIHtcbiAgICB0aGlzLmJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICB9XG5cbiAgZ2V0IHN0cmljdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN0cmljdE1vZGUgfHwgZmFsc2U7XG4gIH1cblxuICBsb2MobG9jOiBTb3VyY2VMb2NhdGlvbik6IFNvdXJjZVNwYW4ge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5zcGFuRm9yKGxvYyk7XG4gIH1cblxuICByZXNvbHV0aW9uRm9yPE4gZXh0ZW5kcyBBU1R2MS5DYWxsTm9kZSB8IEFTVHYxLlBhdGhFeHByZXNzaW9uPihcbiAgICBub2RlOiBOLFxuICAgIHJlc29sdXRpb246IFJlc29sdXRpb248Tj5cbiAgKTogeyByZXNvbHV0aW9uOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbiB9IHwgeyByZXNvbHV0aW9uOiAnZXJyb3InOyBwYXRoOiBzdHJpbmc7IGhlYWQ6IHN0cmluZyB9IHtcbiAgICBpZiAodGhpcy5zdHJpY3QpIHtcbiAgICAgIHJldHVybiB7IHJlc29sdXRpb246IEFTVHYyLlNUUklDVF9SRVNPTFVUSU9OIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNGcmVlVmFyKG5vZGUpKSB7XG4gICAgICBsZXQgciA9IHJlc29sdXRpb24obm9kZSk7XG5cbiAgICAgIGlmIChyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzb2x1dGlvbjogJ2Vycm9yJyxcbiAgICAgICAgICBwYXRoOiBwcmludFBhdGgobm9kZSksXG4gICAgICAgICAgaGVhZDogcHJpbnRIZWFkKG5vZGUpLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyByZXNvbHV0aW9uOiByIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHJlc29sdXRpb246IEFTVHYyLlNUUklDVF9SRVNPTFVUSU9OIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpc0ZyZWVWYXIoY2FsbGVlOiBBU1R2MS5DYWxsTm9kZSB8IEFTVHYxLlBhdGhFeHByZXNzaW9uKTogYm9vbGVhbiB7XG4gICAgaWYgKGNhbGxlZS50eXBlID09PSAnUGF0aEV4cHJlc3Npb24nKSB7XG4gICAgICBpZiAoY2FsbGVlLmhlYWQudHlwZSAhPT0gJ1ZhckhlYWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICF0aGlzLnRhYmxlLmhhcyhjYWxsZWUuaGVhZC5uYW1lKTtcbiAgICB9IGVsc2UgaWYgKGNhbGxlZS5wYXRoLnR5cGUgPT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRnJlZVZhcihjYWxsZWUucGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBoYXNCaW5kaW5nKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnRhYmxlLmhhcyhuYW1lKTtcbiAgfVxuXG4gIGNoaWxkKGJsb2NrUGFyYW1zOiBzdHJpbmdbXSk6IEJsb2NrQ29udGV4dDxCbG9ja1N5bWJvbFRhYmxlPiB7XG4gICAgcmV0dXJuIG5ldyBCbG9ja0NvbnRleHQodGhpcy5zb3VyY2UsIHRoaXMub3B0aW9ucywgdGhpcy50YWJsZS5jaGlsZChibG9ja1BhcmFtcykpO1xuICB9XG5cbiAgY3VzdG9taXplQ29tcG9uZW50TmFtZShpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmN1c3RvbWl6ZUNvbXBvbmVudE5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY3VzdG9taXplQ29tcG9uZW50TmFtZShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBgRXhwcmVzc2lvbk5vcm1hbGl6ZXJgIG5vcm1hbGl6ZXMgZXhwcmVzc2lvbnMgd2l0aGluIGEgYmxvY2suXG4gKlxuICogYEV4cHJlc3Npb25Ob3JtYWxpemVyYCBpcyBzdGF0ZWxlc3MuXG4gKi9cbmNsYXNzIEV4cHJlc3Npb25Ob3JtYWxpemVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBibG9jazogQmxvY2tDb250ZXh0KSB7fVxuXG4gIC8qKlxuICAgKiBUaGUgYG5vcm1hbGl6ZWAgbWV0aG9kIHRha2VzIGFuIGFyYml0cmFyeSBleHByZXNzaW9uIGFuZCBpdHMgb3JpZ2luYWwgc3ludGF4IGNvbnRleHQgYW5kXG4gICAqIG5vcm1hbGl6ZXMgaXQgdG8gYW4gQVNUdjIgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogQHNlZSB7U3ludGF4Q29udGV4dH1cbiAgICovXG4gIG5vcm1hbGl6ZShleHByOiBBU1R2MS5MaXRlcmFsLCByZXNvbHV0aW9uOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbik6IEFTVHYyLkxpdGVyYWxFeHByZXNzaW9uO1xuICBub3JtYWxpemUoXG4gICAgZXhwcjogQVNUdjEuTWluaW1hbFBhdGhFeHByZXNzaW9uLFxuICAgIHJlc29sdXRpb246IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uXG4gICk6IEFTVHYyLlBhdGhFeHByZXNzaW9uO1xuICBub3JtYWxpemUoZXhwcjogQVNUdjEuU3ViRXhwcmVzc2lvbiwgcmVzb2x1dGlvbjogQVNUdjIuRnJlZVZhclJlc29sdXRpb24pOiBBU1R2Mi5DYWxsRXhwcmVzc2lvbjtcbiAgbm9ybWFsaXplKGV4cHI6IEFTVHYxLkV4cHJlc3Npb24sIHJlc29sdXRpb246IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uKTogQVNUdjIuRXhwcmVzc2lvbk5vZGU7XG4gIG5vcm1hbGl6ZShcbiAgICBleHByOiBBU1R2MS5FeHByZXNzaW9uIHwgQVNUdjEuTWluaW1hbFBhdGhFeHByZXNzaW9uLFxuICAgIHJlc29sdXRpb246IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uXG4gICk6IEFTVHYyLkV4cHJlc3Npb25Ob2RlIHtcbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgY2FzZSAnTnVsbExpdGVyYWwnOlxuICAgICAgY2FzZSAnQm9vbGVhbkxpdGVyYWwnOlxuICAgICAgY2FzZSAnTnVtYmVyTGl0ZXJhbCc6XG4gICAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzpcbiAgICAgIGNhc2UgJ1VuZGVmaW5lZExpdGVyYWwnOlxuICAgICAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLmxpdGVyYWwoZXhwci52YWx1ZSwgdGhpcy5ibG9jay5sb2MoZXhwci5sb2MpKTtcbiAgICAgIGNhc2UgJ1BhdGhFeHByZXNzaW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aChleHByLCByZXNvbHV0aW9uKTtcbiAgICAgIGNhc2UgJ1N1YkV4cHJlc3Npb24nOiB7XG4gICAgICAgIGxldCByZXNvbHV0aW9uID0gdGhpcy5ibG9jay5yZXNvbHV0aW9uRm9yKGV4cHIsIFNleHBTeW50YXhDb250ZXh0KTtcblxuICAgICAgICBpZiAocmVzb2x1dGlvbi5yZXNvbHV0aW9uID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICAgIGBZb3UgYXR0ZW1wdGVkIHRvIGludm9rZSBhIHBhdGggKFxcYCR7cmVzb2x1dGlvbi5wYXRofVxcYCkgYnV0ICR7cmVzb2x1dGlvbi5oZWFkfSB3YXMgbm90IGluIHNjb3BlYCxcbiAgICAgICAgICAgIGV4cHIubG9jXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrLmJ1aWxkZXIuc2V4cChcbiAgICAgICAgICB0aGlzLmNhbGxQYXJ0cyhleHByLCByZXNvbHV0aW9uLnJlc29sdXRpb24pLFxuICAgICAgICAgIHRoaXMuYmxvY2subG9jKGV4cHIubG9jKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGF0aChcbiAgICBleHByOiBBU1R2MS5NaW5pbWFsUGF0aEV4cHJlc3Npb24sXG4gICAgcmVzb2x1dGlvbjogQVNUdjIuRnJlZVZhclJlc29sdXRpb25cbiAgKTogQVNUdjIuUGF0aEV4cHJlc3Npb24ge1xuICAgIGxldCBoZWFkT2Zmc2V0cyA9IHRoaXMuYmxvY2subG9jKGV4cHIuaGVhZC5sb2MpO1xuXG4gICAgbGV0IHRhaWwgPSBbXTtcblxuICAgIC8vIHN0YXJ0IHdpdGggdGhlIGhlYWRcbiAgICBsZXQgb2Zmc2V0ID0gaGVhZE9mZnNldHM7XG5cbiAgICBmb3IgKGxldCBwYXJ0IG9mIGV4cHIudGFpbCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0LnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiBwYXJ0Lmxlbmd0aCwgc2tpcFN0YXJ0OiAxIH0pO1xuICAgICAgdGFpbC5wdXNoKFxuICAgICAgICBuZXcgU291cmNlU2xpY2Uoe1xuICAgICAgICAgIGxvYzogb2Zmc2V0LFxuICAgICAgICAgIGNoYXJzOiBwYXJ0LFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLnBhdGgodGhpcy5yZWYoZXhwci5oZWFkLCByZXNvbHV0aW9uKSwgdGFpbCwgdGhpcy5ibG9jay5sb2MoZXhwci5sb2MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYGNhbGxQYXJ0c2AgbWV0aG9kIHRha2VzIEFTVHYxLkNhbGxQYXJ0cyBhcyB3ZWxsIGFzIGEgc3ludGF4IGNvbnRleHQgYW5kIG5vcm1hbGl6ZXNcbiAgICogaXQgdG8gYW4gQVNUdjIgQ2FsbFBhcnRzLlxuICAgKi9cbiAgY2FsbFBhcnRzKHBhcnRzOiBBU1R2MS5DYWxsUGFydHMsIGNvbnRleHQ6IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uKTogQ2FsbFBhcnRzIHtcbiAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IHBhcnRzO1xuXG4gICAgbGV0IGNhbGxlZSA9IHRoaXMubm9ybWFsaXplKHBhdGgsIGNvbnRleHQpO1xuICAgIGxldCBwYXJhbUxpc3QgPSBwYXJhbXMubWFwKChwKSA9PiB0aGlzLm5vcm1hbGl6ZShwLCBBU1R2Mi5BUkdVTUVOVF9SRVNPTFVUSU9OKSk7XG4gICAgbGV0IHBhcmFtTG9jID0gU3Bhbkxpc3QucmFuZ2UocGFyYW1MaXN0LCBjYWxsZWUubG9jLmNvbGxhcHNlKCdlbmQnKSk7XG4gICAgbGV0IG5hbWVkTG9jID0gdGhpcy5ibG9jay5sb2MoaGFzaC5sb2MpO1xuICAgIGxldCBhcmdzTG9jID0gU3Bhbkxpc3QucmFuZ2UoW3BhcmFtTG9jLCBuYW1lZExvY10pO1xuXG4gICAgbGV0IHBvc2l0aW9uYWwgPSB0aGlzLmJsb2NrLmJ1aWxkZXIucG9zaXRpb25hbChcbiAgICAgIHBhcmFtcy5tYXAoKHApID0+IHRoaXMubm9ybWFsaXplKHAsIEFTVHYyLkFSR1VNRU5UX1JFU09MVVRJT04pKSxcbiAgICAgIHBhcmFtTG9jXG4gICAgKTtcblxuICAgIGxldCBuYW1lZCA9IHRoaXMuYmxvY2suYnVpbGRlci5uYW1lZChcbiAgICAgIGhhc2gucGFpcnMubWFwKChwKSA9PiB0aGlzLm5hbWVkQXJndW1lbnQocCkpLFxuICAgICAgdGhpcy5ibG9jay5sb2MoaGFzaC5sb2MpXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBjYWxsZWUsXG4gICAgICBhcmdzOiB0aGlzLmJsb2NrLmJ1aWxkZXIuYXJncyhwb3NpdGlvbmFsLCBuYW1lZCwgYXJnc0xvYyksXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgbmFtZWRBcmd1bWVudChwYWlyOiBBU1R2MS5IYXNoUGFpcik6IEFTVHYyLk5hbWVkQXJndW1lbnQge1xuICAgIGxldCBvZmZzZXRzID0gdGhpcy5ibG9jay5sb2MocGFpci5sb2MpO1xuXG4gICAgbGV0IGtleU9mZnNldHMgPSBvZmZzZXRzLnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiBwYWlyLmtleS5sZW5ndGggfSk7XG5cbiAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLm5hbWVkQXJndW1lbnQoXG4gICAgICBuZXcgU291cmNlU2xpY2UoeyBjaGFyczogcGFpci5rZXksIGxvYzoga2V5T2Zmc2V0cyB9KSxcbiAgICAgIHRoaXMubm9ybWFsaXplKHBhaXIudmFsdWUsIEFTVHYyLkFSR1VNRU5UX1JFU09MVVRJT04pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYHJlZmAgbWV0aG9kIG5vcm1hbGl6ZXMgYW4gYEFTVHYxLlBhdGhIZWFkYCBpbnRvIGFuIGBBU1R2Mi5WYXJpYWJsZVJlZmVyZW5jZWAuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGV4dHJlbWVseSBpbXBvcnRhbnQsIGJlY2F1c2UgaXQgaXMgcmVzcG9uc2libGUgZm9yIG5vcm1hbGl6aW5nIGZyZWVcbiAgICogdmFyaWFibGVzIGludG8gYW4gYW4gQVNUdjIuUGF0aEhlYWQgKndpdGggYXBwcm9wcmlhdGUgY29udGV4dCouXG4gICAqXG4gICAqIFRoZSBzeW50YXggY29udGV4dCBpcyBvcmlnaW5hbGx5IGRldGVybWluZWQgYnkgdGhlIHN5bnRhY3RpYyBwb3NpdGlvbiB0aGF0IHRoaXMgYFBhdGhIZWFkYFxuICAgKiBjYW1lIGZyb20sIGFuZCBpcyB1bHRpbWF0ZWx5IGF0dGFjaGVkIHRvIHRoZSBgQVNUdjIuVmFyaWFibGVSZWZlcmVuY2VgIGhlcmUuIEluIEFTVHYyLFxuICAgKiB0aGUgYFZhcmlhYmxlUmVmZXJlbmNlYCBub2RlIGJlYXJzIGZ1bGwgcmVzcG9uc2liaWxpdHkgZm9yIGxvb3NlIG1vZGUgcnVsZXMgdGhhdCBjb250cm9sXG4gICAqIHRoZSBiZWhhdmlvciBvZiBmcmVlIHZhcmlhYmxlcy5cbiAgICovXG4gIHByaXZhdGUgcmVmKGhlYWQ6IEFTVHYxLlBhdGhIZWFkLCByZXNvbHV0aW9uOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbik6IEFTVHYyLlZhcmlhYmxlUmVmZXJlbmNlIHtcbiAgICBsZXQgeyBibG9jayB9ID0gdGhpcztcbiAgICBsZXQgeyBidWlsZGVyLCB0YWJsZSB9ID0gYmxvY2s7XG4gICAgbGV0IG9mZnNldHMgPSBibG9jay5sb2MoaGVhZC5sb2MpO1xuXG4gICAgc3dpdGNoIChoZWFkLnR5cGUpIHtcbiAgICAgIGNhc2UgJ1RoaXNIZWFkJzpcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuc2VsZihvZmZzZXRzKTtcbiAgICAgIGNhc2UgJ0F0SGVhZCc6IHtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHRhYmxlLmFsbG9jYXRlTmFtZWQoaGVhZC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuYXQoaGVhZC5uYW1lLCBzeW1ib2wsIG9mZnNldHMpO1xuICAgICAgfVxuICAgICAgY2FzZSAnVmFySGVhZCc6IHtcbiAgICAgICAgaWYgKGJsb2NrLmhhc0JpbmRpbmcoaGVhZC5uYW1lKSkge1xuICAgICAgICAgIGxldCBbc3ltYm9sLCBpc1Jvb3RdID0gdGFibGUuZ2V0KGhlYWQubmFtZSk7XG5cbiAgICAgICAgICByZXR1cm4gYmxvY2suYnVpbGRlci5sb2NhbFZhcihoZWFkLm5hbWUsIHN5bWJvbCwgaXNSb290LCBvZmZzZXRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgY29udGV4dCA9IGJsb2NrLnN0cmljdCA/IEFTVHYyLlNUUklDVF9SRVNPTFVUSU9OIDogcmVzb2x1dGlvbjtcbiAgICAgICAgICBsZXQgc3ltYm9sID0gYmxvY2sudGFibGUuYWxsb2NhdGVGcmVlKGhlYWQubmFtZSwgY29udGV4dCk7XG5cbiAgICAgICAgICByZXR1cm4gYmxvY2suYnVpbGRlci5mcmVlVmFyKHtcbiAgICAgICAgICAgIG5hbWU6IGhlYWQubmFtZSxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBzeW1ib2wsXG4gICAgICAgICAgICBsb2M6IG9mZnNldHMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBgVGVtcGxhdGVOb3JtYWxpemVyYCBub3JtYWxpemVzIHRvcC1sZXZlbCBBU1R2MSBzdGF0ZW1lbnRzIHRvIEFTVHYyLlxuICovXG5jbGFzcyBTdGF0ZW1lbnROb3JtYWxpemVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBibG9jazogQmxvY2tDb250ZXh0KSB7fVxuXG4gIG5vcm1hbGl6ZShub2RlOiBBU1R2MS5TdGF0ZW1lbnQpOiBBU1R2Mi5Db250ZW50Tm9kZSB8IEFTVHYyLk5hbWVkQmxvY2sge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlICdQYXJ0aWFsU3RhdGVtZW50JzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIYW5kbGViYXJzIHBhcnRpYWwgc3ludGF4ICh7ez4gLi4ufX0pIGlzIG5vdCBhbGxvd2VkIGluIEdsaW1tZXJgKTtcbiAgICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuQmxvY2tTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlICdFbGVtZW50Tm9kZSc6XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudE5vcm1hbGl6ZXIodGhpcy5ibG9jaykuRWxlbWVudE5vZGUobm9kZSk7XG4gICAgICBjYXNlICdNdXN0YWNoZVN0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLk11c3RhY2hlU3RhdGVtZW50KG5vZGUpO1xuXG4gICAgICAvLyBUaGVzZSBhcmUgdGhlIHNhbWUgaW4gQVNUdjJcbiAgICAgIGNhc2UgJ011c3RhY2hlQ29tbWVudFN0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudChub2RlKTtcblxuICAgICAgY2FzZSAnQ29tbWVudFN0YXRlbWVudCc6IHtcbiAgICAgICAgbGV0IGxvYyA9IHRoaXMuYmxvY2subG9jKG5vZGUubG9jKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1R2Mi5IdG1sQ29tbWVudCh7XG4gICAgICAgICAgbG9jLFxuICAgICAgICAgIHRleHQ6IGxvYy5zbGljZSh7IHNraXBTdGFydDogNCwgc2tpcEVuZDogMyB9KS50b1NsaWNlKG5vZGUudmFsdWUpLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2FzZSAnVGV4dE5vZGUnOlxuICAgICAgICByZXR1cm4gbmV3IEFTVHYyLkh0bWxUZXh0KHtcbiAgICAgICAgICBsb2M6IHRoaXMuYmxvY2subG9jKG5vZGUubG9jKSxcbiAgICAgICAgICBjaGFyczogbm9kZS5jaGFycyxcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgTXVzdGFjaGVDb21tZW50U3RhdGVtZW50KG5vZGU6IEFTVHYxLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudCk6IEFTVHYyLkdsaW1tZXJDb21tZW50IHtcbiAgICBsZXQgbG9jID0gdGhpcy5ibG9jay5sb2Mobm9kZS5sb2MpO1xuICAgIGxldCB0ZXh0TG9jOiBTb3VyY2VTcGFuO1xuXG4gICAgaWYgKGxvYy5hc1N0cmluZygpLnNsaWNlKDAsIDUpID09PSAne3shLS0nKSB7XG4gICAgICB0ZXh0TG9jID0gbG9jLnNsaWNlKHsgc2tpcFN0YXJ0OiA1LCBza2lwRW5kOiA0IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0TG9jID0gbG9jLnNsaWNlKHsgc2tpcFN0YXJ0OiAzLCBza2lwRW5kOiAyIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQVNUdjIuR2xpbW1lckNvbW1lbnQoe1xuICAgICAgbG9jLFxuICAgICAgdGV4dDogdGV4dExvYy50b1NsaWNlKG5vZGUudmFsdWUpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgYW4gQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgdG8gYW4gQVNUdjIuQXBwZW5kU3RhdGVtZW50XG4gICAqL1xuICBNdXN0YWNoZVN0YXRlbWVudChtdXN0YWNoZTogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQpOiBBU1R2Mi5BcHBlbmRDb250ZW50IHtcbiAgICBsZXQgeyBlc2NhcGVkIH0gPSBtdXN0YWNoZTtcbiAgICBsZXQgbG9jID0gdGhpcy5ibG9jay5sb2MobXVzdGFjaGUubG9jKTtcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgY2FsbCBwYXJ0cyBpbiBBcHBlbmRTeW50YXhDb250ZXh0XG4gICAgbGV0IGNhbGxQYXJ0cyA9IHRoaXMuZXhwci5jYWxsUGFydHMoXG4gICAgICB7XG4gICAgICAgIHBhdGg6IG11c3RhY2hlLnBhdGgsXG4gICAgICAgIHBhcmFtczogbXVzdGFjaGUucGFyYW1zLFxuICAgICAgICBoYXNoOiBtdXN0YWNoZS5oYXNoLFxuICAgICAgfSxcbiAgICAgIEFwcGVuZFN5bnRheENvbnRleHQobXVzdGFjaGUpXG4gICAgKTtcblxuICAgIGxldCB2YWx1ZSA9IGNhbGxQYXJ0cy5hcmdzLmlzRW1wdHkoKVxuICAgICAgPyBjYWxsUGFydHMuY2FsbGVlXG4gICAgICA6IHRoaXMuYmxvY2suYnVpbGRlci5zZXhwKGNhbGxQYXJ0cywgbG9jKTtcblxuICAgIHJldHVybiB0aGlzLmJsb2NrLmJ1aWxkZXIuYXBwZW5kKFxuICAgICAge1xuICAgICAgICB0YWJsZTogdGhpcy5ibG9jay50YWJsZSxcbiAgICAgICAgdHJ1c3Rpbmc6ICFlc2NhcGVkLFxuICAgICAgICB2YWx1ZSxcbiAgICAgIH0sXG4gICAgICBsb2NcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgYSBBU1R2MS5CbG9ja1N0YXRlbWVudCB0byBhbiBBU1R2Mi5CbG9ja1N0YXRlbWVudFxuICAgKi9cbiAgQmxvY2tTdGF0ZW1lbnQoYmxvY2s6IEFTVHYxLkJsb2NrU3RhdGVtZW50KTogQVNUdjIuSW52b2tlQmxvY2sge1xuICAgIGxldCB7IHByb2dyYW0sIGludmVyc2UgfSA9IGJsb2NrO1xuICAgIGxldCBsb2MgPSB0aGlzLmJsb2NrLmxvYyhibG9jay5sb2MpO1xuXG4gICAgbGV0IHJlc29sdXRpb24gPSB0aGlzLmJsb2NrLnJlc29sdXRpb25Gb3IoYmxvY2ssIEJsb2NrU3ludGF4Q29udGV4dCk7XG5cbiAgICBpZiAocmVzb2x1dGlvbi5yZXNvbHV0aW9uID09PSAnZXJyb3InKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgWW91IGF0dGVtcHRlZCB0byBpbnZva2UgYSBwYXRoIChcXGB7eyMke3Jlc29sdXRpb24ucGF0aH19fVxcYCkgYnV0ICR7cmVzb2x1dGlvbi5oZWFkfSB3YXMgbm90IGluIHNjb3BlYCxcbiAgICAgICAgbG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBjYWxsUGFydHMgPSB0aGlzLmV4cHIuY2FsbFBhcnRzKGJsb2NrLCByZXNvbHV0aW9uLnJlc29sdXRpb24pO1xuXG4gICAgcmV0dXJuIHRoaXMuYmxvY2suYnVpbGRlci5ibG9ja1N0YXRlbWVudChcbiAgICAgIGFzc2lnbihcbiAgICAgICAge1xuICAgICAgICAgIHN5bWJvbHM6IHRoaXMuYmxvY2sudGFibGUsXG4gICAgICAgICAgcHJvZ3JhbTogdGhpcy5CbG9jayhwcm9ncmFtKSxcbiAgICAgICAgICBpbnZlcnNlOiBpbnZlcnNlID8gdGhpcy5CbG9jayhpbnZlcnNlKSA6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxQYXJ0c1xuICAgICAgKSxcbiAgICAgIGxvY1xuICAgICk7XG4gIH1cblxuICBCbG9jayh7IGJvZHksIGxvYywgYmxvY2tQYXJhbXMgfTogQVNUdjEuQmxvY2spOiBBU1R2Mi5CbG9jayB7XG4gICAgbGV0IGNoaWxkID0gdGhpcy5ibG9jay5jaGlsZChibG9ja1BhcmFtcyk7XG4gICAgbGV0IG5vcm1hbGl6ZXIgPSBuZXcgU3RhdGVtZW50Tm9ybWFsaXplcihjaGlsZCk7XG4gICAgcmV0dXJuIG5ldyBCbG9ja0NoaWxkcmVuKFxuICAgICAgdGhpcy5ibG9jay5sb2MobG9jKSxcbiAgICAgIGJvZHkubWFwKChiKSA9PiBub3JtYWxpemVyLm5vcm1hbGl6ZShiKSksXG4gICAgICB0aGlzLmJsb2NrXG4gICAgKS5hc3NlcnRCbG9jayhjaGlsZC50YWJsZSk7XG4gIH1cblxuICBwcml2YXRlIGdldCBleHByKCk6IEV4cHJlc3Npb25Ob3JtYWxpemVyIHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25Ob3JtYWxpemVyKHRoaXMuYmxvY2spO1xuICB9XG59XG5cbmNsYXNzIEVsZW1lbnROb3JtYWxpemVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjdHg6IEJsb2NrQ29udGV4dCkge31cblxuICAvKipcbiAgICogTm9ybWFsaXplcyBhbiBBU1R2MS5FbGVtZW50Tm9kZSB0bzpcbiAgICpcbiAgICogLSBBU1R2Mi5OYW1lZEJsb2NrIGlmIHRoZSB0YWcgbmFtZSBiZWdpbnMgd2l0aCBgOmBcbiAgICogLSBBU1R2Mi5Db21wb25lbnQgaWYgdGhlIHRhZyBuYW1lIG1hdGNoZXMgdGhlIGNvbXBvbmVudCBoZXVyaXN0aWNzXG4gICAqIC0gQVNUdjIuU2ltcGxlRWxlbWVudCBpZiB0aGUgdGFnIG5hbWUgZG9lc24ndCBtYXRjaCB0aGUgY29tcG9uZW50IGhldXJpc3RpY3NcbiAgICpcbiAgICogQSB0YWcgbmFtZSByZXByZXNlbnRzIGEgY29tcG9uZW50IGlmOlxuICAgKlxuICAgKiAtIGl0IGJlZ2lucyB3aXRoIGBAYFxuICAgKiAtIGl0IGlzIGV4YWN0bHkgYHRoaXNgIG9yIGJlZ2lucyB3aXRoIGB0aGlzLmBcbiAgICogLSB0aGUgcGFydCBiZWZvcmUgdGhlIGZpcnN0IGAuYCBpcyBhIHJlZmVyZW5jZSB0byBhbiBpbi1zY29wZSB2YXJpYWJsZSBiaW5kaW5nXG4gICAqIC0gaXQgYmVnaW5zIHdpdGggYW4gdXBwZXJjYXNlIGNoYXJhY3RlclxuICAgKi9cbiAgRWxlbWVudE5vZGUoZWxlbWVudDogQVNUdjEuRWxlbWVudE5vZGUpOiBBU1R2Mi5FbGVtZW50Tm9kZSB7XG4gICAgbGV0IHsgdGFnLCBzZWxmQ2xvc2luZywgY29tbWVudHMgfSA9IGVsZW1lbnQ7XG4gICAgbGV0IGxvYyA9IHRoaXMuY3R4LmxvYyhlbGVtZW50LmxvYyk7XG5cbiAgICBsZXQgW3RhZ0hlYWQsIC4uLnJlc3RdID0gdGFnLnNwbGl0KCcuJyk7XG5cbiAgICAvLyB0aGUgaGVhZCwgYXR0cmlidXRlcyBhbmQgbW9kaWZpZXJzIGFyZSBpbiB0aGUgY3VycmVudCBzY29wZVxuICAgIGxldCBwYXRoID0gdGhpcy5jbGFzc2lmeVRhZyh0YWdIZWFkLCByZXN0LCBlbGVtZW50LmxvYyk7XG5cbiAgICBsZXQgYXR0cnMgPSBlbGVtZW50LmF0dHJpYnV0ZXMuZmlsdGVyKChhKSA9PiBhLm5hbWVbMF0gIT09ICdAJykubWFwKChhKSA9PiB0aGlzLmF0dHIoYSkpO1xuICAgIGxldCBhcmdzID0gZWxlbWVudC5hdHRyaWJ1dGVzLmZpbHRlcigoYSkgPT4gYS5uYW1lWzBdID09PSAnQCcpLm1hcCgoYSkgPT4gdGhpcy5hcmcoYSkpO1xuXG4gICAgbGV0IG1vZGlmaWVycyA9IGVsZW1lbnQubW9kaWZpZXJzLm1hcCgobSkgPT4gdGhpcy5tb2RpZmllcihtKSk7XG5cbiAgICAvLyB0aGUgZWxlbWVudCdzIGJsb2NrIHBhcmFtcyBhcmUgaW4gc2NvcGUgZm9yIHRoZSBjaGlsZHJlblxuICAgIGxldCBjaGlsZCA9IHRoaXMuY3R4LmNoaWxkKGVsZW1lbnQuYmxvY2tQYXJhbXMpO1xuICAgIGxldCBub3JtYWxpemVyID0gbmV3IFN0YXRlbWVudE5vcm1hbGl6ZXIoY2hpbGQpO1xuXG4gICAgbGV0IGNoaWxkTm9kZXMgPSBlbGVtZW50LmNoaWxkcmVuLm1hcCgocykgPT4gbm9ybWFsaXplci5ub3JtYWxpemUocykpO1xuXG4gICAgbGV0IGVsID0gdGhpcy5jdHguYnVpbGRlci5lbGVtZW50KHtcbiAgICAgIHNlbGZDbG9zaW5nLFxuICAgICAgYXR0cnMsXG4gICAgICBjb21wb25lbnRBcmdzOiBhcmdzLFxuICAgICAgbW9kaWZpZXJzLFxuICAgICAgY29tbWVudHM6IGNvbW1lbnRzLm1hcCgoYykgPT4gbmV3IFN0YXRlbWVudE5vcm1hbGl6ZXIodGhpcy5jdHgpLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudChjKSksXG4gICAgfSk7XG5cbiAgICBsZXQgY2hpbGRyZW4gPSBuZXcgRWxlbWVudENoaWxkcmVuKGVsLCBsb2MsIGNoaWxkTm9kZXMsIHRoaXMuY3R4KTtcblxuICAgIGxldCBvZmZzZXRzID0gdGhpcy5jdHgubG9jKGVsZW1lbnQubG9jKTtcbiAgICBsZXQgdGFnT2Zmc2V0cyA9IG9mZnNldHMuc2xpY2VTdGFydENoYXJzKHsgY2hhcnM6IHRhZy5sZW5ndGgsIHNraXBTdGFydDogMSB9KTtcblxuICAgIGlmIChwYXRoID09PSAnRWxlbWVudEhlYWQnKSB7XG4gICAgICBpZiAodGFnWzBdID09PSAnOicpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuLmFzc2VydE5hbWVkQmxvY2soXG4gICAgICAgICAgdGFnT2Zmc2V0cy5zbGljZSh7IHNraXBTdGFydDogMSB9KS50b1NsaWNlKHRhZy5zbGljZSgxKSksXG4gICAgICAgICAgY2hpbGQudGFibGVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5hc3NlcnRFbGVtZW50KHRhZ09mZnNldHMudG9TbGljZSh0YWcpLCBlbGVtZW50LmJsb2NrUGFyYW1zLmxlbmd0aCA+IDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnNlbGZDbG9zaW5nKSB7XG4gICAgICByZXR1cm4gZWwuc2VsZkNsb3NpbmdDb21wb25lbnQocGF0aCwgbG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGJsb2NrcyA9IGNoaWxkcmVuLmFzc2VydENvbXBvbmVudCh0YWcsIGNoaWxkLnRhYmxlLCBlbGVtZW50LmJsb2NrUGFyYW1zLmxlbmd0aCA+IDApO1xuICAgICAgcmV0dXJuIGVsLmNvbXBvbmVudFdpdGhOYW1lZEJsb2NrcyhwYXRoLCBibG9ja3MsIGxvYyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBtb2RpZmllcihtOiBBU1R2MS5FbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnQpOiBBU1R2Mi5FbGVtZW50TW9kaWZpZXIge1xuICAgIGxldCByZXNvbHV0aW9uID0gdGhpcy5jdHgucmVzb2x1dGlvbkZvcihtLCBNb2RpZmllclN5bnRheENvbnRleHQpO1xuXG4gICAgaWYgKHJlc29sdXRpb24ucmVzb2x1dGlvbiA9PT0gJ2Vycm9yJykge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYFlvdSBhdHRlbXB0ZWQgdG8gaW52b2tlIGEgcGF0aCAoXFxge3sjJHtyZXNvbHV0aW9uLnBhdGh9fX1cXGApIGFzIGEgbW9kaWZpZXIsIGJ1dCAke3Jlc29sdXRpb24uaGVhZH0gd2FzIG5vdCBpbiBzY29wZS4gVHJ5IGFkZGluZyBcXGB0aGlzXFxgIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhdGhgLFxuICAgICAgICBtLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgY2FsbFBhcnRzID0gdGhpcy5leHByLmNhbGxQYXJ0cyhtLCByZXNvbHV0aW9uLnJlc29sdXRpb24pO1xuICAgIHJldHVybiB0aGlzLmN0eC5idWlsZGVyLm1vZGlmaWVyKGNhbGxQYXJ0cywgdGhpcy5jdHgubG9jKG0ubG9jKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaGFuZGxlcyBhdHRyaWJ1dGUgdmFsdWVzIHRoYXQgYXJlIGN1cmxpZXMsIGFzIHdlbGwgYXMgY3VybGllcyBuZXN0ZWQgaW5zaWRlIG9mXG4gICAqIGludGVycG9sYXRpb25zOlxuICAgKlxuICAgKiBgYGBoYnNcbiAgICogPGEgaHJlZj17e3VybH19IC8+XG4gICAqIDxhIGhyZWY9XCJ7e3VybH19Lmh0bWxcIiAvPlxuICAgKiBgYGBcbiAgICovXG4gIHByaXZhdGUgbXVzdGFjaGVBdHRyKG11c3RhY2hlOiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCk6IEFTVHYyLkV4cHJlc3Npb25Ob2RlIHtcbiAgICAvLyBOb3JtYWxpemUgdGhlIGNhbGwgcGFydHMgaW4gQXR0clZhbHVlU3ludGF4Q29udGV4dFxuICAgIGxldCBzZXhwID0gdGhpcy5jdHguYnVpbGRlci5zZXhwKFxuICAgICAgdGhpcy5leHByLmNhbGxQYXJ0cyhtdXN0YWNoZSwgQXR0clZhbHVlU3ludGF4Q29udGV4dChtdXN0YWNoZSkpLFxuICAgICAgdGhpcy5jdHgubG9jKG11c3RhY2hlLmxvYylcbiAgICApO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBhcmFtcyBvciBoYXNoLCBqdXN0IHJldHVybiB0aGUgZnVuY3Rpb24gcGFydCBhcyBpdHMgb3duIGV4cHJlc3Npb25cbiAgICBpZiAoc2V4cC5hcmdzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHNleHAuY2FsbGVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2V4cDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogYXR0clBhcnQgaXMgdGhlIG5hcnJvd2VkIGRvd24gbGlzdCBvZiB2YWxpZCBhdHRyaWJ1dGUgdmFsdWVzIHRoYXQgYXJlIGFsc29cbiAgICogYWxsb3dlZCBhcyBhIGNvbmNhdCBwYXJ0ICh5b3UgY2FuJ3QgbmVzdCBjb25jYXRzKS5cbiAgICovXG4gIHByaXZhdGUgYXR0clBhcnQoXG4gICAgcGFydDogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1R2MS5UZXh0Tm9kZVxuICApOiB7IGV4cHI6IEFTVHYyLkV4cHJlc3Npb25Ob2RlOyB0cnVzdGluZzogYm9vbGVhbiB9IHtcbiAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgY2FzZSAnTXVzdGFjaGVTdGF0ZW1lbnQnOlxuICAgICAgICByZXR1cm4geyBleHByOiB0aGlzLm11c3RhY2hlQXR0cihwYXJ0KSwgdHJ1c3Rpbmc6ICFwYXJ0LmVzY2FwZWQgfTtcbiAgICAgIGNhc2UgJ1RleHROb2RlJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHByOiB0aGlzLmN0eC5idWlsZGVyLmxpdGVyYWwocGFydC5jaGFycywgdGhpcy5jdHgubG9jKHBhcnQubG9jKSksXG4gICAgICAgICAgdHJ1c3Rpbmc6IHRydWUsXG4gICAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhdHRyVmFsdWUoXG4gICAgcGFydDogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1R2MS5UZXh0Tm9kZSB8IEFTVHYxLkNvbmNhdFN0YXRlbWVudFxuICApOiB7IGV4cHI6IEFTVHYyLkV4cHJlc3Npb25Ob2RlOyB0cnVzdGluZzogYm9vbGVhbiB9IHtcbiAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgY2FzZSAnQ29uY2F0U3RhdGVtZW50Jzoge1xuICAgICAgICBsZXQgcGFydHMgPSBwYXJ0LnBhcnRzLm1hcCgocCkgPT4gdGhpcy5hdHRyUGFydChwKS5leHByKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHByOiB0aGlzLmN0eC5idWlsZGVyLmludGVycG9sYXRlKHBhcnRzLCB0aGlzLmN0eC5sb2MocGFydC5sb2MpKSxcbiAgICAgICAgICB0cnVzdGluZzogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyUGFydChwYXJ0KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGF0dHIobTogQVNUdjEuQXR0ck5vZGUpOiBBU1R2Mi5IdG1sT3JTcGxhdEF0dHIge1xuICAgIGFzc2VydChtLm5hbWVbMF0gIT09ICdAJywgJ0FuIGF0dHIgbmFtZSBtdXN0IG5vdCBzdGFydCB3aXRoIGBAYCcpO1xuXG4gICAgaWYgKG0ubmFtZSA9PT0gJy4uLmF0dHJpYnV0ZXMnKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdHguYnVpbGRlci5zcGxhdEF0dHIodGhpcy5jdHgudGFibGUuYWxsb2NhdGVCbG9jaygnYXR0cnMnKSwgdGhpcy5jdHgubG9jKG0ubG9jKSk7XG4gICAgfVxuXG4gICAgbGV0IG9mZnNldHMgPSB0aGlzLmN0eC5sb2MobS5sb2MpO1xuICAgIGxldCBuYW1lU2xpY2UgPSBvZmZzZXRzLnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiBtLm5hbWUubGVuZ3RoIH0pLnRvU2xpY2UobS5uYW1lKTtcblxuICAgIGxldCB2YWx1ZSA9IHRoaXMuYXR0clZhbHVlKG0udmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmN0eC5idWlsZGVyLmF0dHIoXG4gICAgICB7IG5hbWU6IG5hbWVTbGljZSwgdmFsdWU6IHZhbHVlLmV4cHIsIHRydXN0aW5nOiB2YWx1ZS50cnVzdGluZyB9LFxuICAgICAgb2Zmc2V0c1xuICAgICk7XG4gIH1cblxuICBwcml2YXRlIG1heWJlRGVwcmVjYXRlZENhbGwoXG4gICAgYXJnOiBTb3VyY2VTbGljZSxcbiAgICBwYXJ0OiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCB8IEFTVHYxLlRleHROb2RlIHwgQVNUdjEuQ29uY2F0U3RhdGVtZW50XG4gICk6IHsgZXhwcjogQVNUdjIuRGVwcmVjYXRlZENhbGxFeHByZXNzaW9uOyB0cnVzdGluZzogYm9vbGVhbiB9IHwgbnVsbCB7XG4gICAgaWYgKHRoaXMuY3R4LnN0cmljdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHBhcnQudHlwZSAhPT0gJ011c3RhY2hlU3RhdGVtZW50Jykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHsgcGF0aCB9ID0gcGFydDtcblxuICAgIGlmIChwYXRoLnR5cGUgIT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwYXRoLmhlYWQudHlwZSAhPT0gJ1ZhckhlYWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgeyBuYW1lIH0gPSBwYXRoLmhlYWQ7XG5cbiAgICBpZiAobmFtZSA9PT0gJ2hhcy1ibG9jaycgfHwgbmFtZSA9PT0gJ2hhcy1ibG9jay1wYXJhbXMnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jdHguaGFzQmluZGluZyhuYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHBhdGgudGFpbC5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwYXJ0LnBhcmFtcy5sZW5ndGggIT09IDAgfHwgcGFydC5oYXNoLnBhaXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGNvbnRleHQgPSBBU1R2Mi5Mb29zZU1vZGVSZXNvbHV0aW9uLmF0dHIoKTtcblxuICAgIGxldCBjYWxsZWUgPSB0aGlzLmN0eC5idWlsZGVyLmZyZWVWYXIoe1xuICAgICAgbmFtZSxcbiAgICAgIGNvbnRleHQsXG4gICAgICBzeW1ib2w6IHRoaXMuY3R4LnRhYmxlLmFsbG9jYXRlRnJlZShuYW1lLCBjb250ZXh0KSxcbiAgICAgIGxvYzogcGF0aC5sb2MsXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXhwcjogdGhpcy5jdHguYnVpbGRlci5kZXByZWNhdGVkQ2FsbChhcmcsIGNhbGxlZSwgcGFydC5sb2MpLFxuICAgICAgdHJ1c3Rpbmc6IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFyZyhhcmc6IEFTVHYxLkF0dHJOb2RlKTogQVNUdjIuQ29tcG9uZW50QXJnIHtcbiAgICBhc3NlcnQoYXJnLm5hbWVbMF0gPT09ICdAJywgJ0FuIGFyZyBuYW1lIG11c3Qgc3RhcnQgd2l0aCBgQGAnKTtcblxuICAgIGxldCBvZmZzZXRzID0gdGhpcy5jdHgubG9jKGFyZy5sb2MpO1xuICAgIGxldCBuYW1lU2xpY2UgPSBvZmZzZXRzLnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiBhcmcubmFtZS5sZW5ndGggfSkudG9TbGljZShhcmcubmFtZSk7XG5cbiAgICBsZXQgdmFsdWUgPSB0aGlzLm1heWJlRGVwcmVjYXRlZENhbGwobmFtZVNsaWNlLCBhcmcudmFsdWUpIHx8IHRoaXMuYXR0clZhbHVlKGFyZy52YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuY3R4LmJ1aWxkZXIuYXJnKFxuICAgICAgeyBuYW1lOiBuYW1lU2xpY2UsIHZhbHVlOiB2YWx1ZS5leHByLCB0cnVzdGluZzogdmFsdWUudHJ1c3RpbmcgfSxcbiAgICAgIG9mZnNldHNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gY2xhc3NpZmllcyB0aGUgaGVhZCBvZiBhbiBBU1R2MS5FbGVtZW50IGludG8gYW4gQVNUdjIuUGF0aEhlYWQgKGlmIHRoZVxuICAgKiBlbGVtZW50IGlzIGEgY29tcG9uZW50KSBvciBgJ0VsZW1lbnRIZWFkJ2AgKGlmIHRoZSBlbGVtZW50IGlzIGEgc2ltcGxlIGVsZW1lbnQpLlxuICAgKlxuICAgKiBSdWxlczpcbiAgICpcbiAgICogMS4gSWYgdGhlIHZhcmlhYmxlIGlzIGFuIGBAYXJnYCwgcmV0dXJuIGFuIGBBdEhlYWRgXG4gICAqIDIuIElmIHRoZSB2YXJpYWJsZSBpcyBgdGhpc2AsIHJldHVybiBhIGBUaGlzSGVhZGBcbiAgICogMy4gSWYgdGhlIHZhcmlhYmxlIGlzIGluIHRoZSBjdXJyZW50IHNjb3BlOlxuICAgKiAgIGEuIElmIHRoZSBzY29wZSBpcyB0aGUgcm9vdCBzY29wZSwgdGhlbiByZXR1cm4gYSBGcmVlIGBMb2NhbFZhckhlYWRgXG4gICAqICAgYi4gRWxzZSwgcmV0dXJuIGEgc3RhbmRhcmQgYExvY2FsVmFySGVhZGBcbiAgICogNC4gSWYgdGhlIHRhZyBuYW1lIGlzIGEgcGF0aCBhbmQgdGhlIHZhcmlhYmxlIGlzIG5vdCBpbiB0aGUgY3VycmVudCBzY29wZSwgU3ludGF4IEVycm9yXG4gICAqIDUuIElmIHRoZSB2YXJpYWJsZSBpcyB1cHBlcmNhc2UgcmV0dXJuIGEgRnJlZVZhcihSZXNvbHZlQXNDb21wb25lbnRIZWFkKVxuICAgKiA2LiBPdGhlcndpc2UsIHJldHVybiBgJ0VsZW1lbnRIZWFkJ2BcbiAgICovXG4gIHByaXZhdGUgY2xhc3NpZnlUYWcoXG4gICAgdmFyaWFibGU6IHN0cmluZyxcbiAgICB0YWlsOiBzdHJpbmdbXSxcbiAgICBsb2M6IFNvdXJjZVNwYW5cbiAgKTogQVNUdjIuRXhwcmVzc2lvbk5vZGUgfCAnRWxlbWVudEhlYWQnIHtcbiAgICBsZXQgdXBwZXJjYXNlID0gaXNVcHBlckNhc2UodmFyaWFibGUpO1xuICAgIGxldCBpblNjb3BlID0gdmFyaWFibGVbMF0gPT09ICdAJyB8fCB2YXJpYWJsZSA9PT0gJ3RoaXMnIHx8IHRoaXMuY3R4Lmhhc0JpbmRpbmcodmFyaWFibGUpO1xuXG4gICAgaWYgKHRoaXMuY3R4LnN0cmljdCAmJiAhaW5TY29wZSkge1xuICAgICAgaWYgKHVwcGVyY2FzZSkge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gaW52b2tlIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBpbiBzY29wZSBpbiBhIHN0cmljdCBtb2RlIHRlbXBsYXRlLCBcXGA8JHt2YXJpYWJsZX0+XFxgLiBJZiB5b3Ugd2FudGVkIHRvIGNyZWF0ZSBhbiBlbGVtZW50IHdpdGggdGhhdCBuYW1lLCBjb252ZXJ0IGl0IHRvIGxvd2VyY2FzZSAtIFxcYDwke3ZhcmlhYmxlLnRvTG93ZXJDYXNlKCl9PlxcYGAsXG4gICAgICAgICAgbG9jXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIEluIHN0cmljdCBtb2RlLCB2YWx1ZXMgYXJlIGFsd2F5cyBlbGVtZW50cyB1bmxlc3MgdGhleSBhcmUgaW4gc2NvcGVcbiAgICAgIHJldHVybiAnRWxlbWVudEhlYWQnO1xuICAgIH1cblxuICAgIC8vIFNpbmNlIHRoZSBwYXJzZXIgaGFuZGVkIHVzIHRoZSBIVE1MIGVsZW1lbnQgbmFtZSBhcyBhIHN0cmluZywgd2UgbmVlZFxuICAgIC8vIHRvIGNvbnZlcnQgaXQgaW50byBhbiBBU1R2MSBwYXRoIHNvIGl0IGNhbiBiZSBwcm9jZXNzZWQgdXNpbmcgdGhlXG4gICAgLy8gZXhwcmVzc2lvbiBub3JtYWxpemVyLlxuICAgIGxldCBpc0NvbXBvbmVudCA9IGluU2NvcGUgfHwgdXBwZXJjYXNlO1xuXG4gICAgbGV0IHZhcmlhYmxlTG9jID0gbG9jLnNsaWNlU3RhcnRDaGFycyh7IHNraXBTdGFydDogMSwgY2hhcnM6IHZhcmlhYmxlLmxlbmd0aCB9KTtcblxuICAgIGxldCB0YWlsTGVuZ3RoID0gdGFpbC5yZWR1Y2UoKGFjY3VtLCBwYXJ0KSA9PiBhY2N1bSArIDEgKyBwYXJ0Lmxlbmd0aCwgMCk7XG4gICAgbGV0IHBhdGhFbmQgPSB2YXJpYWJsZUxvYy5nZXRFbmQoKS5tb3ZlKHRhaWxMZW5ndGgpO1xuICAgIGxldCBwYXRoTG9jID0gdmFyaWFibGVMb2Mud2l0aEVuZChwYXRoRW5kKTtcblxuICAgIGlmIChpc0NvbXBvbmVudCkge1xuICAgICAgbGV0IHBhdGggPSBiLnBhdGgoe1xuICAgICAgICBoZWFkOiBiLmhlYWQodmFyaWFibGUsIHZhcmlhYmxlTG9jKSxcbiAgICAgICAgdGFpbCxcbiAgICAgICAgbG9jOiBwYXRoTG9jLFxuICAgICAgfSk7XG5cbiAgICAgIGxldCByZXNvbHV0aW9uID0gdGhpcy5jdHgucmVzb2x1dGlvbkZvcihwYXRoLCBDb21wb25lbnRTeW50YXhDb250ZXh0KTtcblxuICAgICAgaWYgKHJlc29sdXRpb24ucmVzb2x1dGlvbiA9PT0gJ2Vycm9yJykge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBZb3UgYXR0ZW1wdGVkIHRvIGludm9rZSBhIHBhdGggKFxcYDwke3Jlc29sdXRpb24ucGF0aH0+XFxgKSBidXQgJHtyZXNvbHV0aW9uLmhlYWR9IHdhcyBub3QgaW4gc2NvcGVgLFxuICAgICAgICAgIGxvY1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25Ob3JtYWxpemVyKHRoaXMuY3R4KS5ub3JtYWxpemUocGF0aCwgcmVzb2x1dGlvbi5yZXNvbHV0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdGFnIG5hbWUgd2Fzbid0IGEgdmFsaWQgY29tcG9uZW50IGJ1dCBjb250YWluZWQgYSBgLmAsIGl0J3NcbiAgICAvLyBhIHN5bnRheCBlcnJvci5cbiAgICBpZiAodGFpbC5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgWW91IHVzZWQgJHt2YXJpYWJsZX0uJHt0YWlsLmpvaW4oJy4nKX0gYXMgYSB0YWcgbmFtZSwgYnV0ICR7dmFyaWFibGV9IGlzIG5vdCBpbiBzY29wZWAsXG4gICAgICAgIGxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ0VsZW1lbnRIZWFkJztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGV4cHIoKTogRXhwcmVzc2lvbk5vcm1hbGl6ZXIge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbk5vcm1hbGl6ZXIodGhpcy5jdHgpO1xuICB9XG59XG5cbmNsYXNzIENoaWxkcmVuIHtcbiAgcmVhZG9ubHkgbmFtZWRCbG9ja3M6IEFTVHYyLk5hbWVkQmxvY2tbXTtcbiAgcmVhZG9ubHkgaGFzU2VtYW50aWNDb250ZW50OiBib29sZWFuO1xuICByZWFkb25seSBub25CbG9ja0NoaWxkcmVuOiBBU1R2Mi5Db250ZW50Tm9kZVtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGxvYzogU291cmNlU3BhbixcbiAgICByZWFkb25seSBjaGlsZHJlbjogKEFTVHYyLkNvbnRlbnROb2RlIHwgQVNUdjIuTmFtZWRCbG9jaylbXSxcbiAgICByZWFkb25seSBibG9jazogQmxvY2tDb250ZXh0XG4gICkge1xuICAgIHRoaXMubmFtZWRCbG9ja3MgPSBjaGlsZHJlbi5maWx0ZXIoKGMpOiBjIGlzIEFTVHYyLk5hbWVkQmxvY2sgPT4gYyBpbnN0YW5jZW9mIEFTVHYyLk5hbWVkQmxvY2spO1xuICAgIHRoaXMuaGFzU2VtYW50aWNDb250ZW50ID0gQm9vbGVhbihcbiAgICAgIGNoaWxkcmVuLmZpbHRlcigoYyk6IGMgaXMgQVNUdjIuQ29udGVudE5vZGUgPT4ge1xuICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIEFTVHYyLk5hbWVkQmxvY2spIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdHbGltbWVyQ29tbWVudCc6XG4gICAgICAgICAgY2FzZSAnSHRtbENvbW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNhc2UgJ0h0bWxUZXh0JzpcbiAgICAgICAgICAgIHJldHVybiAhL15cXHMqJC8uZXhlYyhjLmNoYXJzKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pLmxlbmd0aFxuICAgICk7XG4gICAgdGhpcy5ub25CbG9ja0NoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKFxuICAgICAgKGMpOiBjIGlzIEFTVHYyLkNvbnRlbnROb2RlID0+ICEoYyBpbnN0YW5jZW9mIEFTVHYyLk5hbWVkQmxvY2spXG4gICAgKTtcbiAgfVxufVxuXG5jbGFzcyBUZW1wbGF0ZUNoaWxkcmVuIGV4dGVuZHMgQ2hpbGRyZW4ge1xuICBhc3NlcnRUZW1wbGF0ZSh0YWJsZTogUHJvZ3JhbVN5bWJvbFRhYmxlKTogQVNUdjIuVGVtcGxhdGUge1xuICAgIGlmIChpc1ByZXNlbnQodGhpcy5uYW1lZEJsb2NrcykpIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgbmFtZWQgYmxvY2sgYXQgdGhlIHRvcC1sZXZlbCBvZiBhIHRlbXBsYXRlYCwgdGhpcy5sb2MpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJsb2NrLmJ1aWxkZXIudGVtcGxhdGUodGFibGUsIHRoaXMubm9uQmxvY2tDaGlsZHJlbiwgdGhpcy5ibG9jay5sb2ModGhpcy5sb2MpKTtcbiAgfVxufVxuXG5jbGFzcyBCbG9ja0NoaWxkcmVuIGV4dGVuZHMgQ2hpbGRyZW4ge1xuICBhc3NlcnRCbG9jayh0YWJsZTogQmxvY2tTeW1ib2xUYWJsZSk6IEFTVHYyLkJsb2NrIHtcbiAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZWRCbG9ja3MpKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKGBVbmV4cGVjdGVkIG5hbWVkIGJsb2NrIG5lc3RlZCBpbiBhIG5vcm1hbCBibG9ja2AsIHRoaXMubG9jKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLmJsb2NrKHRhYmxlLCB0aGlzLm5vbkJsb2NrQ2hpbGRyZW4sIHRoaXMubG9jKTtcbiAgfVxufVxuXG5jbGFzcyBFbGVtZW50Q2hpbGRyZW4gZXh0ZW5kcyBDaGlsZHJlbiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEJ1aWxkRWxlbWVudCxcbiAgICBsb2M6IFNvdXJjZVNwYW4sXG4gICAgY2hpbGRyZW46IChBU1R2Mi5Db250ZW50Tm9kZSB8IEFTVHYyLk5hbWVkQmxvY2spW10sXG4gICAgYmxvY2s6IEJsb2NrQ29udGV4dFxuICApIHtcbiAgICBzdXBlcihsb2MsIGNoaWxkcmVuLCBibG9jayk7XG4gIH1cblxuICBhc3NlcnROYW1lZEJsb2NrKG5hbWU6IFNvdXJjZVNsaWNlLCB0YWJsZTogQmxvY2tTeW1ib2xUYWJsZSk6IEFTVHYyLk5hbWVkQmxvY2sge1xuICAgIGlmICh0aGlzLmVsLmJhc2Uuc2VsZkNsb3NpbmcpIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgIGA8OiR7bmFtZS5jaGFyc30vPiBpcyBub3QgYSB2YWxpZCBuYW1lZCBibG9jazogbmFtZWQgYmxvY2tzIGNhbm5vdCBiZSBzZWxmLWNsb3NpbmdgLFxuICAgICAgICB0aGlzLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZWRCbG9ja3MpKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZCBuYW1lZCBibG9jayBpbnNpZGUgPDoke25hbWUuY2hhcnN9PiBuYW1lZCBibG9jazogbmFtZWQgYmxvY2tzIGNhbm5vdCBjb250YWluIG5lc3RlZCBuYW1lZCBibG9ja3NgLFxuICAgICAgICB0aGlzLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTG93ZXJDYXNlKG5hbWUuY2hhcnMpKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgPDoke25hbWUuY2hhcnN9PiBpcyBub3QgYSB2YWxpZCBuYW1lZCBibG9jaywgYW5kIG5hbWVkIGJsb2NrcyBtdXN0IGJlZ2luIHdpdGggYSBsb3dlcmNhc2UgbGV0dGVyYCxcbiAgICAgICAgdGhpcy5sb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy5lbC5iYXNlLmF0dHJzLmxlbmd0aCA+IDAgfHxcbiAgICAgIHRoaXMuZWwuYmFzZS5jb21wb25lbnRBcmdzLmxlbmd0aCA+IDAgfHxcbiAgICAgIHRoaXMuZWwuYmFzZS5tb2RpZmllcnMubGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYG5hbWVkIGJsb2NrIDw6JHtuYW1lLmNoYXJzfT4gY2Fubm90IGhhdmUgYXR0cmlidXRlcywgYXJndW1lbnRzLCBvciBtb2RpZmllcnNgLFxuICAgICAgICB0aGlzLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgb2Zmc2V0cyA9IFNwYW5MaXN0LnJhbmdlKHRoaXMubm9uQmxvY2tDaGlsZHJlbiwgdGhpcy5sb2MpO1xuXG4gICAgcmV0dXJuIHRoaXMuYmxvY2suYnVpbGRlci5uYW1lZEJsb2NrKFxuICAgICAgbmFtZSxcbiAgICAgIHRoaXMuYmxvY2suYnVpbGRlci5ibG9jayh0YWJsZSwgdGhpcy5ub25CbG9ja0NoaWxkcmVuLCBvZmZzZXRzKSxcbiAgICAgIHRoaXMubG9jXG4gICAgKTtcbiAgfVxuXG4gIGFzc2VydEVsZW1lbnQobmFtZTogU291cmNlU2xpY2UsIGhhc0Jsb2NrUGFyYW1zOiBib29sZWFuKTogQVNUdjIuU2ltcGxlRWxlbWVudCB7XG4gICAgaWYgKGhhc0Jsb2NrUGFyYW1zKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZCBibG9jayBwYXJhbXMgaW4gPCR7bmFtZX0+OiBzaW1wbGUgZWxlbWVudHMgY2Fubm90IGhhdmUgYmxvY2sgcGFyYW1zYCxcbiAgICAgICAgdGhpcy5sb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJlc2VudCh0aGlzLm5hbWVkQmxvY2tzKSkge1xuICAgICAgbGV0IG5hbWVzID0gdGhpcy5uYW1lZEJsb2Nrcy5tYXAoKGIpID0+IGIubmFtZSk7XG5cbiAgICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgVW5leHBlY3RlZCBuYW1lZCBibG9jayA8OmZvbz4gaW5zaWRlIDwke25hbWUuY2hhcnN9PiBIVE1MIGVsZW1lbnRgLFxuICAgICAgICAgIHRoaXMubG9jXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJpbnRlZE5hbWVzID0gbmFtZXMubWFwKChuKSA9PiBgPDoke24uY2hhcnN9PmApLmpvaW4oJywgJyk7XG4gICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgYFVuZXhwZWN0ZWQgbmFtZWQgYmxvY2tzIGluc2lkZSA8JHtuYW1lLmNoYXJzfT4gSFRNTCBlbGVtZW50ICgke3ByaW50ZWROYW1lc30pYCxcbiAgICAgICAgICB0aGlzLmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsLnNpbXBsZShuYW1lLCB0aGlzLm5vbkJsb2NrQ2hpbGRyZW4sIHRoaXMubG9jKTtcbiAgfVxuXG4gIGFzc2VydENvbXBvbmVudChcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgdGFibGU6IEJsb2NrU3ltYm9sVGFibGUsXG4gICAgaGFzQmxvY2tQYXJhbXM6IGJvb2xlYW5cbiAgKTogUHJlc2VudEFycmF5PEFTVHYyLk5hbWVkQmxvY2s+IHtcbiAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZWRCbG9ja3MpICYmIHRoaXMuaGFzU2VtYW50aWNDb250ZW50KSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZCBjb250ZW50IGluc2lkZSA8JHtuYW1lfT4gY29tcG9uZW50IGludm9jYXRpb246IHdoZW4gdXNpbmcgbmFtZWQgYmxvY2tzLCB0aGUgdGFnIGNhbm5vdCBjb250YWluIG90aGVyIGNvbnRlbnRgLFxuICAgICAgICB0aGlzLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZWRCbG9ja3MpKSB7XG4gICAgICBpZiAoaGFzQmxvY2tQYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgVW5leHBlY3RlZCBibG9jayBwYXJhbXMgbGlzdCBvbiA8JHtuYW1lfT4gY29tcG9uZW50IGludm9jYXRpb246IHdoZW4gcGFzc2luZyBuYW1lZCBibG9ja3MsIHRoZSBpbnZvY2F0aW9uIHRhZyBjYW5ub3QgdGFrZSBibG9jayBwYXJhbXNgLFxuICAgICAgICAgIHRoaXMubG9jXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCBzZWVuTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgICAgZm9yIChsZXQgYmxvY2sgb2YgdGhpcy5uYW1lZEJsb2Nrcykge1xuICAgICAgICBsZXQgbmFtZSA9IGJsb2NrLm5hbWUuY2hhcnM7XG5cbiAgICAgICAgaWYgKHNlZW5OYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgICAgYENvbXBvbmVudCBoYWQgdHdvIG5hbWVkIGJsb2NrcyB3aXRoIHRoZSBzYW1lIG5hbWUsIFxcYDw6JHtuYW1lfT5cXGAuIE9ubHkgb25lIGJsb2NrIHdpdGggYSBnaXZlbiBuYW1lIG1heSBiZSBwYXNzZWRgLFxuICAgICAgICAgICAgdGhpcy5sb2NcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIChuYW1lID09PSAnaW52ZXJzZScgJiYgc2Vlbk5hbWVzLmhhcygnZWxzZScpKSB8fFxuICAgICAgICAgIChuYW1lID09PSAnZWxzZScgJiYgc2Vlbk5hbWVzLmhhcygnaW52ZXJzZScpKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgICAgYENvbXBvbmVudCBoYXMgYm90aCA8OmVsc2U+IGFuZCA8OmludmVyc2U+IGJsb2NrLiA8OmludmVyc2U+IGlzIGFuIGFsaWFzIGZvciA8OmVsc2U+YCxcbiAgICAgICAgICAgIHRoaXMubG9jXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlZW5OYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm5hbWVkQmxvY2tzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aGlzLmJsb2NrLmJ1aWxkZXIubmFtZWRCbG9jayhcbiAgICAgICAgICBTb3VyY2VTbGljZS5zeW50aGV0aWMoJ2RlZmF1bHQnKSxcbiAgICAgICAgICB0aGlzLmJsb2NrLmJ1aWxkZXIuYmxvY2sodGFibGUsIHRoaXMubm9uQmxvY2tDaGlsZHJlbiwgdGhpcy5sb2MpLFxuICAgICAgICAgIHRoaXMubG9jXG4gICAgICAgICksXG4gICAgICBdO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFBhdGgobm9kZTogQVNUdjEuUGF0aEV4cHJlc3Npb24gfCBBU1R2MS5DYWxsTm9kZSk6IHN0cmluZyB7XG4gIGlmIChub2RlLnR5cGUgIT09ICdQYXRoRXhwcmVzc2lvbicgJiYgbm9kZS5wYXRoLnR5cGUgPT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICByZXR1cm4gcHJpbnRQYXRoKG5vZGUucGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBQcmludGVyKHsgZW50aXR5RW5jb2Rpbmc6ICdyYXcnIH0pLnByaW50KG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50SGVhZChub2RlOiBBU1R2MS5QYXRoRXhwcmVzc2lvbiB8IEFTVHYxLkNhbGxOb2RlKTogc3RyaW5nIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ1BhdGhFeHByZXNzaW9uJykge1xuICAgIHN3aXRjaCAobm9kZS5oZWFkLnR5cGUpIHtcbiAgICAgIGNhc2UgJ0F0SGVhZCc6XG4gICAgICBjYXNlICdWYXJIZWFkJzpcbiAgICAgICAgcmV0dXJuIG5vZGUuaGVhZC5uYW1lO1xuICAgICAgY2FzZSAnVGhpc0hlYWQnOlxuICAgICAgICByZXR1cm4gJ3RoaXMnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnBhdGgudHlwZSA9PT0gJ1BhdGhFeHByZXNzaW9uJykge1xuICAgIHJldHVybiBwcmludEhlYWQobm9kZS5wYXRoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFByaW50ZXIoeyBlbnRpdHlFbmNvZGluZzogJ3JhdycgfSkucHJpbnQobm9kZSk7XG4gIH1cbn1cbiIsImV4cG9ydCB0eXBlIEtleXdvcmRUeXBlID0gJ0NhbGwnIHwgJ01vZGlmaWVyJyB8ICdBcHBlbmQnIHwgJ0Jsb2NrJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzS2V5d29yZCh3b3JkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHdvcmQgaW4gS0VZV09SRFNfVFlQRVM7XG59XG5cbi8qKlxuICogVGhpcyBpbmNsdWRlcyB0aGUgZnVsbCBsaXN0IG9mIGtleXdvcmRzIGN1cnJlbnRseSBpbiB1c2UgaW4gdGhlIHRlbXBsYXRlXG4gKiBsYW5ndWFnZSwgYW5kIHdoZXJlIHRoZWlyIHZhbGlkIHVzYWdlcyBhcmUuXG4gKi9cbmV4cG9ydCBjb25zdCBLRVlXT1JEU19UWVBFUzogeyBba2V5OiBzdHJpbmddOiBLZXl3b3JkVHlwZVtdIH0gPSB7XG4gIGNvbXBvbmVudDogWydDYWxsJywgJ0FwcGVuZCcsICdCbG9jayddLFxuICBkZWJ1Z2dlcjogWydBcHBlbmQnXSxcbiAgJ2VhY2gtaW4nOiBbJ0Jsb2NrJ10sXG4gIGVhY2g6IFsnQmxvY2snXSxcbiAgJ2hhcy1ibG9jay1wYXJhbXMnOiBbJ0NhbGwnLCAnQXBwZW5kJ10sXG4gICdoYXMtYmxvY2snOiBbJ0NhbGwnLCAnQXBwZW5kJ10sXG4gIGhlbHBlcjogWydDYWxsJywgJ0FwcGVuZCddLFxuICBpZjogWydDYWxsJywgJ0FwcGVuZCcsICdCbG9jayddLFxuICAnaW4tZWxlbWVudCc6IFsnQmxvY2snXSxcbiAgbGV0OiBbJ0Jsb2NrJ10sXG4gICdsaW5rLXRvJzogWydBcHBlbmQnLCAnQmxvY2snXSxcbiAgbG9nOiBbJ0NhbGwnLCAnQXBwZW5kJ10sXG4gIG1vZGlmaWVyOiBbJ0NhbGwnXSxcbiAgbW91bnQ6IFsnQXBwZW5kJ10sXG4gIG11dDogWydDYWxsJywgJ0FwcGVuZCddLFxuICBvdXRsZXQ6IFsnQXBwZW5kJ10sXG4gICdxdWVyeS1wYXJhbXMnOiBbJ0NhbGwnXSxcbiAgcmVhZG9ubHk6IFsnQ2FsbCcsICdBcHBlbmQnXSxcbiAgdW5ib3VuZDogWydDYWxsJywgJ0FwcGVuZCddLFxuICB1bmxlc3M6IFsnQ2FsbCcsICdBcHBlbmQnLCAnQmxvY2snXSxcbiAgd2l0aDogWydCbG9jayddLFxuICB5aWVsZDogWydBcHBlbmQnXSxcbn07XG4iLCJpbXBvcnQgeyBpc0tleXdvcmQgfSBmcm9tICcuL2tleXdvcmRzJztcbmltcG9ydCB7IHByZXByb2Nlc3MgfSBmcm9tICcuL3BhcnNlci90b2tlbml6ZXItZXZlbnQtaGFuZGxlcnMnO1xuaW1wb3J0IHRyYXZlcnNlIGZyb20gJy4vdHJhdmVyc2FsL3RyYXZlcnNlJztcbmltcG9ydCAqIGFzIEFTVHYxIGZyb20gJy4vdjEvYXBpJztcblxuaW50ZXJmYWNlIEdldFRlbXBsYXRlTG9jYWxzT3B0aW9ucyB7XG4gIGluY2x1ZGVLZXl3b3Jkcz86IGJvb2xlYW47XG4gIGluY2x1ZGVIdG1sRWxlbWVudHM/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGNvcnJlY3QgVG9rZW4gZnJvbSB0aGUgTm9kZSBiYXNlZCBvbiBpdCdzIHR5cGVcbiAqL1xuZnVuY3Rpb24gdG9rZW5zRnJvbVR5cGUoXG4gIG5vZGU6IEFTVHYxLk5vZGUsXG4gIHNjb3BlZFRva2Vuczogc3RyaW5nW10sXG4gIG9wdGlvbnM6IEdldFRlbXBsYXRlTG9jYWxzT3B0aW9uc1xuKTogc3RyaW5nIHwgdm9pZCB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICBpZiAobm9kZS5oZWFkLnR5cGUgPT09ICdBdEhlYWQnIHx8IG5vZGUuaGVhZC50eXBlID09PSAnVGhpc0hlYWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcG9zc2JsZVRva2VuID0gbm9kZS5oZWFkLm5hbWU7XG5cbiAgICBpZiAoc2NvcGVkVG9rZW5zLmluZGV4T2YocG9zc2JsZVRva2VuKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBwb3NzYmxlVG9rZW47XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0VsZW1lbnROb2RlJykge1xuICAgIGNvbnN0IHsgdGFnIH0gPSBub2RlO1xuXG4gICAgY29uc3QgY2hhciA9IHRhZy5jaGFyQXQoMCk7XG5cbiAgICBpZiAoY2hhciA9PT0gJzonIHx8IGNoYXIgPT09ICdAJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlSHRtbEVsZW1lbnRzICYmIHRhZy5pbmRleE9mKCcuJykgPT09IC0xICYmIHRhZy50b0xvd2VyQ2FzZSgpID09PSB0YWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGFnLnN1YnN0cigwLCA1KSA9PT0gJ3RoaXMuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzY29wZWRUb2tlbnMuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0YWc7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIHRva2VucyB0byB0aGUgdG9rZW5zU2V0IGJhc2VkIG9uIHRoZWlyIG5vZGUudHlwZVxuICovXG5mdW5jdGlvbiBhZGRUb2tlbnMoXG4gIHRva2Vuc1NldDogU2V0PHN0cmluZz4sXG4gIG5vZGU6IEFTVHYxLk5vZGUsXG4gIHNjb3BlZFRva2Vuczogc3RyaW5nW10sXG4gIG9wdGlvbnM6IEdldFRlbXBsYXRlTG9jYWxzT3B0aW9uc1xuKSB7XG4gIGNvbnN0IG1heWJlVG9rZW5zID0gdG9rZW5zRnJvbVR5cGUobm9kZSwgc2NvcGVkVG9rZW5zLCBvcHRpb25zKTtcblxuICAoQXJyYXkuaXNBcnJheShtYXliZVRva2VucykgPyBtYXliZVRva2VucyA6IFttYXliZVRva2Vuc10pLmZvckVhY2goKG1heWJlVG9rZW4pID0+IHtcbiAgICBpZiAobWF5YmVUb2tlbiAhPT0gdW5kZWZpbmVkICYmIG1heWJlVG9rZW5bMF0gIT09ICdAJykge1xuICAgICAgdG9rZW5zU2V0LmFkZChtYXliZVRva2VuLnNwbGl0KCcuJylbMF0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2VzIGFuZCB0cmF2ZXJzZXMgYSBnaXZlbiBoYW5kbGViYXJzIGh0bWwgdGVtcGxhdGUgdG8gZXh0cmFjdCBhbGwgdGVtcGxhdGUgbG9jYWxzXG4gKiByZWZlcmVuY2VkIHRoYXQgY291bGQgcG9zc2libGUgY29tZSBmcm9tIHRoZSBwcmFlbnQgc2NvcGUuIENhbiBleGNsdWRlIGtub3duIGtleXdvcmRzXG4gKiBvcHRpb25hbGx5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGVtcGxhdGVMb2NhbHMoXG4gIGh0bWw6IHN0cmluZyxcbiAgb3B0aW9uczogR2V0VGVtcGxhdGVMb2NhbHNPcHRpb25zID0ge1xuICAgIGluY2x1ZGVIdG1sRWxlbWVudHM6IGZhbHNlLFxuICAgIGluY2x1ZGVLZXl3b3JkczogZmFsc2UsXG4gIH1cbik6IHN0cmluZ1tdIHtcbiAgY29uc3QgYXN0ID0gcHJlcHJvY2VzcyhodG1sKTtcbiAgY29uc3QgdG9rZW5zU2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGNvbnN0IHNjb3BlZFRva2Vuczogc3RyaW5nW10gPSBbXTtcblxuICB0cmF2ZXJzZShhc3QsIHtcbiAgICBCbG9jazoge1xuICAgICAgZW50ZXIoeyBibG9ja1BhcmFtcyB9KSB7XG4gICAgICAgIGJsb2NrUGFyYW1zLmZvckVhY2goKHBhcmFtKSA9PiB7XG4gICAgICAgICAgc2NvcGVkVG9rZW5zLnB1c2gocGFyYW0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIGV4aXQoeyBibG9ja1BhcmFtcyB9KSB7XG4gICAgICAgIGJsb2NrUGFyYW1zLmZvckVhY2goKCkgPT4ge1xuICAgICAgICAgIHNjb3BlZFRva2Vucy5wb3AoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgIH0sXG5cbiAgICBFbGVtZW50Tm9kZToge1xuICAgICAgZW50ZXIobm9kZSkge1xuICAgICAgICBub2RlLmJsb2NrUGFyYW1zLmZvckVhY2goKHBhcmFtKSA9PiB7XG4gICAgICAgICAgc2NvcGVkVG9rZW5zLnB1c2gocGFyYW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYWRkVG9rZW5zKHRva2Vuc1NldCwgbm9kZSwgc2NvcGVkVG9rZW5zLCBvcHRpb25zKTtcbiAgICAgIH0sXG5cbiAgICAgIGV4aXQoeyBibG9ja1BhcmFtcyB9KSB7XG4gICAgICAgIGJsb2NrUGFyYW1zLmZvckVhY2goKCkgPT4ge1xuICAgICAgICAgIHNjb3BlZFRva2Vucy5wb3AoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgIH0sXG5cbiAgICBQYXRoRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICBhZGRUb2tlbnModG9rZW5zU2V0LCBub2RlLCBzY29wZWRUb2tlbnMsIG9wdGlvbnMpO1xuICAgIH0sXG4gIH0pO1xuXG4gIGxldCB0b2tlbnM6IHN0cmluZ1tdID0gW107XG5cbiAgdG9rZW5zU2V0LmZvckVhY2goKHMpID0+IHRva2Vucy5wdXNoKHMpKTtcblxuICBpZiAoIW9wdGlvbnM/LmluY2x1ZGVLZXl3b3Jkcykge1xuICAgIHRva2VucyA9IHRva2Vucy5maWx0ZXIoKHRva2VuKSA9PiAhaXNLZXl3b3JkKHRva2VuKSk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufVxuIl0sIm5hbWVzIjpbImlzUHJlc2VudCIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwiYXNzZXJ0TmV2ZXIiLCJERUJVRyIsImIiLCJhc3NpZ24iLCJ0dXBsZSIsImhlYWRUb1N0cmluZyIsIkVudGl0eVBhcnNlciIsIm5hbWVkQ2hhclJlZnMiLCJFdmVudGVkVG9rZW5pemVyIiwiYXNzZXJ0UHJlc2VudCIsInByaW50IiwicGFyc2VXaXRob3V0UHJvY2Vzc2luZyIsInBhcnNlIiwiZGljdCIsIkFTVHYyLlRlbXBsYXRlIiwiQVNUdjIuQmxvY2siLCJBU1R2Mi5OYW1lZEJsb2NrIiwiQVNUdjIuQXJncyIsIkFTVHYyLlBvc2l0aW9uYWxBcmd1bWVudHMiLCJBU1R2Mi5OYW1lZEFyZ3VtZW50IiwiQVNUdjIuTmFtZWRBcmd1bWVudHMiLCJBU1R2Mi5IdG1sQXR0ciIsIkFTVHYyLlNwbGF0QXR0ciIsIkFTVHYyLkNvbXBvbmVudEFyZyIsIkFTVHYyLlBhdGhFeHByZXNzaW9uIiwiQVNUdjIuVGhpc1JlZmVyZW5jZSIsIkFTVHYyLkFyZ1JlZmVyZW5jZSIsIkFTVHYyLkZyZWVWYXJSZWZlcmVuY2UiLCJBU1R2Mi5Mb2NhbFZhclJlZmVyZW5jZSIsIkFTVHYyLkNhbGxFeHByZXNzaW9uIiwiQVNUdjIuRGVwcmVjYXRlZENhbGxFeHByZXNzaW9uIiwiQVNUdjIuSW50ZXJwb2xhdGVFeHByZXNzaW9uIiwiQVNUdjIuTGl0ZXJhbEV4cHJlc3Npb24iLCJBU1R2Mi5BcHBlbmRDb250ZW50IiwiQVNUdjIuRWxlbWVudE1vZGlmaWVyIiwiQVNUdjIuTmFtZWRCbG9ja3MiLCJBU1R2Mi5JbnZva2VCbG9jayIsIkFTVHYyLlNpbXBsZUVsZW1lbnQiLCJBU1R2Mi5JbnZva2VDb21wb25lbnQiLCJBU1R2Mi5Mb29zZU1vZGVSZXNvbHV0aW9uIiwiQVNUdjIuU1RSSUNUX1JFU09MVVRJT04iLCJBU1R2Mi5BUkdVTUVOVF9SRVNPTFVUSU9OIiwiQVNUdjIuSHRtbENvbW1lbnQiLCJBU1R2Mi5IdG1sVGV4dCIsIkFTVHYyLkdsaW1tZXJDb21tZW50Il0sIm1hcHBpbmdzIjoiOztFQWlCTyxJQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBTixNQUFBLENBQWM7RUFDNUMsRUFBQSxJQUFJLEVBRHdDLENBQUE7RUFFNUMsRUFBQSxNQUFNLEVBQUU7RUFGb0MsQ0FBZCxDQUF6QjtFQUtBLElBQU0sa0JBQWtCLEdBQUcsTUFBTSxDQUFOLE1BQUEsQ0FBYztFQUM5QyxFQUFBLE1BQU0sRUFEd0MsYUFBQTtFQUU5QyxFQUFBLEtBQUssRUFGeUMsZ0JBQUE7RUFHOUMsRUFBQSxHQUFHLEVBQUU7RUFIeUMsQ0FBZCxDQUEzQjtFQVNBLElBQU0sa0JBQWtCLEdBQUcsTUFBTSxDQUFOLE1BQUEsQ0FBYztFQUM5QyxFQUFBLE1BQU0sRUFEd0MsYUFBQTtFQUU5QyxFQUFBLEtBQUssRUFGeUMsZ0JBQUE7RUFHOUMsRUFBQSxHQUFHLEVBQUU7RUFIeUMsQ0FBZCxDQUEzQjtFQU1BLElBQU0scUJBQXFCLEdBQUcsTUFBTSxDQUFOLE1BQUEsQ0FBYztFQUNqRCxFQUFBLE1BQU0sRUFEMkMsZUFBQTtFQUVqRCxFQUFBLEtBQUssRUFG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
